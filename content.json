{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://scarlett9354.github.io","root":"/"},"pages":[{"title":"关于","date":"2021-04-26T06:06:43.856Z","updated":"2021-04-26T06:06:43.856Z","comments":false,"path":"about/index.html","permalink":"https://scarlett9354.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2021-04-26T06:06:43.856Z","updated":"2021-04-26T06:06:43.856Z","comments":false,"path":"books/index.html","permalink":"https://scarlett9354.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-04-26T06:06:43.856Z","updated":"2021-04-26T06:06:43.856Z","comments":false,"path":"categories/index.html","permalink":"https://scarlett9354.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-04-26T06:06:43.856Z","updated":"2021-04-26T06:06:43.856Z","comments":true,"path":"links/index.html","permalink":"https://scarlett9354.github.io/links/index.html","excerpt":"","text":""},{"title":"小桔子的部落格","date":"2021-04-27T09:43:41.258Z","updated":"2021-04-27T09:43:41.258Z","comments":false,"path":"repository/index.html","permalink":"https://scarlett9354.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-04-26T06:06:43.856Z","updated":"2021-04-26T06:06:43.856Z","comments":false,"path":"tags/index.html","permalink":"https://scarlett9354.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"前端LeetCode题目","slug":"前端LeetCode题目","date":"2021-08-20T02:57:23.000Z","updated":"2021-08-24T08:43:11.382Z","comments":true,"path":"2021/08/20/前端LeetCode题目/","link":"","permalink":"https://scarlett9354.github.io/2021/08/20/%E5%89%8D%E7%AB%AFLeetCode%E9%A2%98%E7%9B%AE/","excerpt":"","text":"GitHub：https://github.com/scarlett9354/js-leetcode每日打卡更新中，欢迎关注。 26. 删除排序数组中的重复项给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 解释：函数应该返回新的去重后的长度 len ，并且原数组 nums 的前len个元素被修改为 [x, x, …] 。不需要考虑数组中超出新长度后面的元素。 思路 由于给定的数组 nums 是有序的，因此对于任意 i&lt;j，如果 nums[i]=nums[j]，则对任意 i≤k≤j，必有 nums[i]=nums[k]=nums[j]，即相等的元素在数组中的下标一定是连续的。利用数组有序的特点，可以通过双指针的方法删除重复元素。 1234567891011121314151617181920212223242526272829303132333435363738function removeDuplicates(nums) &#123; // 假设数组 nums 的长度为 n const n = nums.length // 如果数组 nums 的长度为 0，则数组不包含任何元素，因此返回 0。 if (n === 0) return 0 // 当数组 nums 的长度大于 0 时，数组中至少包含一个元素，在删除重复元素之后也至少剩下一个元素，因此 nums[0] 保持原状即可，从下标 1 开始删除重复元素 // 定义两个指针 fast 和 slow 分别为快指针和慢指针，快指针表示遍历数组到达的下标位置，慢指针表示下一个不同元素要填入的下标位置，初始时两个指针都指向下标 1 let fast = 1, slow = 1 // 将快指针 fast 依次遍历从 1 到 n−1 的每个位置 while (fast &lt; n) &#123; // 对于每个位置，如果 nums[fast] ≠ nums[fast−1]，说明 nums[fast] 和之前的元素都不同 if (nums[fast] !== nums[fast - 1]) &#123; // 因此将 nums[fast] 的值复制到 nums[slow] nums[slow] = nums[fast] // 然后将 slow 的值加 1，即指向下一个位置 ++slow &#125; ++fast &#125; // 遍历结束之后，从 nums[0] 到 nums[slow−1] 的每个元素都不相同且包含原数组中的每个不同的元素，因此新的长度即为 slow，返回 slow 即可 return slow&#125;// 示例1const nums1 = [1, 1, 2]console.log(removeDuplicates(nums1)) // 2console.log(nums1) // [1, 2, 2]// 示例2const nums2 = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]const len = removeDuplicates(nums2)console.log(len) // 5console.log(nums2) // [0, 1, 2, 3, 4, 2, 2, 3, 3, 4]console.log(filterTargetsByLength(nums2, len)) // [0, 1, 2, 3, 4]// 过滤出前len项function filterTargetsByLength(arr, len) &#123; return arr.filter((item, index) =&gt; index &lt; len)&#125; 复杂度分析 时间复杂度：O(n)，其中 n 是数组的长度。快指针和慢指针最多各移动 n 次。 空间复杂度：O(1)。只需要使用常数的额外空间。 27. 移除元素给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 思路 如果要移除的元素恰好在数组的开头，例如序列[1,2,3,4,5]，当 \\textit{val}val 为 11 时，我们需要把每一个元素都左移一位。 注意到题目中说：「元素的顺序可以改变」。实际上我们可以直接将最后一个元素 5 移动到序列开头，取代元素 1，得到序列 [5,2,3,4]，同样满足题目要求。这个方法在序列中 val 元素的数量较少时非常有效。 实现方面，我们依然使用双指针，两个指针初始时分别位于数组的首尾，向中间移动遍历该序列。 12345678910111213141516171819202122232425262728function removeElement(nums, val) &#123; let left = 0, right = nums.length while (left &lt; right) &#123; // 如果左指针 left 指向的元素等于 val if (nums[left] === val) &#123; // 此时将右指针 right 指向的元素复制到左指针 left 的位置 nums[left] = nums[right - 1] // 并将这个元素从数组中删除 nums.splice(right - 1, 1) // 然后右指针 right 左移一位 right-- &#125; else &#123; // 左指针 left 指向的元素如果不等于val，left 右移一位 left++ &#125; // 如果赋值过来的元素恰好也等于 val，可以继续把右指针 right 指向的元素的值赋值过来（左指针 left 指向的等于 val 的元素的位置继续被覆盖），直到左指针指向的元素的值不等于 val 为止。 // 当左指针 left 和右指针 right 重合的时候，左右指针遍历完数组中所有的元素。 &#125; return left&#125;// 示例1const nums1 = [3,2,2,3], val1 = 3console.log(removeElement(nums1, val1), nums1) // 2 [2, 2, 2, 3]// 示例2const nums2 = [0, 1, 2, 2, 3, 0, 4, 2], val2 = 2console.log(removeElement(nums2, val2), nums2) // 5 [0, 1, 4, 0, 3, 0, 4, 2] 这个方法两个指针在最坏的情况下合起来只遍历了数组一次，避免了需要保留的元素的重复赋值操作。 复杂度分析 时间复杂度：O(n)，其中 n 为序列的长度。我们只需要遍历该序列至多一次。 空间复杂度：O(1)。我们只需要常数的空间保存若干变量。 35. 搜索插入位置给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 请必须使用时间复杂度为 O(log n) 的算法。 思路：二分查找 如果一个问题中，待查找的数是整数，且知道范围，大概就可以使用二分查找算法。 从题干中我们可以得出最后的目标：在一个有序数组中找第一个大于等于 target 的下标。 1234567891011121314151617181920212223242526272829303132333435363738function searchInsert(nums, target) &#123; const n = nums.length // 先设定左侧下标 left 和右侧下标 right let left = 0, right = n - 1 while (left &lt;= right) &#123; // 计算中间下标 mid，这样写是防止大数溢出 let mid = ((right - left) &gt;&gt; 1) + left // 每次根据nums[mid] 和 target 之间的大小进行判断 if (target === nums[mid]) &#123; // 相等则直接返回下标 return mid &#125; else if (target &lt; nums[mid]) &#123; // right 左移 right = mid - 1 &#125; else &#123; // left 右移 left = mid + 1 &#125; &#125; // 查找结束，如果没用相等值则返回left，该值为插入位置 return left&#125;// 示例1const nums1 = [1, 3, 5, 6], target1 = 5console.log(searchInsert(nums1, target1)) // 2// 示例2const target2 = 2console.log(searchInsert(nums1, target2)) // 1// 示例3const target3 = 7console.log(searchInsert(nums1, target3)) // 4// 示例4const target4 = 0console.log(searchInsert(nums1, target4)) // 0// 示例5const nums2 = [1]console.log(searchInsert(nums2, target4)) // 0 复杂度分析 时间复杂度：O(log n)，其中 n 为数组的长度。二分查找所需的时间复杂度为 O(log n)。 空间复杂度：O(1)。我们只需要常数空间存放若干变量。","categories":[{"name":"算法","slug":"算法","permalink":"https://scarlett9354.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://scarlett9354.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"React17+React Hook+TS4 最佳实践，仿 Jira 企业级项目(三)","slug":"React17-ReactHook-TS4最佳实践，仿Jira企业级项目-三","date":"2021-08-19T08:42:53.000Z","updated":"2021-11-12T07:41:37.990Z","comments":true,"path":"2021/08/19/React17-ReactHook-TS4最佳实践，仿Jira企业级项目-三/","link":"","permalink":"https://scarlett9354.github.io/2021/08/19/React17-ReactHook-TS4%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%8C%E4%BB%BFJira%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%A1%B9%E7%9B%AE-%E4%B8%89/","excerpt":"","text":"第10章 深入React 状态管理与Redux机制10-1 useCallback应用，优化异步请求本节主要处理两个问题： 接口请求太慢(比如需要3s)，此时如果被打断，会报错：Can’t perform a React state update on an unmounted component； 之前被disable禁掉的依赖。 问题1的原因在代码中src\\utils\\use-async.ts描述为： 在run()方法中要经过3s才能setDate(data)，但在3s还没有完成就切换了页面，项目列表页的useAsync就被注销了，但是这个异步任务还存在，当3s完成后还是会进行setData()，由于页面组件已经被卸载了，就会导致上面的报错。怎么解决呢？ 在src\\utils\\index.ts添加hook： 123456789101112131415/** * 返回组件的挂载状态，如果还没挂载或者已经卸载，返回false；反之，返回true */export const useMountedRef = () =&gt; &#123; const mountedRef = useRef(false) useEffect(() =&gt; &#123; // 在页面渲染完成后调用 mountedRef.current = true return () =&gt; &#123; // 在被卸载时 mountedRef.current = false &#125; &#125;) return mountedRef&#125; 在src\\utils\\use-async.ts中使用： 1234567891011121314export const useAsync = &lt;D&gt;(initialState?: State&lt;D&gt;, initialConfig?: typeof defaultConfig) =&gt; &#123; const mountedRef = useMountedRef() const run = (promise: Promise&lt;D&gt;, runConfig?: &#123; retry: () =&gt; Promise&lt;D&gt; &#125;) =&gt; &#123; ... return promise.then(data =&gt; &#123; // 如果为true，说明组件已经被挂载而不是被卸载的状态，在这个时候才设置data if (mountedRef.current) setData(data) return data &#125;).catch(error =&gt; &#123; ... &#125;) &#125;&#125; 问题2 那些被disabled的依赖既不属于基本类型，又不属于state，所以作为依赖时会造成无限循环，使用callback()解决： 先解决第1处disabled的地方src\\utils\\project.ts： 12345678export const useProjects = (param?: Partial&lt;Project&gt;) =&gt; &#123; useEffect(() =&gt; &#123; run(fetchProjects(), &#123; retry: fetchProjects &#125;) &#125;, [param, run, fetchProjects]) return result&#125; 这里有依赖了两个方法：run和fetchProjects 依赖run()方法，在src\\utils\\use-async.ts中用callback解决： 123456789101112131415161718192021222324252627export const useAsync = &lt;D&gt;(initialState?: State&lt;D&gt;, initialConfig?: typeof defaultConfig) =&gt; &#123; const [state, setState] = useState&lt;State&lt;D&gt;&gt;(&#123; ...defaultInitialState, ...initialState &#125;) const run = useCallback((promise: Promise&lt;D&gt;, runConfig?: &#123; retry: () =&gt; Promise&lt;D&gt; &#125;) =&gt; &#123; if (!promise || !promise.then) &#123; throw new Error(&#x27;请传入 Promise 类型数据&#x27;) &#125; setRetry(() =&gt; () =&gt; &#123; if (runConfig?.retry) &#123; run(runConfig?.retry(), runConfig) &#125; &#125;) setState(&#123; ...state, stat: &#x27;loading&#x27; &#125;) return promise.then(data =&gt; &#123; if (mountedRef.current) setData(data) return data &#125;).catch(error =&gt; &#123; setError(error) if (config.throwOnError) return Promise.reject(error) return error &#125;) &#125;, [config.throwOnError, mountedRef, setData, state, setError]) return ...&#125; run()又依赖了setData()和setError()，用callback如下： 1234567891011const setData = useCallback((data: D) =&gt; setState(&#123; data, stat: &#x27;success&#x27;, error: null&#125;), [])const setError = useCallback((error: Error) =&gt; setState(&#123; error, stat: &#x27;error&#x27;, data: null&#125;), []) 上面仍存在一个问题，就是依赖了state，然后在方法里又setState用到这个state，也会造成无限循环，这也是useCallback()常见的问题，不要在回调函数中用到state，要采用setState的函数用法，这样在依赖里就不需要用state了： 1234const run = useCallback((promise: Promise&lt;D&gt;, runConfig?: &#123; retry: () =&gt; Promise&lt;D&gt; &#125;) =&gt; &#123; setState(prevState =&gt; (&#123; ...prevState, stat: &#x27;loading&#x27; &#125;)) ...&#125;, [config.throwOnError, mountedRef, setData, setError]) 依赖fetchProjects()方法，在上面的要用callback解决： 12const client = useHttp()const fetchProjects = useCallback(() =&gt; client(&#x27;projects&#x27;, &#123; data: cleanObject(param || &#123;&#125;) &#125;), [client, param]) fetchProjects()依赖client方法，在src\\utils\\http.ts中用callback： 1234567export const useHttp = () =&gt; &#123; const &#123; user &#125; = useAuth() return useCallback( (...[endpoint, config]: Parameters&lt;typeof http&gt;) =&gt; http(endpoint, &#123; ...config, token: user?.token &#125;), [user?.token] )&#125; 总结： useMemo()和useCallback()都是为了依赖而存在的，具体地说，如果定义的非基本类型想用作依赖，就需要用二者之一把它们限制住，让它们不要每次在页面渲染时重新创建。 通常，在自定义hook中如果要返回函数，这里的函数大概率要用到useCallback()限制，当别人在useEffect()中使用时，eslint很有可能会提示将其加到依赖里，所以我们索性就在定义时提前限制住吧！ 10-2 状态提升，组合组件与控制反转(上)公用的创建项目侧边drawer，被多处使用，先用状态提升的方式实现这种组件间共享状态： 先找到这些共享状态的组件的最近的父组件src\\authenticated-app.tsx： 1234567export const AuthenticatedApp = () =&gt; &#123; const [projectModalOpen, setProjectModalOpen] = useState(false) return &lt;Container&gt; ... &lt;ProjectModal projectModalOpen=&#123;projectModalOpen&#125; onClose=&#123;() =&gt; setProjectModalOpen(false)&#125; /&gt; &lt;/Container&gt;&#125; 创建modal组件src\\screens\\project-list\\project-modal.tsx： 123456789import &#123; Button, Drawer &#125; from &quot;antd&quot;;import React from &quot;react&quot;;export const ProjectModal = (props: &#123; projectModalOpen: boolean, onClose: () =&gt; void &#125;) =&gt; &#123; return &lt;Drawer onClose=&#123;props.onClose&#125; visible=&#123;props.projectModalOpen&#125; width=&#123;&#x27;100%&#x27;&#125;&gt; &lt;h1&gt;Project Modal&lt;/h1&gt; &lt;Button onClick=&#123;props.onClose&#125;&gt;关闭&lt;/Button&gt; &lt;/Drawer&gt;&#125; 创建popover组件src\\components\\project-popover.tsx： 123456789101112131415161718192021222324252627import styled from &quot;@emotion/styled&quot;;import &#123; List, Popover, Typography &#125; from &quot;antd&quot;;import React from &quot;react&quot;;import &#123; useProjects &#125; from &quot;utils/project&quot;;export const ProjectPopover = () =&gt; &#123; const &#123; data: projects, isLoading &#125; = useProjects() const pinnedProjects = projects?.filter(project =&gt; project.pin) const content = &lt;ContentContainer&gt; &lt;Typography.Text type=&#123;&#x27;secondary&#x27;&#125;&gt;收藏项目&lt;/Typography.Text&gt; &lt;List&gt; &#123; pinnedProjects?.map(project =&gt; &lt;List.Item&gt; &lt;List.Item.Meta title=&#123;project.name&#125; /&gt; &lt;/List.Item&gt;) &#125; &lt;/List&gt; &lt;/ContentContainer&gt; return &lt;Popover placement=&#123;&#x27;bottom&#x27;&#125; content=&#123;content&#125;&gt; 项目 &lt;/Popover&gt;&#125;const ContentContainer = styled.div`min-width: 30rem;` 在src\\authenticated-app.tsx中使用： 1234567891011121314151617181920export const AuthenticatedApp = () =&gt; &#123; return &lt;Container&gt; &lt;PageHeader /&gt; ... &lt;/Container&gt;&#125;const PageHeader = () =&gt; &#123; const &#123; logout, user &#125; = useAuth() return &lt;Header between&gt; &lt;HeaderLeft gap&gt; &lt;Button style=&#123;&#123; padding: 0 &#125;&#125; type=&#123;&#x27;link&#x27;&#125; onClick=&#123;resetRoute&#125;&gt; &lt;SoftwareLogo width=&#123;&#x27;6rem&#x27;&#125; color=&#123;&#x27;rgb(38,132,255)&#x27;&#125; /&gt; &lt;/Button&gt; &lt;ProjectPopover /&gt; &lt;span&gt;用户&lt;/span&gt; &lt;/HeaderLeft&gt; ... &lt;/Header&gt;&#125; 10-3 状态提升，组合组件与控制反转(下)继续上节的状态提升： 在src\\components\\project-popover.tsx中添加分割线和创建项目按钮，并调用父组件传来的setProjectModalOpen()方法： 12345678910111213export const ProjectPopover = (props: &#123; setProjectModalOpen: (isOpen: boolean) =&gt; void &#125;) =&gt; &#123; const &#123; data: projects, isLoading &#125; = useProjects() const pinnedProjects = projects?.filter(project =&gt; project.pin) const content = &lt;ContentContainer&gt; ... &lt;Divider /&gt; &lt;ButtonNoPadding onClick=&#123;() =&gt; props.setProjectModalOpen(true)&#125; type=&#123;&#x27;link&#x27;&#125;&gt;创建项目&lt;/ButtonNoPadding&gt; &lt;/ContentContainer&gt; return &lt;Popover placement=&#123;&#x27;bottom&#x27;&#125; content=&#123;content&#125;&gt; 项目 &lt;/Popover&gt;&#125; 在src\\components\\lib.tsx中定义ButtonNoPadding： 123export const ButtonNoPadding = styled(Button)`padding: 0;` 将setProjectModalOpen从src\\authenticated-app.tsx传下去： 123456789101112131415161718192021export const AuthenticatedApp = () =&gt; &#123; const [projectModalOpen, setProjectModalOpen] = useState(false) return &lt;Container&gt; &lt;PageHeader setProjectModalOpen=&#123;setProjectModalOpen&#125; /&gt; ... &lt;/Container&gt;&#125;const PageHeader = (props: &#123; setProjectModalOpen: (isOpen: boolean) =&gt; void &#125;) =&gt; &#123; const &#123; logout, user &#125; = useAuth() return &lt;Header between&gt; &lt;HeaderLeft gap&gt; &lt;ButtonNoPadding type=&#123;&#x27;link&#x27;&#125; onClick=&#123;resetRoute&#125;&gt; &lt;SoftwareLogo width=&#123;&#x27;6rem&#x27;&#125; color=&#123;&#x27;rgb(38,132,255)&#x27;&#125; /&gt; &lt;/ButtonNoPadding&gt; &lt;ProjectPopover setProjectModalOpen=&#123;props.setProjectModalOpen&#125; /&gt; &lt;span&gt;用户&lt;/span&gt; &lt;/HeaderLeft&gt; ... &lt;/Header&gt;&#125; 在src\\screens\\project-list\\index.tsx中添加创建项目按钮： 123456789export const ProjectListScreen = (props: &#123; setProjectModalOpen: (isOpen: boolean) =&gt; void &#125;) =&gt; &#123; return &lt;Container&gt; &lt;Row align=&quot;middle&quot; justify=&quot;space-between&quot;&gt; &lt;h1&gt;项目列表&lt;/h1&gt; &lt;Button onClick=&#123;() =&gt; props.setProjectModalOpen(true)&#125;&gt;创建项目&lt;/Button&gt; &lt;/Row&gt; ... &lt;/Container&gt;&#125; 将setProjectModalOpen()在src\\authenticated-app.tsx传下去： 12345678910111213141516export const AuthenticatedApp = () =&gt; &#123; const [projectModalOpen, setProjectModalOpen] = useState(false) return &lt;Container&gt; &lt;Main&gt; &lt;Router&gt; &lt;Routes&gt; &lt;Route path=&#123;&#x27;/projects&#x27;&#125; element=&#123;&lt;ProjectListScreen setProjectModalOpen=&#123;setProjectModalOpen&#125; /&gt;&#125; /&gt; ... &lt;/Routes&gt; &lt;/Router&gt; &lt;/Main&gt; &lt;/Container&gt;&#125; 在src\\screens\\project-list\\list.tsx中table的最后一列添加编辑按钮： 1234567891011121314151617181920212223interface ListProps extends TableProps&lt;Project&gt; &#123; ..., setProjectModalOpen: (isOpen: boolean) =&gt; void&#125;export const List = (&#123; users, ...props &#125;: ListProps) =&gt; &#123; return &lt;Table pagination=&#123;false&#125; columns=&#123;[ ..., &#123; render(value, project) &#123; return &lt;Dropdown overlay=&#123;&lt;Menu&gt; &lt;Menu.Item key=&#123;&#x27;edit&#x27;&#125;&gt; &lt;ButtonNoPadding type=&#123;&#x27;link&#x27;&#125; onClick=&#123;() =&gt; props.setProjectModalOpen(true)&#125;&gt; 编辑 &lt;/ButtonNoPadding&gt; &lt;/Menu.Item&gt; &lt;/Menu&gt;&#125;&gt; &lt;ButtonNoPadding type=&#123;&#x27;link&#x27;&#125;&gt;...&lt;/ButtonNoPadding&gt; &lt;/Dropdown&gt; &#125; &#125; ]&#125; /&gt;&#125; 在src\\screens\\project-list\\index.tsx将setProjectModalOpen()传给List： 1234567891011export const ProjectListScreen = (props: &#123; setProjectModalOpen: (isOpen: boolean) =&gt; void &#125;) =&gt; &#123; return &lt;Container&gt; ... &lt;List setProjectModalOpen=&#123;props.setProjectModalOpen&#125; refresh=&#123;retry&#125; loading=&#123;isLoading&#125; dataSource=&#123;list || []&#125; users=&#123;users || []&#125; /&gt; &lt;/Container&gt;&#125; 以上两节所采用的状态提升方法，有两个问题：prop drilling(下钻)、耦合(定义和调用方法离得太远)。 使用组件组合(component composiztion)的方式改造以上代码，实际上是把上面传递setProjectModalOpen()方法的地方改成传JSX： 在src\\authenticated-app.tsx中有这几处改动： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;PageHeader projectButton=&#123; &lt;ButtonNoPadding onClick=&#123;() =&gt; setProjectModalOpen(true)&#125; type=&#123;&#x27;link&#x27;&#125;&gt; 创建项目 &lt;/ButtonNoPadding&gt; &#125; /&gt;export const AuthenticatedApp = () =&gt; &#123; const [projectModalOpen, setProjectModalOpen] = useState(false) return &lt;Container&gt; &lt;PageHeader projectButton=&#123; &lt;ButtonNoPadding onClick=&#123;() =&gt; setProjectModalOpen(true)&#125; type=&#123;&#x27;link&#x27;&#125;&gt; 创建项目 &lt;/ButtonNoPadding&gt; &#125; /&gt; &lt;Main&gt; &lt;Router&gt; &lt;Routes&gt; &lt;Route path=&#123;&#x27;/projects&#x27;&#125; element=&#123;&lt;ProjectListScreen projectButton=&#123; &lt;ButtonNoPadding onClick=&#123;() =&gt; setProjectModalOpen(true)&#125; type=&#123;&#x27;link&#x27;&#125;&gt; 创建项目 &lt;/ButtonNoPadding&gt; &#125; /&gt;&#125; /&gt; ... &lt;/Routes&gt; &lt;/Router&gt; &lt;/Main&gt; &lt;/Container&gt;&#125;const PageHeader = (props: &#123; projectButton: JSX.Element &#125;) =&gt; &#123; const &#123; logout, user &#125; = useAuth() return &lt;Header between&gt; &lt;HeaderLeft gap&gt; &lt;ButtonNoPadding type=&#123;&#x27;link&#x27;&#125; onClick=&#123;resetRoute&#125;&gt; &lt;SoftwareLogo width=&#123;&#x27;6rem&#x27;&#125; color=&#123;&#x27;rgb(38,132,255)&#x27;&#125; /&gt; &lt;/ButtonNoPadding&gt; &lt;ProjectPopover &#123;...props&#125; /&gt; &lt;span&gt;用户&lt;/span&gt; &lt;/HeaderLeft&gt; ... &lt;/Header&gt;&#125; src\\components\\project-popover.tsx改造： 1234567export const ProjectPopover = (props: &#123; projectButton: JSX.Element &#125;) =&gt; &#123; const content = &lt;ContentContainer&gt; ... &lt;Divider /&gt; &#123;props.projectButton&#125; &lt;/ContentContainer&gt;&#125; src\\screens\\project-list\\index.tsx改造： 12345678910111213export const ProjectListScreen = (props: &#123; projectButton: JSX.Element &#125;) =&gt; &#123; return &lt;Container&gt; &lt;Row align=&quot;middle&quot; justify=&quot;space-between&quot;&gt; &lt;h1&gt;项目列表&lt;/h1&gt; &#123;props.projectButton&#125; &lt;/Row&gt; ... &lt;List projectButton=&#123;props.projectButton&#125; ... /&gt; &lt;/Container&gt;&#125; src\\screens\\project-list\\list.tsx改造： 1234567891011121314151617181920interface ListProps extends TableProps&lt;Project&gt; &#123; ..., projectButton: JSX.Element&#125;export const List = (&#123; users, ...props &#125;: ListProps) =&gt; &#123; return &lt;Table pagination=&#123;false&#125; columns=&#123;[ ..., &#123; render(value, project) &#123; return &lt;Dropdown overlay=&#123;&lt;Menu&gt; &lt;Menu.Item key=&#123;&#x27;edit&#x27;&#125;&gt; &#123;props.projectButton&#125; &lt;/Menu.Item&gt; &lt;/Menu&gt;&#125;&gt; &lt;ButtonNoPadding type=&#123;&#x27;link&#x27;&#125;&gt;...&lt;/ButtonNoPadding&gt; &lt;/Dropdown&gt; &#125; &#125; ]&#125; /&gt;&#125; 这样做法的好处是，子组件就再也不用关注属性和方法了，因为都在根组件处理了，实现解耦的目的。 此处还涉及到一个概念控制反转。 10-4 合并组件状态，实现useUndo 创建src\\utils\\use-undo.ts： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import &#123; useState &#125; from &quot;react&quot;export const UseUndo = &lt;T&gt;(initialPresent: T) =&gt; &#123; const [past, setPast] = useState&lt;T[]&gt;([]) // 用来记录历史操作的合集 const [present, setPresent] = useState(initialPresent) const [future, setFuture] = useState&lt;T[]&gt;([]) const canUndo = past.length !== 0 // 表示有历史记录，可以往回时空穿梭（往后跳） const canRedo = future.length !== 0 // 表示有future的操作，可以往前跳 const undo = () =&gt; &#123; if (!canUndo) return const previous = past[past.length - 1] // 历史记录中最新的那个 const newPast = past.slice(0, past.length - 1) // 这时候新的past就不包括上面的previous了 // 赋值三步走 setPast(newPast) setPresent(previous) setFuture([present, ...future]) &#125; const redo = () =&gt; &#123; if (!canRedo) return // 以[&#x27;present&#x27;, f1, f2, f3]为例 const next = future[0] // f1 const newFuture = future.slice(1) // [f2, f3] setPast([...past, present]) setPresent(next) setFuture(newFuture) &#125; const set = (newPresent: T) =&gt; &#123; if (newPresent === present) return setPast([...past, present]) setPresent(newPresent) setFuture([]) &#125; const reset = (newPresent: T) =&gt; &#123; setPast([]) setPresent(newPresent) setFuture([]) &#125; return [ &#123; past, present, future &#125;, &#123; set, reset, undo, redo, canUndo, canRedo &#125; ] as const&#125; 之前强调过，如果在自定义hook中return函数，最好给它加上useCallback，我们发现以上几个函数用useCallback后的依赖几乎一样或者互相影响，为&#39;canUndo&#39;, &#39;future&#39;, &#39;past&#39;, and &#39;present&#39;，这时我们就可以将这几个state合并为一个，改造如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import &#123; useCallback, useState &#125; from &quot;react&quot;export const UseUndo = &lt;T&gt;(initialPresent: T) =&gt; &#123; const [state, setState] = useState&lt;&#123; past: T[], present: T, future: T[] &#125;&gt;(&#123; past: [], present: initialPresent, future: [] &#125;) // 或者可以这样写 // const [state, setState] = useState(&#123; // past: [] as T[], // present: initialPresent, // future: [] as T[] // &#125;) const canUndo = state.past.length !== 0 const canRedo = state.future.length !== 0 const undo = useCallback(() =&gt; &#123; setState(currentState =&gt; &#123; const &#123; past, present, future &#125; = currentState if (past.length === 0) return currentState const previous = past[past.length - 1] const newPast = past.slice(0, past.length - 1) return &#123; past: newPast, present: previous, future: [present, ...future] &#125; &#125;) &#125;, []) const redo = useCallback(() =&gt; &#123; setState(currentState =&gt; &#123; const &#123; past, present, future &#125; = currentState if (future.length === 0) return currentState const next = future[0] // f1 const newFuture = future.slice(1) // [f2, f3] return &#123; past: [...past, present], present: next, future: newFuture &#125; &#125;) &#125;, []) const set = useCallback((newPresent: T) =&gt; &#123; setState(currentState =&gt; &#123; const &#123; past, present &#125; = currentState if (newPresent === present) return currentState return &#123; past: [...past, present], present: newPresent, future: [] &#125; &#125;) &#125;, []) const reset = useCallback((newPresent: T) =&gt; &#123; setState(() =&gt; &#123; return &#123; past: [], present: newPresent, future: [] &#125; &#125;) &#125;, []) return [ state, &#123; set, reset, undo, redo, canUndo, canRedo &#125; ] as const&#125; 10-5 用useReducer进行状态管理 用useReducer改造src\\utils\\use-undo.ts： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import &#123; useCallback, useReducer, useState &#125; from &quot;react&quot;const UNDO = &#x27;UNDO&#x27;const REDO = &#x27;REDO&#x27;const SET = &#x27;SET&#x27;const RESET = &#x27;RESET&#x27;type State&lt;T&gt; = &#123; past: T[], present: T, future: T[]&#125;// type规定这个action是什么类型，newPresent是作为数据的参数type Action&lt;T&gt; = &#123; newPresent?: T, type: typeof UNDO | typeof REDO | typeof SET | typeof RESET &#125;// reducer的基本的工作机制是从前面的state推断出后面的state，当我们把undoReducer用在useReducer()运行时，useReducer会自动给undoReducer传进来现在的stateconst undoReducer = &lt;T&gt;(state: State&lt;T&gt;, action: Action&lt;T&gt;) =&gt; &#123; const &#123; past, present, future &#125; = state const &#123; type, newPresent &#125; = action switch (type) &#123; case UNDO: &#123; if (past.length === 0) return state const previous = past[past.length - 1] // 历史记录中最新的那个 const newPast = past.slice(0, past.length - 1) // 这时候新的past就不包括上面的previous了 return &#123; past: newPast, present: previous, future: [present, ...future] &#125; &#125; case REDO: &#123; if (future.length === 0) return state const next = future[0] // f1 const newFuture = future.slice(1) // [f2, f3] return &#123; past: [...past, present], present: next, future: newFuture &#125; &#125; case SET: &#123; if (newPresent === present) return state return &#123; past: [...past, present], present: newPresent, future: [] &#125; &#125; case RESET: &#123; return &#123; past: [], present: newPresent, future: [] &#125; &#125; default: return state &#125;&#125;export const UseUndo = &lt;T&gt;(initialPresent: T) =&gt; &#123; const [state, dispatch] = useReducer(undoReducer, &#123; past: [], present: initialPresent, future: [] &#125; as State&lt;T&gt;) const canUndo = state.past.length !== 0 const canRedo = state.future.length !== 0 // 如果想让useReducer产值，必须调用dispatch const undo = useCallback(() =&gt; dispatch(&#123; type: UNDO &#125;), []) const redo = useCallback(() =&gt; dispatch(&#123; type: REDO &#125;), []) const set = useCallback((newPresent: T) =&gt; dispatch(&#123; type: SET, newPresent &#125;), []) const reset = useCallback((newPresent: T) =&gt; dispatch(&#123; type: RESET, newPresent &#125;), []) return [ state, &#123; set, reset, undo, redo, canUndo, canRedo &#125; ] as const&#125; 流程描述： useReducer()接收的第一参数是一个reducer函数，第二个是状态的初始值，这个reducer函数undoReducer()每次运行都会传进来一个参数，这个参数就是此时此刻的state值，这个值结合传进来的另一个参数action告诉reducer，这个值结束后，下个值是什么，就是它里面return的新的值，这个undoReducer()函数就像个生产线，将结果一个个产出。 当需要这个undoReducer()函数产值时，就需要调用useReducer返回的第二个参数dispatch，这个dispatch()里面传的参数由自己规定(和action对应)，当dispatch后，undoReducer()会接收到传的参数，并根据判断返回新的值。 我们之前有个自定义hook useAsync非常适合用useReducer，因为它符合这样的规律：state是个对象，里面有若干状态error、data、stat，三者总互相影响，总是一起赋值，src\\utils\\use-async.ts改写如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import &#123; useCallback, useReducer, useState &#125; from &quot;react&quot;import &#123; useMountedRef &#125; from &quot;utils&quot;interface State&lt;D&gt; &#123; error: Error | null data: D | null stat: &#x27;idle&#x27; | &#x27;loading&#x27; | &#x27;error&#x27; | &#x27;success&#x27;&#125;const defaultInitialState: State&lt;null&gt; = &#123; stat: &#x27;idle&#x27;, data: null, error: null&#125;const defaultConfig = &#123; throwOnError: false&#125;const useSafeDispatch = &lt;T&gt;(dispatch: (...args: T[]) =&gt; void) =&gt; &#123; const mountedRef = useMountedRef() return useCallback((...args: T[]) =&gt; (mountedRef.current ? dispatch(...args) : void 0), [dispatch, mountedRef])&#125;export const useAsync = &lt;D&gt;(initialState?: State&lt;D&gt;, initialConfig?: typeof defaultConfig) =&gt; &#123; const config = &#123; ...defaultConfig, ...initialConfig &#125; const [state, dispatch] = useReducer((state: State&lt;D&gt;, action: Partial&lt;State&lt;D&gt;&gt;) =&gt; (&#123; ...state, ...action &#125;), &#123; ...defaultInitialState, ...initialState &#125;) const safeDispatch = useSafeDispatch(dispatch) const [retry, setRetry] = useState(() =&gt; () =&gt; &#123; &#125;) const setData = useCallback((data: D) =&gt; safeDispatch(&#123; data, stat: &#x27;success&#x27;, error: null &#125;), [safeDispatch]) const setError = useCallback((error: Error) =&gt; safeDispatch(&#123; error, stat: &#x27;error&#x27;, data: null &#125;), [safeDispatch]) const run = useCallback((promise: Promise&lt;D&gt;, runConfig?: &#123; retry: () =&gt; Promise&lt;D&gt; &#125;) =&gt; &#123; if (!promise || !promise.then) &#123; throw new Error(&#x27;请传入 Promise 类型数据&#x27;) &#125; setRetry(() =&gt; () =&gt; &#123; if (runConfig?.retry) &#123; run(runConfig?.retry(), runConfig) &#125; &#125;) safeDispatch(&#123; stat: &#x27;loading&#x27; &#125;) return promise.then(data =&gt; &#123; // 这里的setData已经在上面safeDispatch了 setData(data) return data &#125;).catch(error =&gt; &#123; setError(error) if (config.throwOnError) return Promise.reject(error) return error &#125;) &#125;, [config.throwOnError, setData, setError, safeDispatch]) return &#123; isIdle: state.stat === &#x27;idle&#x27;, isLoading: state.stat === &#x27;loading&#x27;, isError: state.stat === &#x27;error&#x27;, isSuccess: state.stat === &#x27;success&#x27;, run, setData, setError, retry, ...state &#125;&#125; 综上，useState和useReducer在功能上是可以互换的，useState适合于定义单个的状态，useReducer适合定义一群会互相影响的状态。 10-6 redux用法介绍无 10-7 react-redux 与 HoC react-redux起到桥梁的作用，它把store中的状态state和react component组件连接在一起，把store中的state变成组件状态。具体怎么链接呢？见 https://codesandbox.io/s/1vwm785r44 在hook出现之前非常推崇的模式是容器组件与展示组件分离(separation of container presidential)。React Hook的历史 redux的hook模式见 https://react-redux.js.org/api/hooks，里面最重要的是useSelector 10-9 为什么我们需要redux-thunk？ 回顾同步redux代码，以todos为例： reducers 它的入口文件reducers/index.js： 12345678import &#123; combineReducers &#125; from &#x27;redux&#x27;import todos from &#x27;./todos&#x27;import visibilityFilter from &#x27;./visibilityFilter&#x27;export default combineReducers(&#123; todos, visibilityFilter&#125;) 结合了两个reducer - todos和visibilityFilter，使用redux中的combineReducers将它俩合并起来。 reducers/todos.js： 1234567891011121314151617181920212223const todos = (state = [], action) =&gt; &#123; switch (action.type) &#123; case &#x27;ADD_TODO&#x27;: return [ ...state, &#123; id: action.id, text: action.text, completed: false &#125; ] case &#x27;TOGGLE_TODO&#x27;: return state.map(todo =&gt; (todo.id === action.id) ? &#123;...todo, completed: !todo.completed&#125; : todo ) default: return state &#125;&#125;export default todos 定义的todos reducer，接收一个现在的state和action，这个action标识了要对现在的state做怎样的处理，它们两个决定了这个todos返回一个新的什么样的状态。 reducer要符合可预测的概念，即给它一个相同的state和action，它一定会返回一个相同的newState，里面的代码完全不受外界环境的影响，是个纯函数。 当用户要做某个操作比如ADD_TODO或者TOGGLE_TODO时，不需要关心现在的state，只需要关心参数action。 reducer必须是个同步函数，是为了保持它的纯洁性和可预测性，因为异步操作在函数式编程中被认为是副作用，即这次操作和下次操作即使参数相同，但请求结果可能也有所不同。 reducer中为什么要返回一个全新的state呢？ 比如把上面TOGGLE_TODO的情况改为： 123case &#x27;TOGGLE_TODO&#x27;: const target = state.find(todo=&gt;todo.id===action.id) target.completed = !target.completed 点击Add Todo按钮同样可以实现添加输入值的效果，单点击列表输入值，却无法实现切换删除状态的功能，即状态不刷新了。 究其原因，redux的比较方法和react一样非常简单粗暴，因为以上操作state并未发生改变，所以页面并不会刷新，所以必须返回一个全新的state，才能实现页面刷新。 containers containers/AddTodo.js： 123456789101112131415161718192021222324252627import React from &#x27;react&#x27;import &#123; connect &#125; from &#x27;react-redux&#x27;import &#123; addTodo &#125; from &#x27;../actions&#x27;const AddTodo = (&#123; dispatch &#125;) =&gt; &#123; let input return ( &lt;div&gt; &lt;form onSubmit=&#123;e =&gt; &#123; e.preventDefault() if (!input.value.trim()) &#123; return &#125; dispatch(addTodo(input.value)) input.value = &#x27;&#x27; &#125;&#125;&gt; &lt;input ref=&#123;node =&gt; input = node&#125; /&gt; &lt;button type=&quot;submit&quot;&gt; Add Todo &lt;/button&gt; &lt;/form&gt; &lt;/div&gt; )&#125;export default connect()(AddTodo) 当点击Add Todo这个按钮时，触发了form的onSubmit函数，这个函数中dispatch了一个action-addTodo，这里的dispatch来自redux。 actions actions/index.js： 12345678910111213141516171819202122let nextTodoId = 0export const addTodo = text =&gt; (&#123; type: &#x27;ADD_TODO&#x27;, id: nextTodoId++, text&#125;)export const setVisibilityFilter = filter =&gt; (&#123; type: &#x27;SET_VISIBILITY_FILTER&#x27;, filter&#125;)export const toggleTodo = id =&gt; (&#123; type: &#x27;TOGGLE_TODO&#x27;, id&#125;)export const VisibilityFilters = &#123; SHOW_ALL: &#x27;SHOW_ALL&#x27;, SHOW_COMPLETED: &#x27;SHOW_COMPLETED&#x27;, SHOW_ACTIVE: &#x27;SHOW_ACTIVE&#x27;&#125; 上面dispatch的这个action addTodo的参数是text，上面传入的input.value，这个action返回一个对象，里面必含一个type，剩下的属性是由用户自己来定义的。 采用图文结合再次进行描述 View指组件，用户在组件上点击或输入操作会发起更新动作，这里包含两步，第1步在containers/AddTodo.js中用addTodo对应actions/index.js计算出来action，第2步是dispatch发起这个action。 上面发起的更新动作到了Reducers中，在reduces/todo.js中reducer通过结合新的state和上面得到的action，得到一个新的state，并被存到Store里，react-redux结合View和Store自动更新View，即更新组件、更新视图。 如何实现异步操作？ 用react-redux自带的，在actions/index.js中添加一个新的action： 1234export const addFullTodo = (todo) =&gt; (&#123; type: &quot;ADD_TODO&quot;, ...todo&#125;) 在containers/AddTodo.js中使用： 1234567891011121314151617181920212223242526272829const loadTodo = () =&gt; &#123; // 所有的函数只要返回一个Promise，它就是个异步函数 return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#123; id: 100, text: &quot;异步todo&quot; &#125;); &#125;, 500); &#125;);&#125;;const AddTodo = (&#123; dispatch &#125;) =&gt; &#123; let input; return ( &lt;div&gt; &lt;form onSubmit=&#123;(e) =&gt; &#123; ... loadTodo().then((todo) =&gt; &#123; dispatch(addFullTodo(todo)); &#125;); &#125;&#125; &gt; &lt;input ref=&#123;(node) =&gt; (input = node)&#125; /&gt; &lt;button type=&quot;submit&quot;&gt;Add Todo&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; );&#125;; 使用redux-thunk(在redux中用来处理异步最流行的库)改写以上代码： 先安装这个库，在src/index.js中引入并使用thunk： 1234567891011import &#123; createStore, applyMiddleware &#125; from &quot;redux&quot;;import thunk from &quot;redux-thunk&quot;;const store = createStore(rootReducer, applyMiddleware(thunk));render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById(&quot;root&quot;)); 来到actions/index.js中新添加一个action： 123456789import &#123; loadTodo &#125; from &quot;../containers/AddTodo&quot;;export const addTodoAsync = () =&gt; &#123; return (dispatch) =&gt; &#123; loadTodo().then((todo) =&gt; &#123; dispatch(addFullTodo(todo)); &#125;); &#125;;&#125;; 在containers/AddTodo.js中使用时直接调用dispatch(addTodoAsync())即可实现上面相同的功能。 对比发现，在组件中我们不想关心异步的细节，不想关心异步后的操作调用哪个action，使用redux-thunk后，可以达到这个目的，而且调用时，看着和同步的dispatch没什么两样，以后无论有什么新需求，只需要去action addTodoAsync中修改即可。 综上，redux-thunk最大的作用就是帮助隐藏异步或者同步实现的细节，让异步代码也能像普通的action creator一样写在actions/index.js中。 阅读redux-thunk的源码： 1234567891011function createThunkMiddleware(extraArgument) &#123; return (&#123; dispatch, getState &#125;) =&gt; (next) =&gt; (action) =&gt; &#123; if(typeof action === &#x27;function&#x27;) &#123; return action(dispatch, getState, extraArgument) &#125; return next(action) &#125;&#125;const thunk = createThunkMiddleware()thunk.withExtraArgument = createThunkMiddlewareexport default thunk 先检测action的类型是不是function，如果是，就把action按照特定的参数执行，因为普通的action返回值是对象，当遇到异步的action，返回的是一个函数，就会被redux-thunk拦截。 redux-saga和redux-observable的最基本功能和redux-thunk的相同，还有些更难理解的功能，绝大多数项目，thunk的功能就足够用了。 10-10 配置redux-toolkit redux-toolkit是在redux基础上略微封装了一层，主要解决redux存在的三个问题： redux store配置太复杂了 有一大堆依赖要安装，如redux-thunk等 redux需要很多模板代码 redux-toolkit是将复杂逻辑简单化了的redux，现在被当作写redux的标准方式。 在jira项目中应用： 先切换到新分支redux-toolkit，安装$ npm i react-redux @reduxjs/toolkit -S，新建src/store/index.ts入口文件： 12345678910import &#123; configureStore &#125; from &quot;@reduxjs/toolkit&quot;export const rootReducer = &#123;&#125;export const store = configureStore(&#123; reducer: rootReducer&#125;)export type AppDispatch = typeof store.dispatchexport type RootState = ReturnType&lt;typeof store.getState&gt; 新建src/screens/project-list/project-list.slice.ts专门管project-list相关的状态的： 12345678910111213141516171819202122import &#123; createSlice &#125; from &quot;@reduxjs/toolkit&quot;interface State &#123; projectModalOpen: boolean&#125;const initialState: State = &#123; projectModalOpen: false&#125;export const projectListSlice = createSlice(&#123; name: &#x27;projectListSlice&#x27;, initialState, reducers: &#123; openProjectModal(state) &#123; state.projectModalOpen = true &#125;, closeProjectModal(state) &#123; state.projectModalOpen = false &#125; &#125;&#125;) 为什么以上reducers中可以直接给state赋值呢？因为redux-toolkit借助immer库返回之前新对象的形式，immer的核心在于immutable state(不可变状态)： 12345678910111213141516import produce from &quot;immer&quot;const baseState = [ &#123; title: &quot;Learn TypeScript&quot;, done: true &#125;, &#123; title: &quot;Try Immer&quot;, done: false &#125;]// 此处的draft可以被看作是baseState的一个影子，immer在底层新建个对象，把那一系列操作映射到新建的对象上，总之是让我们以不干净的写法完成干净的事情const nextState = produce(baseState, draft =&gt; &#123; draft[1].done = true draft.push(&#123;title: &quot;Tweet about it&quot;&#125;)&#125;) 10-11 应用redux-toolkit管理模态框 在src\\screens\\project-list\\project-list.slice.ts中导出actions： 1export const projectListActions = projectListSlice.actions 在src\\store\\index.tsx中添加： 1234import &#123; projectListSlice &#125; from &quot;screens/project-list/project-list.slice&quot;export const rootReducer = &#123; projectList: projectListSlice.reducer&#125; 至此，结合10-10，状态的配置就完成了！ 下面是在业务组件中使用： src\\authenticated-app.tsx，删掉&lt;PageHeader /&gt;组件的projectButton属性，以及&lt;ProjectModal /&gt;和&lt;ProjectPopover /&gt;上的所有属性： 12345678910111213141516export const AuthenticatedApp = () =&gt; &#123; return &lt;Container&gt; &lt;PageHeader /&gt; ... &lt;ProjectModal /&gt; &lt;/Container&gt;&#125;const PageHeader = () =&gt; &#123; return &lt;Header between&gt; &lt;HeaderLeft gap&gt; &lt;ProjectPopover /&gt; &lt;/HeaderLeft&gt; ... &lt;/Header&gt;&#125; 并把这个button挪到src\\components\\project-popover.tsx中替换原来的props.projectButton，然后使用react-redux自带的hook useDispatch，在此之前先安装react-redux的类型库$ npm i @types/react-redux -D 1234567891011import &#123; useDispatch &#125; from &quot;react-redux&quot;;import &#123; projectListActions &#125; from &quot;screens/project-list/project-list.slice&quot;;export const ProjectPopover = () =&gt; &#123; const dispatch = useDispatch() const content = &lt;ContentContainer&gt; ... &lt;ButtonNoPadding onClick=&#123;() =&gt; dispatch(projectListActions.openProjectModal())&#125; type=&#123;&#x27;link&#x27;&#125;&gt; 创建项目 &lt;/ButtonNoPadding&gt; &lt;/ContentContainer&gt;&#125; 上面删除&lt;ProjectModal /&gt;的属性，在该组件文件src\\screens\\project-list\\project-modal.tsx中就得做出相应修改，也是使用dispatch hook： 12345678910111213import &#123; useDispatch &#125; from &quot;react-redux&quot;;import &#123; projectListActions &#125; from &quot;./project-list.slice&quot;;export const ProjectModal = () =&gt; &#123; const dispatch = useDispatch() return &lt;Drawer onClose=&#123;() =&gt; dispatch(projectListActions.closeProjectModal())&#125; visible=&#123;props.projectModalOpen&#125; width=&#123;&#x27;100%&#x27;&#125;&gt; &lt;span&gt;Project Modal&lt;/span&gt; &lt;Button onClick=&#123;() =&gt; dispatch(projectListActions.closeProjectModal())&#125;&gt;关闭&lt;/Button&gt; &lt;/Drawer&gt;&#125; 上面visible属性用到state中的projectModalOpen，在src\\screens\\project-list\\project-list.slice.ts中抽象一个读取的方法： 1export const selectProjectModalOpen = (state: RootState) =&gt; state.projectList.projectModalOpen 然后修改上面的project-modal.tsx中的visible属性： 1234567891011import &#123; useDispatch, useSelector &#125; from &quot;react-redux&quot;;export const ProjectModal = () =&gt; &#123; const dispatch = useDispatch() const projectModalOpen = useSelector(selectProjectModalOpen) return &lt;Drawer onClose=&#123;() =&gt; dispatch(projectListActions.closeProjectModal())&#125; visible=&#123;projectModalOpen&#125; width=&#123;&#x27;100%&#x27;&#125;&gt; &lt;/Drawer&gt;&#125; 此处用到的hook useSelector是用来读store中总的状态树的状态的，读的是根状态树，是个对象。 上面的类型RootState是在src\\store\\index.tsx中定义的export type RootState = ReturnType&lt;typeof store.getState&gt;，它里面之所以有projectList类型，是因为在上面定义的export const rootReducer = &#123; projectList: projectListSlice.reducer &#125; 这里的getState(): S类型返回S，是个泛型，这个泛型就代表了整个state树，store.getState是个js函数，用typeof把它转换成ts类型，这个类型就是返回的那个S。 用ReturnType可以读出来传进来的这个函数的返回值type ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: any) =&gt; infer R ? R : any;，所以它可以读出来上面那个泛型S的返回值，这个返回值就是整个state的类型。 src\\screens\\project-list\\index.tsx中也如上面做出修改，替换+使用hook，以及删除&lt;List /&gt;组件上的projectButton属性： 12345678910111213141516171819202122import &#123; useDispatch &#125; from &quot;react-redux&quot;import &#123; ButtonNoPadding &#125; from &quot;components/lib&quot;import &#123; projectListActions &#125; from &quot;./project-list.slice&quot;export const ProjectListScreen = (props: &#123; projectButton: JSX.Element &#125;) =&gt; &#123; const dispatch = useDispatch() return &lt;Container&gt; &lt;Row align=&quot;middle&quot; justify=&quot;space-between&quot;&gt; &lt;h1&gt;项目列表&lt;/h1&gt; &lt;ButtonNoPadding onClick=&#123;() =&gt; dispatch(projectListActions.openProjectModal())&#125; type=&#123;&#x27;link&#x27;&#125;&gt; 创建项目 &lt;/ButtonNoPadding&gt; &lt;/Row&gt; &lt;List projectButton=&#123;props.projectButton&#125; refresh=&#123;retry&#125; loading=&#123;isLoading&#125; dataSource=&#123;list || []&#125; users=&#123;users || []&#125; /&gt; &lt;/Container&gt;&#125; src\\screens\\project-list\\list.tsx中也如上面做出修改，替换+使用hook： 1234567891011121314151617181920212223import &#123; ButtonNoPadding &#125; from &quot;components/lib&quot;import &#123; useDispatch &#125; from &quot;react-redux&quot;import &#123; projectListActions &#125; from &quot;./project-list.slice&quot;export const List = (&#123; users, ...props &#125;: ListProps) =&gt; &#123; const dispatch = useDispatch() return &lt;Table pagination=&#123;false&#125; columns=&#123;[ ......, &#123; render(value, project) &#123; return &lt;Dropdown overlay=&#123;&lt;Menu&gt; &lt;Menu.Item key=&#123;&#x27;edit&#x27;&#125;&gt; &lt;ButtonNoPadding onClick=&#123;() =&gt; dispatch(projectListActions.openProjectModal())&#125; type=&#123;&#x27;link&#x27;&#125;&gt; 编辑 &lt;/ButtonNoPadding&gt; &lt;/Menu.Item&gt; &lt;/Menu&gt;&#125;&gt; &lt;ButtonNoPadding type=&#123;&#x27;link&#x27;&#125;&gt;...&lt;/ButtonNoPadding&gt; &lt;/Dropdown&gt; &#125; &#125; ]&#125; /&gt;&#125; 以上都修改完成后，启动项目可能会报这样的错：could not find react-redux context value, please ensure the component is wrapped in a ，怎么做到让很多组件都能访问到store里的状态呢？实际上还是使用context，但是不推荐有n多个context和provider，官方推荐只有一个store就可以，可以将这个store包裹在最外层，在src\\context\\index.tsx中： 123456789101112import &#123; Provider &#125; from &quot;react-redux&quot;;import &#123; store &#125; from &quot;store&quot;; // 这里引入的store是在src\\store\\index.tsx中暴露出来的export const AppProviders = (&#123; children &#125;: &#123; children: ReactNode &#125;) =&gt; &#123; return ( &lt;Provider store=&#123;store&#125;&gt; &lt;AuthProvider&gt; &#123;children&#125; &lt;/AuthProvider&gt; &lt;/Provider&gt; )&#125; 10-12 用redux-thunk管理登录状态context和redux是呈竞争关系的，我们把之前的context代码换成redux： 新建src\\store\\auth-slice.ts，定义一个reducer、四个thunk： 123456789101112131415161718192021222324252627282930313233import &#123; createSlice &#125; from &quot;@reduxjs/toolkit&quot;;import &#123; User &#125; from &quot;screens/project-list/search-panel&quot;;import &#123; AuthForm, bootstrapUser &#125; from &quot;context/auth-context&quot;;import &#123; AppDispatch &#125; from &quot;store&quot;;import * as auth from &#x27;auth-provider&#x27;// 定义state的类型interface State &#123; user: User | null&#125;const initialState: State = &#123; user: null&#125;export const authSlice = createSlice(&#123; name: &#x27;auth&#x27;, initialState, reducers: &#123; setUser(state, action) &#123; state.user = action.payload &#125; &#125;&#125;)const &#123; setUser &#125; = authSlice.actions// 对应auth-context.tsx中的const login = (form: AuthForm) =&gt; auth.login(form).then(setUser)// p.s.一个thunk是两层函数export const login = (form: AuthForm) =&gt; (dispatch: AppDispatch) =&gt; auth.login(form).then(user =&gt; dispatch(setUser(user)))export const register = (form: AuthForm) =&gt; (dispatch: AppDispatch) =&gt; auth.register(form).then(user =&gt; dispatch(setUser(user)))export const logout = () =&gt; (dispatch: AppDispatch) =&gt; auth.logout().then(user =&gt; dispatch(setUser(null)))export const bootstrap = () =&gt; (dispatch: AppDispatch) =&gt; bootstrapUser().then(user =&gt; dispatch(setUser(user))) 在src\\store\\index.ts中添加authReducer： 123456import &#123; authSlice &#125; from &quot;./auth-slice&quot;export const rootReducer = &#123; projectList: projectListSlice.reducer, auth: authSlice.reducer&#125; 接上面的src\\store\\auth-slice.ts，在其他地方怎么获取user？ 1export const selectUser = (state: RootState) =&gt; state.auth.user 在其他地方怎么使用上面定义的redux-thunk呢？ 可以直接使用，比如在src\\unauthenticated-app\\login.tsx中： 123456789101112import &#123; useDispatch &#125; from &quot;react-redux&quot;;export const LoginScreen = (&#123; onError &#125;: &#123; onError: (error: Error) =&gt; void &#125;) =&gt; &#123; const dispatch = useDispatch() const handleSubmit = async (values: &#123; username: string, password: string &#125;) =&gt; &#123; /** * 对应export const login = (form: AuthForm) =&gt; (dispatch: AppDispatch) =&gt; auth.login(form).then(user =&gt; dispatch(setUser(user)))讲解： * 首先执行loginThunk(values)，传入的values参数就是login=(form:AuthForm)里的form，它返回一个函数(dispatch: AppDispatch) =&gt; auth.login(form) * 下面的dispatch接收到这个函数后，要发给中间件redux-thunk，redux-thunk一接收到它是个函数，就会进行处理 */ dispatch(loginThunk(values)) &#125;&#125; 如果我们用dispatch(loginThunk(values))挨个去替换所有使用到import &#123; useAuth &#125; from &quot;context/auth-context&quot;;中的useAuth.login()方法，会引起太大的影响，所以我们尽量在代码的上游进行修改，即src\\context\\auth-context.tsx中： 123456789101112131415import * as authStore from &quot;store/auth-slice&quot;import &#123; useDispatch, useSelector &#125; from &quot;react-redux&quot;export const useAuth = () =&gt; &#123; const dispatch = useDispatch() const user = useSelector(authStore.selectUser) // 此处需要注意，当我们用自定义hook返回方法时，要给它加上useCallback const login = useCallback((form: AuthForm) =&gt; dispatch(authStore.login(form)), [dispatch]) const register = useCallback((form: AuthForm) =&gt; dispatch(authStore.register(form)), [dispatch]) const logout = useCallback(() =&gt; dispatch(authStore.logout()), [dispatch]) return &#123; user, login, register, logout &#125;&#125; 此处要注意另一个问题，比如在定义login()方法后直接使用login(&#123; username: &#39;123&#39;, password: &#39;123&#39; &#125;)，我们期待它返回一个Promise，因为此处的dispatch(authStore.login(form))执行完后，在export const login = (form: AuthForm) =&gt; (dispatch: AppDispatch) =&gt; auth.login(form)中会返回一个Promise，才能使用.then(user =&gt; dispatch(setUser(user)))，这就需要对dispatch的类型做出显式的声明： 1const dispatch: (...args: unknown[]) =&gt; Promise&lt;User&gt; = useDispatch() 然后精简代码： 不再需要AuthContext了，删掉，AuthProvider直接return children即可； 其中定义的login()等方法也可以删掉了； 定义的useAsync()的参数data和setData也要删掉； 定义dispatch，并修改run(bootstrapUser())为run(dispatch(authStore.bootstrap()))； 以上调整完成，src\\context\\index.tsx中ts会报错 “AuthProvider”不能用作 JSX 组件。其返回类型 “ReactNode” 不是有效的 JSX 元素。不能将类型“undefined”分配给类型“Element | null”。 这是因为在AuthProvider直接return children，这个children的类型是**type** ReactNode = ReactChild | ReactFragment | ReactPortal | boolean | null | undefined;，作为一个组件，不能返回null或者undefined，所以要在children外面包上一层div。 综上，这个AuthProvider最终如下： 123456789101112131415161718export const AuthProvider = (&#123; children &#125;: &#123; children: ReactNode &#125;) =&gt; &#123; const &#123; error, isLoading, isIdle, isError, run &#125; = useAsync&lt;User | null&gt;() const dispatch: (...args: unknown[]) =&gt; Promise&lt;User&gt; = useDispatch() useMount(() =&gt; &#123; run(dispatch(authStore.bootstrap())) &#125;) if (isIdle || isLoading) &#123; return &lt;FullPageLoading /&gt; &#125; if (isError) &#123; return &lt;FullPageErrorFallBack error=&#123;error&#125; /&gt; &#125; return &lt;div&gt;&#123;children&#125;&lt;/div&gt;&#125; 第11章 用 react-query 获取数据，管理缓存11-1 用url参数管理项目模态框状态切回master分支，接下来要实现用url管理弹窗打开和关闭状态，即src\\authenticated-app.tsx中的projectModalOpen： 在src\\screens\\project-list\\util.ts中新建一个hook，这个hook扮演全局状态管理器的功能，可以取代redux或context： 12345678910111213141516171819export const useProjectModal = () =&gt; &#123; const [&#123; projectCreate &#125;, setProjectCreate] = useUrlQueryParam([ &#x27;projectCreate&#x27; ]) const open = () =&gt; setProjectCreate(&#123; projectCreate: true &#125;) // 此处将projectCreate定义为undefined是当关闭弹窗时，使路由中该参数去掉，而不是置为&#x27;false&#x27; const close = () =&gt; setProjectCreate(&#123; projectCreate: undefined &#125;) // return [ // projectCreate === &#x27;true&#x27;, // 标识现在这个modal是否打开的标识 // open, // close // ] as const return &#123; projectModalOpen: projectCreate === &#x27;true&#x27;, open, close &#125;&#125; 返回tuple的好处：在使用这个hook时，变量名可以任意命名，如const [created, openXX, closeXX] = useProjectModal()，类似useState: const [a, setA] = useState()，但是它不能打乱顺序 一般返回的数据在三个或以内，就用tuple；如果返回的比较多，就用对象 但返回对象在使用时也有缺点，就是名字被限制住了，比如const { open } = useProjectModal()，但要重命名必须这样写const { open: openModal } = useProjectModal() 回到项目中，因为除了现在定义的创建，后续还会有编辑的状态，所以我们用对象形式 这个projectModalOpen状态就可以在组件中解耦了： src\\authenticated-app.tsx： 删掉const [projectModalOpen, setProjectModalOpen] = useState(false)； &lt;ProjectModal /&gt;组件的状态也不需要从外部传入了，因为我们可以把上面新定义的hook中状态直接注入其中，同时删除该组件中的属性； 删除PageHeader的属性，和其中&lt;ProjectPopover /&gt;的属性； 删除ProjectListScreen的属性。 src\\screens\\project-list\\project-modal.tsx中将props.projectModalOpen和props.onClose修改如下： 1234567export const ProjectModal = () =&gt; &#123; const &#123; projectModalOpen, close &#125; = useProjectModal() return &lt;Drawer onClose=&#123;close&#125; visible=&#123;projectModalOpen&#125; width=&#123;&#x27;100%&#x27;&#125;&gt; &lt;span&gt;Project Modal&lt;/span&gt; &lt;Button onClick=&#123;close&#125;&gt;关闭&lt;/Button&gt; &lt;/Drawer&gt;&#125; src\\components\\project-popover.tsx中将props.projectButton替换成&lt;ButtonNoPadding /&gt;组件： 123456789export const ProjectPopover = () =&gt; &#123; const &#123; open &#125; = useProjectModal() const content = &lt;ContentContainer&gt; .... &lt;ButtonNoPadding type=&#123;&#x27;link&#x27;&#125; onClick=&#123;open&#125;&gt; 创建项目 &lt;/ButtonNoPadding&gt; &lt;/ContentContainer&gt;&#125; src\\screens\\project-list\\index.tsx中删除&lt;List /&gt;组件的属性projectButton，将其中的props.projectButton像上面一样替换成&lt;ButtonNoPadding /&gt;组件。 以上都准备完毕，启动项目会出现报错 useLocation() may be used only in the context of a component.，它的做法就类似于src\\context\\auth-context.tsx中定义的useAuth()，检测在使用useAuth时是否在AuthContext，如果不是，就报错。 我们明明没用到useLocation()，大概推断它可能跟route有关，像是某个东西未被包裹在&lt;Router&gt;中，在src\\authenticated-app.tsx中可以看到，在它包裹范围外，我们用到了&lt;PageHeader /&gt;和&lt;ProjectModal /&gt;，后者用到了useProjectModal()，这里面又用到了useUrlQueryParam()，它就和路由有关联，再往深了挖掘，里面用到了useSearchParams()就是react-router-dom中的路由，即罪魁祸首。 解决方法：将&lt;Router&gt;元素的层级提高到上面两个组件外，作为&lt;Container&gt;的直接子组件。 11-2 用 react-query 来处理 -服务端缓存React Query高性能、功能强大、异步获取数据的库，帮助获取缓存和更新数据，而不用把它们当作全局状态管理。 12345678910111213141516171819202122232425262728293031import &#123; QueryClient, QueryClientProvider, useQuery &#125; from &#x27;react-query&#x27;const queryClient = new QueryClient()export default function App() &#123; return ( &lt;QueryClientProvider client=&#123;queryClient&#125;&gt; &lt;Example /&gt; &lt;/QueryClientProvider&gt; )&#125;function Example() &#123; const &#123; isLoading, error, data &#125; = useQuery(&#x27;repoData&#x27;, () =&gt; fetch(&#x27;https://api.github.com/repos/tannerlinsley/react-query&#x27;).then(res =&gt; res.json()) ) if (isLoading) return &#x27;Loading...&#x27; if (error) return &#x27;An error has occurred: &#x27; + error.message return ( &lt;div&gt; &lt;h1&gt;&#123;data.name&#125;&lt;/h1&gt; &lt;p&gt;&#123;data.description&#125;&lt;/p&gt; &lt;strong&gt;👀 &#123;data.subscribers_count&#125;&lt;/strong&gt;&#123;&#x27; &#x27;&#125; &lt;strong&gt;✨ &#123;data.stargazers_count&#125;&lt;/strong&gt;&#123;&#x27; &#x27;&#125; &lt;strong&gt;🍴 &#123;data.forks_count&#125;&lt;/strong&gt; &lt;/div&gt; )&#125; QueryClientProvider帮助react-query做一些跨组件的事情 useQuery是react-query提供的hook，在react-query中最常用。 它的第一个参数是个key，我们可以随意指定，相当于给这个数据起了个名字； 第二个参数是告诉react-query怎么获取数据。 它的返回值isLoading是当页面刚加载时为true，后面就变成了false；isFetching是当页面加载时重新加载它 缓存里的三个主要概念： 获取新数据：useQuery(key,...) 刷新：queryClient.invalidateQueries(key) 获取缓存里的数据：queryClient.getQueryData(key) 11-3 类型守卫，用useQuery缓存工程列表","categories":[{"name":"React","slug":"React","permalink":"https://scarlett9354.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://scarlett9354.github.io/tags/React/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://scarlett9354.github.io/tags/TypeScript/"},{"name":"React Hook","slug":"React-Hook","permalink":"https://scarlett9354.github.io/tags/React-Hook/"}]},{"title":"React17+React Hook+TS4 最佳实践，仿 Jira 企业级项目(二)","slug":"React17-ReactHook-TS4最佳实践，仿Jira企业级项目-二","date":"2021-08-03T09:02:26.000Z","updated":"2021-11-01T09:52:40.883Z","comments":true,"path":"2021/08/03/React17-ReactHook-TS4最佳实践，仿Jira企业级项目-二/","link":"","permalink":"https://scarlett9354.github.io/2021/08/03/React17-ReactHook-TS4%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%8C%E4%BB%BFJira%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%A1%B9%E7%9B%AE-%E4%BA%8C/","excerpt":"","text":"第7章 用户体验优化 - 加载中和错误状态处理7-1 给页面添加Loading和Error状态，增加页面友好性 在src/screens/project-list/index.tsx中定义并设置loading： 12345678910111213export const ProjectListScreen = () =&gt; &#123; const [isLoading, setIsLoading] = useState(false) ... const debouncedParam = useDebounce(param, 200) useEffect(() =&gt; &#123; setIsLoading(true) client(&#x27;projects&#x27;, &#123; data: cleanObject(debouncedParam) &#125;).then(setList) .finally(() =&gt; setIsLoading(false)) // eslint-disable-next-line react-hooks/exhaustive-deps &#125;, [debouncedParam]) return ...&#125; 怎么将这个loading传到Table组件呢？为了避免每次都手动添加，可以直接只传一次，以后直接修改props即可，在src/screens/project-list/list.tsx中的具体做法如下： 1234567...interface ListProps extends TableProps&lt;Project&gt; &#123; users: User[]&#125;export const List = (&#123; users, ...props &#125;: ListProps) =&gt; &#123; return &lt;Table pagination=&#123;false&#125; columns=&#123;[...]&#125; &#123;...props&#125; /&gt;&#125; 再回到project-list/index.tsx将list属性改为dataSource： 1&lt;List dataSource=&#123;list&#125; users=&#123;users&#125;&gt;&lt;/List&gt; 所以这个Table组件添加loading，就可以从List组件传过去了： 123456789101112131415export const ProjectListScreen = () =&gt; &#123; const [isLoading, setIsLoading] = useState(false) const debouncedParam = useDebounce(param, 200) useEffect(() =&gt; &#123; setIsLoading(true) client(&#x27;projects&#x27;, &#123; data: cleanObject(debouncedParam) &#125;).then(setList) .finally(() =&gt; setIsLoading(false)) // eslint-disable-next-line react-hooks/exhaustive-deps &#125;, [debouncedParam]) return &lt;Container&gt; ... &lt;List loading=&#123;isLoading&#125; dataSource=&#123;list&#125; users=&#123;users&#125;&gt;&lt;/List&gt; &lt;/Container&gt;&#125; 异常处理： 123456789101112131415161718192021222324export const ProjectListScreen = () =&gt; &#123; // 先定义error状态 const [error, setError] = useState&lt;null | Error&gt;(null) const debouncedParam = useDebounce(param, 200) useEffect(() =&gt; &#123; setIsLoading(true) // 在catch中操纵错误 client(&#x27;projects&#x27;, &#123; data: cleanObject(debouncedParam) &#125;) .then(setList) .catch(error =&gt; &#123; setList([]) setError(error) &#125;) .finally(() =&gt; setIsLoading(false)) // eslint-disable-next-line react-hooks/exhaustive-deps &#125;, [debouncedParam]) return &lt;Container&gt; &lt;h1&gt;项目列表&lt;/h1&gt; &lt;SearchPanel ...&gt;&lt;/SearchPanel&gt; &#123;error ? &lt;Typography.Text type=&#123;&#x27;danger&#x27;&#125;&gt;&#123;error.message&#125;&lt;/Typography.Text&gt; : null&#125; &lt;List ...&gt;&lt;/List&gt; &lt;/Container&gt;&#125; 7-2 用高级 Hook-useAsync统一处理Loading和Error状态 新建src/utils/use-async.ts编写自定义hook useAsync： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import &#123; useState &#125; from &quot;react&quot;interface State&lt;D&gt; &#123; error: Error | null data: D | null stat: &#x27;idle&#x27; | &#x27;loading&#x27; | &#x27;error&#x27; | &#x27;success&#x27;&#125;const defaultInitialState: State&lt;null&gt; = &#123; stat: &#x27;idle&#x27;, data: null, error: null&#125;/** * @param initialState 用户传入的state，优先级比defaultInitialState高 */export const useAsync = &lt;D&gt;(initialState?: State&lt;D&gt;) =&gt; &#123; const [state, setState] = useState&lt;State&lt;D&gt;&gt;(&#123; ...defaultInitialState, ...initialState &#125;) // 请求成功 const setData = (data: D) =&gt; setState(&#123; data, stat: &#x27;success&#x27;, error: null &#125;) // 请求失败 const setError = (error: Error) =&gt; setState(&#123; error, stat: &#x27;error&#x27;, data: null &#125;) // run用来触发异步请求 const run = (promise: Promise&lt;D&gt;) =&gt; &#123; if (!promise || !promise.then) &#123; // 会打断一切进程 throw new Error(&#x27;请传入 Promise 类型数据&#x27;) &#125; setState(&#123; ...state, stat: &#x27;loading&#x27; &#125;) return promise.then(data =&gt; &#123; setData(data) return data &#125;).catch(error =&gt; &#123; setError(error) return error &#125;) &#125; return &#123; isIdle: state.stat === &#x27;idle&#x27;, isLoading: state.stat === &#x27;loading&#x27;, isError: state.stat === &#x27;error&#x27;, isSuccess: state.stat === &#x27;success&#x27;, run, setData, setError, ...state &#125;&#125; 在src/screens/project-list/index.tsx中使用： 1234567891011121314151617import &#123; List, Project &#125; from &quot;./list&quot;import &#123; useAsync &#125; from &quot;utils/use-async&quot;export const ProjectListScreen = () =&gt; &#123; const &#123; run, isLoading, error, data: list &#125; = useAsync&lt;Project[]&gt;() const debouncedParam = useDebounce(param, 200) useEffect(() =&gt; &#123; run(client(&#x27;projects&#x27;, &#123; data: cleanObject(debouncedParam) &#125;)) // eslint-disable-next-line react-hooks/exhaustive-deps &#125;, [debouncedParam]) return &lt;Container&gt; ... &lt;List loading=&#123;isLoading&#125; dataSource=&#123;list || []&#125; users=&#123;users&#125;&gt;&lt;/List&gt; &lt;/Container&gt;&#125; 以上run操作和useAsync可以抽象成src/utils/project.ts： 12345678910111213141516import &#123; useEffect &#125; from &quot;react&quot;import &#123; Project &#125; from &quot;screens/project-list/list&quot;import &#123; cleanObject &#125; from &quot;utils&quot;import &#123; useHttp &#125; from &quot;./http&quot;import &#123; useAsync &#125; from &quot;./use-async&quot;export const useProjects = (param?: Partial&lt;Project&gt;) =&gt; &#123; const client = useHttp() const &#123; run, ...result &#125; = useAsync&lt;Project[]&gt;() useEffect(() =&gt; &#123; run(client(&#x27;projects&#x27;, &#123; data: cleanObject(param || &#123;&#125;) &#125;)) // eslint-disable-next-line react-hooks/exhaustive-deps &#125;, [param]) return result&#125; src/screens/project-list/index.tsx进行改造： 12345678910export const ProjectListScreen = () =&gt; &#123; const [param, setParam] = useState(&#123; name: &#x27;&#x27;, personId: &#x27;&#x27; &#125;) const debouncedParam = useDebounce(param, 200) const client = useHttp() const &#123; isLoading, error, data: list &#125; = useProjects(debouncedParam) return ...&#125; 用户列表也可以进行以上抽象，新建src/utils/user.ts： 12345678910111213141516import &#123; useEffect &#125; from &quot;react&quot;;import &#123; User &#125; from &quot;screens/project-list/search-panel&quot;;import &#123; cleanObject &#125; from &quot;utils&quot;;import &#123; useHttp &#125; from &quot;./http&quot;;import &#123; useAsync &#125; from &quot;./use-async&quot;;export const useUsers = (param?: Partial&lt;User&gt;) =&gt; &#123; const client = useHttp() const &#123; run, ...result &#125; = useAsync&lt;User[]&gt;() useEffect(() =&gt; &#123; run(client(&#x27;users&#x27;, &#123; data: cleanObject(param || &#123;&#125;) &#125;)) // eslint-disable-next-line react-hooks/exhaustive-deps &#125;, [param]) return result&#125; src/screens/project-list/index.tsx进行改造： 1234export const ProjectListScreen = () =&gt; &#123; const &#123; data: users &#125; = useUsers() return ...&#125; 综上，共封装了两层： 第一层是useProjects和useUsers，把获取projects和users列表的详细信息都隐藏在这个custom hook中了； 第二层是在useProjects和useUsers这俩custom hook中，把维持loading和error的信息都隐藏在useAsync中了。 7-3 登录注册页面Loading和Error状态处理，与Event Loop详解 在src/unauthenticated-app/index.tsx添加error状态并展示： 12345678910111213export const UnauthenticatedApp = () =&gt; &#123; const [error, setError] = useState&lt;Error | null&gt;(null) return &lt;Container&gt; ... &lt;ShadowCard&gt; &lt;Title&gt;&#123;isRegister ? &#x27;请注册&#x27; : &#x27;请登录&#x27;&#125;&lt;/Title&gt; &#123;error ? &lt;Typography.Text type=&#123;&#x27;danger&#x27;&#125;&gt;&#123;error.message&#125;&lt;/Typography.Text&gt; : null&#125; &#123;/* 当RegisterScreen或LoginScreen中抛出错误时，error才有值 */&#125; &#123;isRegister ? &lt;RegisterScreen onError=&#123;setError&#125; /&gt; : &lt;LoginScreen onError=&#123;setError&#125; /&gt;&#125; ... &lt;/ShadowCard&gt; &lt;/Container&gt;&#125; 给RegisterScreen和LoginScreen两个组件添加onError属性，并调用： 123456789export const RegisterScreen = (&#123; onError &#125;: &#123; onError: (error: Error) =&gt; void &#125;) =&gt; &#123; const handleSubmit = (values: &#123; username: string, password: string &#125;) =&gt; &#123; try &#123; register(values) &#125; catch (e) &#123; onError(e) &#125; &#125;&#125; 123456789export const LoginScreen = (&#123; onError &#125;: &#123; onError: (error: Error) =&gt; void &#125;) =&gt; &#123; const handleSubmit = (values: &#123; username: string, password: string &#125;) =&gt; &#123; try &#123; login(values) &#125; catch (e) &#123; onError(e) &#125; &#125;&#125; 由于我们要展示error.message，但现在报错返回了{name:’’,password:’’}，检查之前的代码发现在src/auth-provider.ts中我们确实抛出了data，修正如下： 123456789101112131415161718192021222324252627&gt;export const login = (data: &#123; username: string; password: string &#125;) =&gt; &#123; return fetch(`$&#123;apiUrl&#125;/login`, &#123; ... &#125;).then(async response =&gt; &#123; if (response.ok) &#123; return handleUserResponse(await response.json()) &#125; else &#123; // 相当于throw new Error // return Promise.reject(data) return Promise.reject(await response.json()) &#125; &#125;)&gt;&#125;&gt;export const register = (data: &#123; username: string; password: string &#125;) =&gt; &#123; return fetch(`$&#123;apiUrl&#125;/register`, &#123; ... &#125;).then(async response =&gt; &#123; if (response.ok) &#123; return handleUserResponse(await response.json()) &#125; else &#123; // 相当于throw new Error // return Promise.reject(data) return Promise.reject(await response.json()) &#125; &#125;)&gt;&#125; 再次登录发现返回的错误信息&#123;status: 400, message: &quot;Invalid name or password&quot;&#125;是对的，但是页面上却没有展示，原因是在src/unauthenticated-app/login.tsx中的login(values)返回一个promise，它是个异步的函数，我们之前直接用login(values).catch()能捕获到错误，因为catch里的内容会等到login异步执行完成后再执行，但try…catch…中的catch却不会等异步完成，而是会优先调用，导致捕获不到异步完成后抛出的错误，解决办法是使用async…await…： 1234567&gt;const handleSubmit = async (values: &#123; username: string, password: string &#125;) =&gt; &#123; try &#123; await login(values) &#125; catch (e) &#123; onError(e) &#125;&gt;&#125; 实现密码二次验证的功能： 123456789101112131415161718192021222324export const RegisterScreen = (&#123; onError &#125;: &#123; onError: (error: Error) =&gt; void &#125;) =&gt; &#123; const handleSubmit = async (&#123; cpassword, ...values &#125;: &#123; username: string, password: string, cpassword: string &#125;) =&gt; &#123; if (cpassword !== values.password) &#123; onError(new Error(&#x27;请确认两次输入的密码相同&#x27;)) return &#125; try &#123; await register(values) &#125; catch (e) &#123; onError(e) &#125; &#125; return &lt;Form onFinish=&#123;handleSubmit&#125;&gt; ... &lt;Form.Item name=&#123;&#x27;password&#x27;&#125; rules=&#123;[&#123; required: true, message: &#x27;请输入密码&#x27; &#125;]&#125;&gt; &lt;Input placeholder=&#123;&#x27;密码&#x27;&#125; type=&quot;password&quot; id=&#123;&#x27;password&#x27;&#125; /&gt; &lt;/Form.Item&gt; &lt;Form.Item name=&#123;&#x27;cpassword&#x27;&#125; rules=&#123;[&#123; required: true, message: &#x27;请确认密码&#x27; &#125;]&#125;&gt; &lt;Input placeholder=&#123;&#x27;确认密码&#x27;&#125; type=&quot;password&quot; id=&#123;&#x27;cpassword&#x27;&#125; /&gt; &lt;/Form.Item&gt; ... &lt;/Form&gt;&#125; 登录接口请求较慢时，为其添加loading： 1234567891011121314151617export const LoginScreen = (&#123; onError &#125;: &#123; onError: (error: Error) =&gt; void &#125;) =&gt; &#123; const &#123; run, isLoading &#125; = useAsync() const handleSubmit = async (values: &#123; username: string, password: string &#125;) =&gt; &#123; try &#123; await run(login(values)) &#125; catch (e) &#123; onError(e) &#125; &#125; return &lt;Form onFinish=&#123;handleSubmit&#125;&gt; ... &lt;Form.Item&gt; &lt;LongButton loading=&#123;isLoading&#125; htmlType=&#123;&#x27;submit&#x27;&#125; type=&#123;&#x27;primary&#x27;&#125;&gt;登录&lt;/LongButton&gt; &lt;/Form.Item&gt; &lt;/Form&gt;&#125; 上面loading效果出来了，但是错误信息又不展示了，在src/utils/use-async.ts中可以看到run方法的定义中，当promise抛出异常时，才调用其中的catch，为什么外面却接收不到这里抛出的异常呢，是因为在这里我们已经内部消化掉了，改动如下： 12345678910return promise.then(data =&gt; &#123; setData(data) return data&#125;).catch(error =&gt; &#123; // catch会消化异常，如果不主动抛出，外面是接收不到异常的 setError(error) // return error // 改为： return Promise.reject(error)&#125;) 这里可能会产生疑问：上面useAsync返回值了有error，为什么不直接使用它？ 是因为error的获取是同步的，当同步和异步混用时，就得使用try…catch…。 延伸阅读专栏-前端面试精选集-05 异步函数与Promise： 一个页面的脚本如下，请问会打印出什么内容？ 123456789101112console.log(&#x27;script start&#x27;)setTimeout(() =&gt; &#123; console.log(&#x27;setTimeout&#x27;)&#125;, 0)new Promise((resolve) =&gt; &#123; console.log(&#x27;promise1&#x27;) resolve(&#x27;&#x27;) console.log(&#x27;promise2&#x27;)&#125;).then(() =&gt; &#123; console.log(&#x27;promise then&#x27;)&#125;)console.log(&#x27;script end&#x27;) 答案： 123456script startpromise1promise2script endpromise thensetTimeout 解读： 前四个都是同步代码，尽管promise1和2是在new Promise中，但是构建Promise的过程即then之前的内容都是同步的。 因为JavaScript中有2种任务： 宏任务：同步script(整体代码)、setTimeout回调函数、setInterval回调函数、I/O、UI rendering； 微任务：process.nextTick、Promise回调函数、Object.observe、MutationObserver。 其执行的顺序为-宏任务和微任务交替执行： 首先JavaScript引擎会执行一个宏任务，注意这个宏任务一般是主干代码本身，也就是目前的同步代码 执行过程中如果遇到微任务，就把它添加到微任务的任务队列中 宏任务执行完成后，立即执行当前微任务队列中的微任务，直到微任务队列被清空 微任务执行完丑，开始执行下一个宏任务 如此循环往复，直到宏任务和微任务被清空 略 有时候我们并不想在useAsync()外面使用try…catch…，而是直接使用它返回的error，可以修改useAsync传递不同的配置参数，返回不同的错误处理方式： src/utils/use-async.ts： 1234567891011121314151617181920const defaultConfig = &#123; throwOnError: false&#125;export const useAsync = &lt;D&gt;(initialState?: State&lt;D&gt;, initialConfig?: typeof defaultConfig) =&gt; &#123; const config = &#123; ...defaultConfig, ...initialConfig &#125; ... const run = (promise: Promise&lt;D&gt;) =&gt; &#123; ... return promise.then(data =&gt; &#123; setData(data) return data &#125;).catch(error =&gt; &#123; // catch会消化异常，如果不主动抛出，外面是接收不到异常的 setError(error) if (config.throwOnError) return Promise.reject(error) return error &#125;) &#125; return ...&#125; 在src/unauthenticated-app/login.tsx中： 123456789101112export const LoginScreen = (&#123; onError &#125;: &#123; onError: (error: Error) =&gt; void &#125;) =&gt; &#123; const &#123; login &#125; = useAuth() const &#123; run, isLoading &#125; = useAsync(undefined, &#123; throwOnError: true &#125;) const handleSubmit = async (values: &#123; username: string, password: string &#125;) =&gt; &#123; try &#123; await run(login(values)) &#125; catch (e) &#123; onError(e) &#125; &#125; return ...&#125; src/unauthenticated-app/register.tsx的修改同上。 7-4 用useAsync获取用户信息在项目列表页的接口返回成功后，列表才渲染出来，希望实现的效果是在接口还没返回时，在页面先渲染一个loading，告诉用户稍等… src/context/auth-context.tsx修改如下： 1234567891011121314import &#123; useAsync &#125; from &quot;utils/use-async&quot;export const AuthProvider = (&#123; children &#125;: &#123; children: ReactNode &#125;) =&gt; &#123; // const [user, setUser] = useState&lt;User | null&gt;(null) const &#123; data: user, error, isLoading, isIdle, isError, run, setData: setUser &#125; = useAsync&lt;User | null&gt;() ... useMount(() =&gt; &#123; // bootstrapUser().then(setUser) run(bootstrapUser()) &#125;) if (isIdle || isLoading) &#123; return &lt;p&gt;loading...&lt;/p&gt; &#125; return &lt;AuthContext.Provider children=&#123;children&#125; value=&#123;&#123; user, login, register, logout &#125;&#125; /&gt;&#125; 这时候在接口返回前，页面左上角会出现loading…文字。 上面的loading并不好看，可以实现一个全屏的loading： 在src/components/lib.tsx中添加组件： 123456789101112import React from &#x27;react&#x27;import &#123; Spin &#125; from &#x27;antd&#x27;const FullPage = styled.div`height: 100vh;display: flex;justify-content: center;align-items: center;`export const FullPageLoading = () =&gt; &lt;FullPage&gt; &lt;Spin size=&#123;&#x27;large&#x27;&#125; /&gt;&lt;/FullPage&gt; 对上面的src/context/auth-context.tsx进行修改： 1234if (isIdle || isLoading) &#123; // return &lt;p&gt;loading...&lt;/p&gt; return &lt;FullPageLoading /&gt;&#125; 如果获取用户信息接口抛出异常了，会跳到未登录页，但是这个接口失败了，我们再次登录进去还会再自动登出的，不如直接在这里显示错误信息，让用户知道我们的网站可能在维护，而不是让他一遍遍去试着登录。 与上面的loading类似，先在src/components/lib.tsx中添加组件： 123export const FullPageErrorFallBack = (&#123; error &#125;: &#123; error: Error | null &#125;) =&gt; &lt;FullPage&gt; &lt;Typography.Text type=&#123;&#x27;danger&#x27;&#125;&gt;&#123;error?.message&#125;&lt;/Typography.Text&gt;&lt;/FullPage&gt; 在src/context/auth-context.tsx中添加： 12345678export const AuthProvider = (&#123; children &#125;: &#123; children: ReactNode &#125;) =&gt; &#123; const &#123; data: user, error, isLoading, isIdle, isError, run, setData: setUser &#125; = useAsync&lt;User | null&gt;() ... if (isError) &#123; return &lt;FullPageErrorFallBack error=&#123;error&#125; /&gt; &#125; return ...&#125; 7-5 实现Error Boundaries，捕获边界错误使用现成的库即可：https://github.com/bvaughn/react-error-boundary 第8章 Hook，路由，与 URL 状态管理8-1 ⽤useRef实现useDocumentTitle - useRef与Hook 闭包详解（上） 在src/utils/index.ts中编写新的hook： 12345export const useDocumentTitle = (title: string) =&gt; &#123; useEffect(() =&gt; &#123; document.title = title &#125;, [title])&#125; 在src/unauthenticated-app/index.tsx中使用： 1234import &#123; useDocumentTitle &#125; from &quot;utils&quot;export const UnauthenticatedApp = () =&gt; &#123; useDocumentTitle(&#x27;请登录注册以继续&#x27;)&#125; 在src/screens/project-list/index.tsx中使用：useDocumentTitle(&#39;项目列表&#39;) 但是这样的做法就要求每个页面都要指定documentTitle，如果忘记了，就会保留上个页面的title。 离开页面时，还原成项目默认的title： 修改src/utils/index.ts： 123456789101112export const useDocumentTitle = (title: string, keepOnUnmount: boolean = true) =&gt; &#123; const oldTitle = document.title useEffect(() =&gt; &#123; document.title = title &#125;, [title]) useEffect(() =&gt; &#123; return () =&gt; &#123; if (!keepOnUnmount) document.title = oldTitle &#125; &#125;, [])&#125; 将unauthenticated-app/index.tsx中的useDocumentTitle注掉，为screens/project-list/index.tsx添加useDocumentTitle(&#39;项目列表&#39;, false)，将public/index.html中的title改为“Jira任务管理系统”，可见在项目列表页的退出时，title还原成了默认的。 8-2 ⽤useRef实现useDocumentTitle - useRef与Hook 闭包详解（下） 新建src/screens/project-list/test.tsx做个试验： 123456789101112131415161718192021222324import React, &#123; useEffect, useState &#125; from &quot;react&quot;;import &#123; useMount &#125; from &quot;utils&quot;;export const Test = () =&gt; &#123; const [num, setNum] = useState(0) const add = () =&gt; setNum(num + 1) useMount(() =&gt; &#123; setInterval(() =&gt; &#123; console.log(&#x27;num in setInterval:&#x27;, num); // 一直是0 &#125;, 1000) &#125;) useEffect(() =&gt; &#123; return () =&gt; &#123; console.log(num); // 0 &#125; &#125;, []) return &lt;div&gt; &lt;button onClick=&#123;add&#125;&gt;add&lt;/button&gt; &lt;p&gt;number:&#123;num&#125;&lt;/p&gt; &lt;/div&gt;&#125; 在src/screens/project-list/index.tsx中使用&lt;Test /&gt;，以上两个log处都是初始值0，这涉及到react hook 与 闭包，是hook与闭包经典的坑。 useMount和useEffect只有在页面加载时被执行一次，里面就形成了一个闭包，而它的作用域引用的是页面加载时num的值，后面无论页面怎么渲染、num怎么变化，它们都不会再被执行了。所以回调函数中的闭包作用域引用的永远是页面初始时的值，怎么避免呢？要把[num]作为依赖传递到回调函数中。 如下，通过给useEffect指定正确的依赖，成功地让useEffect里面的作用域拿到了最新的值： 12345678910111213141516171819export const Test = () =&gt; &#123; const [num, setNum] = useState(0) const add = () =&gt; setNum(num + 1) useEffect(() =&gt; &#123; const id = setInterval(() =&gt; &#123; console.log(&#x27;num in setInterval:&#x27;, num); &#125;, 1000) return () =&gt; clearInterval(id) &#125;, [num]) useEffect(() =&gt; &#123; return () =&gt; &#123; console.log(num); &#125; &#125;, [num]) return ...&#125; 经过以上试验，重新审视src/utils/index.ts： 1234567891011121314151617export const useDocumentTitle = (title: string, keepOnUnmount: boolean = true) =&gt; &#123; const oldTitle = document.title // 页面加载时：oldTitle === 旧title &#x27;React App&#x27; // 加载后：oldTitle === 新title useEffect(() =&gt; &#123; document.title = title &#125;, [title]) useEffect(() =&gt; &#123; return () =&gt; &#123; if (!keepOnUnmount) &#123; // 如果不指定依赖，读到的就是旧title document.title = oldTitle &#125; &#125; &#125;, [])&#125; 虽然以上的闭包写法是奏效的，但react依然报依赖warning，而且对于看我们代码的人并不友好、并不直观，进行如下修改： 1234567891011121314151617export const useDocumentTitle = (title: string, keepOnUnmount: boolean = true) =&gt; &#123; // 因为这种写法的oldTitle始终会是最新的值，就没法保留初始化的值了 // 所以要采用useRef().current，它在这个组件的生命周期中都不会变化 // const oldTitle = document.title const oldTitle = useRef(document.title).current // 帮助持久化变量 // 页面加载时：旧title // 加载后：新title useEffect(() =&gt; &#123; document.title = title &#125;, [title]) useEffect(() =&gt; &#123; return () =&gt; &#123; if (!keepOnUnmount) document.title = oldTitle &#125; &#125;, [keepOnUnmount, oldTitle])&#125; 8-3 添加项目列表和项目详情路由 线上地址 https://sindu12jun.github.io/projects 安装路由：$ npm i react-router@6.0.0-beta.0 react-router-dom@6.0.0-beta.0 history -S 在src\\authenticated-app.tsx中对路由进行配置： 先将&lt;Header&gt;&lt;/Header&gt;提成组件PageHeader，看起来能舒服一点，配置路由： 123456789101112131415161718import &#123; Navigate, Route, Routes &#125; from &quot;react-router&quot;;import &#123; BrowserRouter as Router &#125; from &#x27;react-router-dom&#x27;export const AuthenticatedApp = () =&gt; &#123; return &lt;Container&gt; &lt;PageHeader /&gt; &lt;Main&gt; &lt;Router&gt; &lt;Routes&gt; &lt;Route path=&#123;&#x27;/projects&#x27;&#125; element=&#123;&lt;ProjectListScreen /&gt;&#125;&gt;&lt;/Route&gt; &lt;Route path=&#123;&#x27;/projects/:projectId/*&#x27;&#125; element=&#123;&lt;ProjectScreen /&gt;&#125;&gt;&lt;/Route&gt; &#123;/* 匹配不到上面两个路由，就自动打开projects */&#125; &lt;Navigate to=&#123;&#x27;/projects&#x27;&#125; /&gt; &lt;/Routes&gt; &lt;/Router&gt; &lt;/Main&gt; &lt;/Container&gt;&#125; 启动并通过http://localhost:3000会自动打开 http://localhost:3000/projects 访问列表页，而且注意Routes包裹不能丢，否则里面的两个Route就会同时显示了。 react-router 和 react-router-dom的关系，类似于react 和 react-dom/react-native/react-vr… react是一个核心的库，里面主要处理虚拟的、计算的、理论的逻辑，类似于在组件中的state、useEffect的状态怎么影响虚拟dom树，这次的虚拟dom树和上次的虚拟dom树中间的diff运算，都是在react中处理的 经过一系列的计算，得出的结果就会被react-dom消费。 为什么一开始不把react和react-dom结合在一起，因为react-dom主要生活在浏览器的宿主环境里，里面充满了dom操作，而这些dom操作只能在浏览器中运行；而react-native是用来的在native环境如在ios和安卓环境中来消费react运算出的结果；react-vr也一样，来消费那个结果并渲染在ps5上 react-router主要用来管理路由状态，所以Routes和Route都是从它中引入进来，它们在内存中就像是个对象，用来计算当前这个路由树是怎样的，计算结果就给react-router-dom消费，或者也可以给native环境消费。 对src\\screens\\project-list\\list.tsx进行修改使用router： 123456789export const List = (&#123; users, ...props &#125;: ListProps) =&gt; &#123; return &lt;Table pagination=&#123;false&#125; columns=&#123;[&#123; title: &#x27;名称&#x27;, sorter: (a, b) =&gt; a.name.localeCompare(b.name), render(value, project) &#123; return &lt;Link to=&#123;String(project.id)&#125;&gt;&#123;project.name&#125;&lt;/Link&gt; &#125; &#125;, ... /&gt;&#125; 这样在列表页点击名称，就会跳到&lt;Route path=&#123;&#39;/projects/:projectId/*&#39;&#125; element=&#123;&lt;ProjectScreen /&gt;&#125;&gt;&lt;/Route&gt;对应的页面，即ProjectScreen。 8-4 添加看板和任务组路由 在src\\screens\\project\\index.tsx中添加跳转入口和路由： 1234567891011121314151617181920212223import React from &quot;react&quot;;import &#123; Link &#125; from &quot;react-router-dom&quot;;import &#123; Navigate, Route, Routes &#125; from &#x27;react-router&#x27;import &#123; KanbanScreen &#125; from &quot;screens/kanban&quot;;import &#123; EpicScreen &#125; from &quot;screens/epic&quot;;export const ProjectScreen = () =&gt; &#123; return &lt;div&gt; &lt;h1&gt;project screen&lt;/h1&gt; &#123;/* 加斜线是根路由 */&#125; &#123;/* &lt;Link to=&#123;&#x27;/kanban&#x27;&#125;&gt;看板&lt;/Link&gt; */&#125; &lt;Link to=&#123;&#x27;kanban&#x27;&#125;&gt;看板&lt;/Link&gt; &lt;Link to=&#123;&#x27;epic&#x27;&#125;&gt;任务组&lt;/Link&gt; &lt;Routes&gt; &#123;/* projects/:projectId/kanban */&#125; &lt;Route path=&#123;&#x27;/kanban&#x27;&#125; element=&#123;&lt;KanbanScreen /&gt;&#125;&gt;&lt;/Route&gt; &#123;/* projects/:projectId/epic */&#125; &lt;Route path=&#123;&#x27;/epic&#x27;&#125; element=&#123;&lt;EpicScreen /&gt;&#125;&gt;&lt;/Route&gt; &#123;/* 如果不能匹配上面写的两个路由，就统一打开kanban */&#125; &lt;Navigate to=&#123;window.location.pathname + &#x27;/kanban&#x27;&#125; /&gt; &lt;/Routes&gt; &lt;/div&gt;&#125; 在src\\authenticated-app.tsx中实现切换到根路由的功能： 123456789101112const PageHeader = () =&gt; &#123; const &#123; logout, user &#125; = useAuth() return &lt;Header between&gt; &lt;HeaderLeft gap&gt; &lt;Button type=&#123;&#x27;link&#x27;&#125; onClick=&#123;resetRoute&#125;&gt; &lt;SoftwareLogo width=&#123;&#x27;6rem&#x27;&#125; color=&#123;&#x27;rgb(38,132,255)&#x27;&#125; /&gt; &lt;/Button&gt; ... &lt;/HeaderLeft&gt; ... &lt;/Header&gt;&#125; 在src\\utils\\index.ts中定义resetRoute()，不仅可以重置路由状态，还能刷新整个页面： 1export const resetRoute = () =&gt; window.location.href = window.location.origin 8-5 初步实现 useUrlQueryParam 管理 URL 参数状态新建src\\utils\\url.ts： 123456789101112131415// 文档见https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParamsimport &#123; useSearchParams &#125; from &quot;react-router-dom&quot;/** * 返回页面url中，指定键的参数值 */export const useUrlQueryParam = (keys: string[]) =&gt; &#123; const [searchParams, setSearchParam] = useSearchParams() return [ keys.reduce((prev: &#123; [p: string]: string &#125;, key: string) =&gt; &#123; return &#123; ...prev, [key]: searchParams.get(key) || &#x27;&#x27; &#125; &#125;, &#123;&#125; as &#123; [key in string]: string &#125;), setSearchParam ] as const&#125; as const举例解读： 1const a = [&#x27;jack&#x27;, 12, &#123; gender: &#x27;male&#x27; &#125;] 我们想要的第一个string，第二个number，第三个对象，但现在的类型是每个位置都可能是string|number|{gender:string}，这是因为ts会把它默认为数组，而在ts的数组中元素类型都应该保持一致，所以让它们三个都有个string|number|{gender:string}就能保持一致了。但我们想要的是个tuple类型，所以可以使用as const解决： 1const a1 = [&#x27;jack&#x27;, 12, &#123; gender: &#x27;male&#x27; &#125;] as const reduce()方法的第二个参数如果只传{}，useUrlQueryParam的第一个参数会被推断为空对象，所以要强制给它指定成&#123; [key in string]: string &#125; 在src\\screens\\project-list\\index.tsx中调用：console.log(useUrlQueryParam([&#39;name&#39;]))，访问http://localhost:3000/projects?name=%E9%AA%91%E6%89%8B%E7%AE%A1%E7%90%86，打印出`[{&quot;name&quot;: “骑手管理”}]`。 8-6 用useMemo解决依赖循环问题 - Hook的依赖问题详解 在src\\screens\\project-list\\index.tsx中修改： 12345678910export const ProjectListScreen = () =&gt; &#123; const [, setParam] = useState(&#123; name: &#x27;&#x27;, personId: &#x27;&#x27; &#125;) const [param] = useUrlQueryParam([&#x27;name&#x27;, &#x27;personId&#x27;]) const debouncedParam = useDebounce(param, 200) const &#123; isLoading, error, data: list &#125; = useProjects(debouncedParam) ...&#125; 修改src\\utils\\url.ts如下： 123456789export const useUrlQueryParam = &lt;K extends string&gt;(keys: K[]) =&gt; &#123; const [searchParams, setSearchParam] = useSearchParams() return [ keys.reduce((prev, key) =&gt; &#123; return &#123; ...prev, [key]: searchParams.get(key) || &#x27;&#x27; &#125; &#125;, &#123;&#125; as &#123; [key in K]: string &#125;), setSearchParam ] as const&#125; 按照上面修改后，仍会无限循环，可以用这个库分析 https://github.com/welldone-software/why-did-you-render。 经过分析，提示&#123;&quot;prev&quot;:&#123;name:&quot;&quot;,personId:&quot;&quot;&#125;&#125;和&#123;&quot;next&quot;:&#123;name:&quot;&quot;,personId:&quot;&quot;&#125;&#125;这两个对象不是同一个，因为js的引用对象在对比时实际对比的是地址，而不是值。比如： 123const a = &#123;name: &#x27;Jack&#x27;&#125;const b = &#123;name: &#x27;Jack&#x27;&#125;a === b // false 在项目里分析，怀疑是src\\screens\\project-list\\index.tsx中const debouncedParam = useDebounce(param, 200)的param在useDebounce中作为useEffect的依赖，这个param在每次渲染时都重新创建了一个新的对象，导致这次渲染创建的对象和上次渲染创建的对象地址不一样，从而导致了这个无限渲染，但是为什么这个param每次渲染时都重新创建新对象呢？ 从src\\utils\\url.ts中可以看出(代码见上面)，在每次渲染时都会执行keys.reduce()方法，它在每次渲染时都会创建一个新的对象，这就是造成无限渲染的罪魁祸首。 举例说明： 1234567891011121314import React, &#123; useEffect, useState &#125; from &quot;react&quot;;export default function App() &#123; const obj = &#123; name: &#x27;Jack&#x27; &#125; const [num, setNum] = useState(0) useEffect(() =&gt; &#123; setNum(num + 1) &#125;, [obj]) return ( &lt;div&gt;&#123;num&#125;&lt;/div&gt; )&#125; 这个代码会导致num无限累加，原因： 在页面第一次加载时setNum(num+1)会调用，会造成这个组件重新渲染，进入第二次渲染，第二次渲染时，obj又重新定义了一次，与上一个obj虽然值一样，但不是同一个对象，因为它是useEffect的依赖，所以useEffect又被调用一次，如此循环往复… 如果把上面的obj定义为1，就不会无限循环。 综上，当obj是基本类型时，就不会无限循环；当obj是对象时，就会无限循环。 回到我们的项目，需要借助useMemo来解决： 123456789101112131415import &#123; useMemo &#125; from &quot;react&quot;import &#123; useSearchParams &#125; from &quot;react-router-dom&quot;export const useUrlQueryParam = &lt;K extends string&gt;(keys: K[]) =&gt; &#123; const [searchParams, setSearchParam] = useSearchParams() return [ useMemo( () =&gt; keys.reduce((prev, key) =&gt; &#123; return &#123; ...prev, [key]: searchParams.get(key) || &#x27;&#x27; &#125; &#125;, &#123;&#125; as &#123; [key in K]: string &#125;), [searchParams] ), setSearchParam ] as const&#125; 这里可能会有疑惑：searchParams也是个对象，放到依赖里不会导致无限循环吗？ 不会，这是因为searchParams是useSerchParams这个hook返回的state，react在对比state时就不会像对比直接定义的obj那样用===对比，而是只有显式地调用setSearchParam时，react才会认为searchParams发生了改变。 以上代码会报一个warning: React Hook useMemo has a missing dependency:’keys’，如果我们把keys作为依赖给useMemo，又会陷入无限循环，因为在调用useUrlQueryParam([&#39;name&#39;, &#39;personId&#39;])时，相当于定义了一个const arr = [&#39;name&#39;, &#39;personId&#39;]，然后传给useUrlQueryParam(arr)，由于arr是引用类型，所以当它作为依赖时会导致无限循环。 解决办法有两种： 把keys提成state，因为state放在依赖列表里不会无限循环，而且想改变这个keys时，可以定义并调用setKeys()。 src\\screens\\project-list\\index.tsx： 12const [keys] = useState&lt;(&#x27;name&#x27; | &#x27;personId&#x27;)[]&gt;([&#x27;name&#x27;, &#x27;personId&#x27;])const [param] = useUrlQueryParam(keys) src\\utils\\url.ts： 123456useMemo( () =&gt; keys.reduce((prev, key) =&gt; &#123; return &#123; ...prev, [key]: searchParams.get(key) || &#x27;&#x27; &#125; &#125;, &#123;&#125; as &#123; [key in K]: string &#125;), [searchParams, keys]), 注释忽略warning src\\utils\\url.ts： 1234567useMemo( () =&gt; keys.reduce((prev, key) =&gt; &#123; return &#123; ...prev, [key]: searchParams.get(key) || &#x27;&#x27; &#125; &#125;, &#123;&#125; as &#123; [key in K]: string &#125;), // eslint-disable-next-line react-hooks/exhaustive-deps [searchParams]), 总结： 基本类型 可以放到依赖里 组件状态 可以放到依赖里 非组件状态的对象 绝不可以放到依赖里 8-7 完成URL状态管理与JS中的 iterator讲解 优化src\\screens\\project-list\\index.tsx： 123export const ProjectListScreen = () =&gt; &#123; const [param, setParam] = useUrlQueryParam([&#x27;name&#x27;, &#x27;personId&#x27;])&#125; 优化src\\utils\\url.ts中useUrlQueryParam()返回的第二个参数，即对应上面的setParam()，要求setParam的参数只能是以’name’或’personId’作为key的对象： 123456789export const useUrlQueryParam = &lt;K extends string&gt;(keys: K[]) =&gt; &#123; const [searchParams, setSearchParam] = useSearchParams() return [..., (params: Partial&lt;&#123; [key in K]: unknown &#125;&gt;) =&gt; &#123; const o = cleanObject(&#123; ...Object.fromEntries(searchParams), ...params &#125;) as URLSearchParamsInit return setSearchParam(o) &#125; ] as const&#125; 我们常用的数组[]、对象{}和Map都部署了iterator，部署了iterator的数据有一个特点是可以用for…of进行遍历。 怎么查看这个数据上是否部署了iterator？举例说明 123let a =[1, 2, 3]const i = a[Symbol.iterator]()i // [[Prototype]]: Array Iterator 展开i，可以看到它上面有next，调用后打印如下： 1234i.next() // &#123;value: 1, done: false&#125;i.next() // &#123;value: 2, done: false&#125;i.next() // &#123;value: 3, done: false&#125;i.next() // &#123;value: undefined, done: true&#125; 根据以上特性，我们就可以给任意的数据部署iterator： 1234567891011121314151617181920212223242526272829const obj = &#123; data: [&#x27;hello&#x27;, &#x27;world&#x27;], [Symbol.iterator]() &#123; const self = this let index = 0 return &#123; next() &#123; if (index &lt; self.data.length) &#123; return &#123; value: self.data[index++] + &#x27;!&#x27;, done: false &#125; &#125; else &#123; return &#123; value: undefined, done: true &#125; &#125; &#125; &#125; &#125;&#125;for (let o of obj) &#123; console.log(o);&#125;// hello!// world!// undefined Object.fromEntries(iterable) 方法把键值对列表转换为一个对象，它的参数是部署了iterator的数据，类似 Array 、 Map 或者其它实现了可迭代协议的可迭代对象。 第9章 用户选择器与项目编辑功能9-1 实现id-select.tsx解决id类型 难题 select中的id类型string或number有时候不匹配，比如： 1234567&lt;select onChange=&#123;evt =&gt; &#123; const value = evt.target.value console.log(value, typeof value) // 默认选项 string | 1 string &#125;&#125;&gt; &lt;option value=&#123;undefined&#125;&gt;默认选项&lt;/option&gt; &lt;option value=&#123;1&#125;&gt;第一个选项&lt;/option&gt;&lt;/select&gt; 新建src\\components\\id-select.tsx： 1234567891011121314151617181920212223242526272829303132333435import &#123; Select &#125; from &quot;antd&quot;;import React from &quot;react&quot;;import &#123; Raw &#125; from &quot;types&quot;;interface IdSelectProps &#123; value: Raw | null | undefined onChange: (value?: number) =&gt; void // 不管value传什么值，当onChange时，我们把值向外传时，会把所有的值都转化成number，这样使select的行为前后一致，更容易预测 defaultOptionName?: string // 默认值/空值 options?: &#123; name: string, id: number &#125;[]&#125;/** * value 可以传入多种类型的值 * onChange 只会回调 number|undefined类型 * 当 isNaN(Number(value)) 为true时，代表选择默认类型 * 当选择默认类型时，onChange会回调undefined * @param props */export const IdSelect = (props: IdSelectProps) =&gt; &#123; const &#123; value, onChange, defaultOptionName, options &#125; = props return &lt;Select value=&#123;toNumber(value)&#125; // 非0时表示选择了有效项，是0时表示选择了默认项，返回undefined onChange=&#123;value =&gt; onChange(toNumber(value) || undefined)&#125; &gt; &#123; defaultOptionName ? &lt;Select.Option value=&#123;0&#125;&gt;&#123;defaultOptionName&#125;&lt;/Select.Option&gt; : null &#125; &#123; options?.map(option =&gt; &lt;Select.Option key=&#123;option.id&#125; value=&#123;option.id&#125;&gt;&#123;option.name&#125;&lt;/Select.Option&gt;) &#125; &lt;/Select&gt;&#125;const toNumber = (value: unknown) =&gt; isNaN(Number(value)) ? 0 : Number(value) 当我们封装组件时，要考虑允许用户把Select的其他属性都透传进来，所以我们需要把Select上自带的属性都拿出来，统一定义并一次性传到Select身上： 123456789101112131415161718192021// Select身上自带的所有属性类型type SelectProps = React.ComponentProps&lt;typeof Select&gt;// 继承时新定义的类型与母类型可能会有冲突，需要借助Omitinterface IdSelectProps extends Omit&lt;SelectProps, &#x27;value&#x27; | &#x27;onChange&#x27; | &#x27;options&#x27;&gt; &#123; value: Raw | null | undefined onChange: (value?: number) =&gt; void // 不管value传什么值，当onChange时，我们把值向外传时，会把所有的值都转化成number，这样使select的行为前后一致，更容易预测 defaultOptionName?: string // 默认值/空值 options?: &#123; name: string, id: number &#125;[]&#125;export const IdSelect = (props: IdSelectProps) =&gt; &#123; const &#123; value, onChange, defaultOptionName, options, ...restProps &#125; = props return &lt;Select value=&#123;toNumber(value)&#125; // 非0时表示选择了有效项，是0时表示选择了默认项，返回undefined onChange=&#123;value =&gt; onChange(toNumber(value) || undefined)&#125; &#123;...restProps&#125; &gt; ... &lt;/Select&gt;&#125; 9-2 抽象user-select组件选择用户 应用上面的IdSelect对代码进行改造，使string、number和空值问题得以解决： 将src\\screens\\project-list\\search-panel.tsx中定义的User类型的id改成number： 1234export interface User &#123; id: number ...&#125; 将src\\screens\\project-list\\list.tsx中定义的Project类型的id和personId也改成number： 12345export interface Project &#123; id: number personId: number ...&#125; 回到search-panel.tsx，将SearchPanelProps中的param利用utility type进行改造： 1234interface SearchPanelProps &#123; param: Pick&lt;Project, &#39;name&#39; | &#39;personId&#39;&gt; ...&#125; 这里定义的parm类型就和Project中相应的类型自动保持一致了。 修改src\\screens\\project-list\\index.tsx中的报错： 12345export const ProjectListScreen = () =&gt; &#123; const [param, setParam] = useProjectSearchParams() const &#123; isLoading, error, data: list &#125; = useProjects(useDebounce(param, 200)) ...&#125; 新建src\\screens\\project-list\\util.ts，返回项目列表搜索的参数： 123456789import &#123; useUrlQueryParam &#125; from &quot;utils/url&quot;export const useProjectSearchParams = () =&gt; &#123; const [param, setParam] = useUrlQueryParam([&#x27;name&#x27;, &#x27;personId&#x27;]) return [ &#123; ...param, personId: Number(param.personId) || undefined &#125;, setParam ] as const&#125; 同时更正src\\screens\\project-list\\search-panel.tsx中param类型： 1234interface SearchPanelProps &#123; param: Partial&lt;Pick&lt;Project, &#x27;name&#x27; | &#x27;personId&#x27;&gt;&gt; ...&#125; 抽象出组件src\\components\\user-select.tsx： 12345678import React from &quot;react&quot;;import &#123; useUsers &#125; from &quot;utils/user&quot;;import &#123; IdSelect &#125; from &quot;./id-select&quot;;export const UserSelect = (props: React.ComponentProps&lt;typeof IdSelect&gt;) =&gt; &#123; const &#123; data: users &#125; = useUsers() return &lt;IdSelect options=&#123;users || []&#125; &#123;...props&#125; /&gt;&#125; 在src\\screens\\project-list\\search-panel.tsx中使用： 1234567891011121314export const SearchPanel = (&#123; users, param, setParam &#125;: SearchPanelProps) =&gt; &#123; return &lt;Form layout=&#123;&#x27;inline&#x27;&#125; style=&#123;&#123; marginBottom: &#x27;2rem&#x27; &#125;&#125;&gt; ... &lt;Form.Item&gt; &lt;UserSelect defaultOptionName=&#123;&#x27;负责人&#x27;&#125; value=&#123;param.personId&#125; onChange=&#123;value =&gt; setParam(&#123; ...param, personId: value &#125;)&#125; /&gt; &lt;/Form.Item&gt; &lt;/Form&gt;&#125; 以上代码运行后又出现了无限刷新的问题，在src\\screens\\project-list\\util.ts添加useMemo： 1234567export const useProjectSearchParams = () =&gt; &#123; const [param, setParam] = useUrlQueryParam([&#x27;name&#x27;, &#x27;personId&#x27;]) return [ useMemo(() =&gt; (&#123; ...param, personId: Number(param.personId) || undefined &#125;), [param]), setParam ] as const&#125; 将请求时间调久，初始化时在下拉框中可以明显地看出先出现了id值，又变成了中文，原因是在下拉框显示数字的这段时间，uses的数据还没有返回回来，所以这个id没有匹配到任何一项，所以就默认显示了这个id，在src\\components\\id-select.tsx中解决，这样初始化时在数据请求成功前，会显示默认选项“负责人”： 12345678export const IdSelect = (props: IdSelectProps) =&gt; &#123; const &#123; value, onChange, defaultOptionName, options, ...restProps &#125; = props return &lt;Select value=&#123;options?.length ? Number(value) : 0&#125; ... &gt; &lt;/Select&gt;&#125; 9-3 用 useEditProject 编辑项目这几节要实现的功能有项目的收藏与取消收藏、项目的编辑和删除、项目的创建，本节实现收藏与取消收藏的功能： 新建src\\components\\pin.tsx： 1234567891011121314151617import &#123; Rate &#125; from &quot;antd&quot;;import React from &quot;react&quot;;interface PinProps extends React.ComponentProps&lt;typeof Rate&gt; &#123; checked: boolean onCheckedChange?: (checked: boolean) =&gt; void // 之所以把这个方法定为可选类型，是因为比如在title上是纯展示的，并不会用到它&#125;export const Pin = (&#123; checked, onCheckedChange, ...restProps &#125;: PinProps) =&gt; &#123; // const &#123; checked, onCheckedChange, ...restProps &#125; = props return &lt;Rate count=&#123;1&#125; value=&#123;checked ? 1 : 0&#125; onChange=&#123;num =&gt; onCheckedChange?.(!!num)&#125; // 如果onCheckedChange是undefined，就不能调用，所以需要?.；!!num相当于Boolean(num) &#123;...restProps&#125; /&gt;&#125; 在src\\screens\\project-list\\list.tsx的table中添加一列： 12345678910111213141516171819export const List = (&#123; users, ...props &#125;: ListProps) =&gt; &#123; const &#123; mutate &#125; = useEditProject() // const pinProject = (id: number, pin: boolean) =&gt; mutate(&#123; id, pin &#125;) // 观察pinProject的两个参数，project.id在定义函数前就知道了，而pin是在函数参数传进来时才知道，可以用“柯里化”简化 const pinProject = (id: number) =&gt; (pin: boolean) =&gt; mutate(&#123; id, pin &#125;) return &lt;Table pagination=&#123;false&#125; columns=&#123;[ &#123; title: &lt;Pin checked=&#123;true&#125; disabled=&#123;true&#125; /&gt;, render(value, project) &#123; // return &lt;Pin checked=&#123;project.pin&#125; onCheckedChange=&#123;(pin) =&gt; &#123; // mutate(&#123; id: project.id, pin &#125;) // &#125;&#125; /&gt; // return &lt;Pin checked=&#123;project.pin&#125; onCheckedChange=&#123;(pin) =&gt; pinProject(project.id, pin)&#125; /&gt; return &lt;Pin checked=&#123;project.pin&#125; onCheckedChange=&#123;pinProject(project.id)&#125; /&gt; &#125; &#125;, ... ]&#125; /&gt;&#125; 先在src\\utils\\project.ts中定义向服务端发送编辑请求的方法： 1234567891011export const useEditProject = () =&gt; &#123; const &#123; run, ...asyncResult &#125; = useAsync() const client = useHttp() const mutate = (params: Partial&lt;Project&gt;) =&gt; &#123; return run(client(`projects/$&#123;params.id&#125;`, &#123; data: params, method: &#x27;PATCH&#x27; &#125;)) &#125; return &#123; mutate, ...asyncResult &#125;&#125; 注意：这里需要传入参数，如果直接作为hook函数的参数传进来，在调用时需要在行间调用hook并传参(onCheckedChange={()=&gt;useEditProject(id, {pin:true})})，不符合react规定，因为react hook必须放在顶层，不能放在函数里面 在src/utils/project.ts中定义新增方法： 1234567891011export const useAddProject = () =&gt; &#123; const &#123; run, ...asyncResult &#125; = useAsync() const client = useHttp() const mutate = (params: Partial&lt;Project&gt;) =&gt; &#123; return run(client(`projects/$&#123;params.id&#125;`, &#123; data: params, method: &#x27;POST&#x27; &#125;)) &#125; return &#123; mutate, ...asyncResult &#125;&#125; 9-4 编辑后刷新-useState的懒初始化与保存函数状态 当给useState()传入一个函数，想用它保存一个函数时，某些无法预料的事情发生，做个试验进行验证： 123456789101112export default function App() &#123; const [callback, setCallback] = React.useState(()=&gt;&#123; alert(&#x27;init&#x27;) &#125;) return ( &lt;div className=&quot;App&quot;&gt; &lt;button onClick=&#123;() =&gt; setCallback(() =&gt; alert(&quot;set&quot;))&#125;&gt; setCallback &lt;/button&gt; &lt;/div&gt; );&#125; 以上会初始化时弹出2次init，点击set按钮，弹出set。 即向useState中传入函数时，就直接把这个函数运行了 在useState的函数签名function useState&lt;S&gt;(initialState: S | (() =&gt; S)): ...中可以看到，它的参数initialState可以是S或者箭头函数，为什么要把箭头函数专门列出来呢？它有什么特殊性？ 在 惰性初始state文档中，可以看到initialState 参数只会在组件的初始渲染中起作用，后续渲染时会被忽略。 1234const [state, setState] = useState(() =&gt; &#123; const initialState = someExpensiveComputation(props); return initialState;&#125;); 根据里面的例子，可以明确知道，在useState()中传入一个函数是有其特殊意义的，当我们传入一个函数时，react并不会认为我们要保存一个函数，而是会认为要做惰性初始。 如果不用惰性初始state，一般会这样写： 1const [state, setState] = useState(someExpensiveComputation(props)); 这样写在组件每次渲染时，这个昂贵的计算方法someExpensiveComputation()都会重新执行一遍，会导致页面存在很慢或者卡死。 所以上面验证的例子中，React.useState(()=&gt;&#123; alert(&#39;init&#39;) &#125;)会被react看作惰性的初始化，set按钮被认为是对惰性值进行更新，所以会直接执行setCallback(() =&gt; alert(&quot;set&quot;))。 综上，useState直接传入函数的含义是 惰性初始化，所以，要用useState保存函数，不能直接传入函数。 经改造后的代码如下，就达到了用useState保存函数的目的： 123456789101112export default function App() &#123; const [callback, setCallback] = React.useState(() =&gt; () =&gt; &#123; alert(&quot;init&quot;); &#125;); console.log(callback); return ( &lt;div className=&quot;App&quot;&gt; &lt;button onClick=&#123;() =&gt; setCallback(() =&gt; () =&gt; alert(&quot;update&quot;))&#125;&gt;setCallback&lt;/button&gt; &lt;button onClick=&#123;callback&#125;&gt;call callback&lt;/button&gt; &lt;/div&gt; );&#125; 除了上面的方法，还可以使用useRef()： 12345678910111213export default function App() &#123; const callbackRef = React.useRef(() =&gt; alert(&quot;init&quot;)); const callback = callbackRef.current; console.log(callback); return ( &lt;div className=&quot;App&quot;&gt; &lt;button onClick=&#123;() =&gt; (callbackRef.current = () =&gt; alert(&quot;update&quot;))&#125;&gt; setCallback &lt;/button&gt; &lt;button onClick=&#123;callback&#125;&gt;call callback&lt;/button&gt; &lt;/div&gt; );&#125; 先点击call按钮，会弹出init，点击set按钮后再点call，弹出的仍是init，原因是： 点击set按钮后组件并未重新渲染，因为用useRef定义的值并不是组件的状态，它只是个普通的变量，所以在useRef这个容器里保存的值改变时，不会触发组件的重新渲染，因此call按钮的click方法callback()还是第一次渲染时的callback，即init。 如何拿到useRef的最新值呢？ 123&lt;button onClick=&#123;() =&gt; callbackRef.current()&#125;&gt;call callback&lt;/button&gt;// or&lt;button onClick=&#123;() =&gt; callback()&#125;&gt;call callback&lt;/button&gt; 如果改成这样&lt;button onClick=&#123;callbackRef.current&#125;&gt;call callback&lt;/button&gt;弹出的又变成init了，因为点击call按钮，从callbackRef.current读值的操作只会在第一次渲染时发生，当点击时这个current早已被读出来了，这里并不会重新读一遍。 9-5 完成编辑后刷新功能 根据以上的总结，在src\\utils\\use-async.ts中定义retry，并在run()中调用setRetry()且向外返回retry方法： 12345678910111213141516export const useAsync = &lt;D&gt;(initialState?: State&lt;D&gt;, initialConfig?: typeof defaultConfig) =&gt; &#123; const [retry, setRetry] = useState(() =&gt; () =&gt; &#123; &#125;) const run = (promise: Promise&lt;D&gt;, runConfig?: &#123; retry: () =&gt; Promise&lt;D&gt; &#125;) =&gt; &#123; setRetry(() =&gt; () =&gt; &#123; if (runConfig?.retry) &#123; run(runConfig?.retry(), runConfig) &#125; &#125;) ... &#125; return &#123; // retry 被调用时重新跑一遍run，让state刷新一遍 retry, ... &#125;&#125; 在src\\utils\\project.ts中调用run()并传参： 123456789101112export const useProjects = (param?: Partial&lt;Project&gt;) =&gt; &#123; const client = useHttp() const &#123; run, ...result &#125; = useAsync&lt;Project[]&gt;() const fetchProjects = () =&gt; client(&#x27;projects&#x27;, &#123; data: cleanObject(param || &#123;&#125;) &#125;) useEffect(() =&gt; &#123; run(fetchProjects(), &#123; retry: fetchProjects &#125;) // eslint-disable-next-line react-hooks/exhaustive-deps &#125;, [param]) return result&#125; 在src\\screens\\project-list\\index.tsx中使用： 123456789export const ProjectListScreen = () =&gt; &#123; const [param, setParam] = useProjectSearchParams() const &#123; isLoading, error, data: list, retry &#125; = useProjects(useDebounce(param, 200)) return &lt;Container&gt; &lt;Button onClick=&#123;retry&#125;&gt;retry&lt;/Button&gt; ... &lt;/Container&gt;&#125; 怎样在编辑成功后直接执行retry()？ src\\screens\\project-list\\index.tsx中给项目列表添加refresh属性： 1234567export const ProjectListScreen = () =&gt; &#123; const &#123; isLoading, error, data: list, retry &#125; = useProjects(useDebounce(param, 200)) return &lt;Container&gt; &lt;List refresh=&#123;retry&#125; loading=&#123;isLoading&#125; dataSource=&#123;list || []&#125; users=&#123;users || []&#125;&gt;&lt;/List&gt; &lt;/Container&gt;&#125; 在List组件src\\screens\\project-list\\list.tsx中添加refresh数据类型，并在编辑的回调中执行retry： 12345678910interface ListProps extends TableProps&lt;Project&gt; &#123; users: User[] refresh?: () =&gt; void&#125;export const List = (&#123; users, ...props &#125;: ListProps) =&gt; &#123; const &#123; mutate &#125; = useEditProject() const pinProject = (id: number) =&gt; (pin: boolean) =&gt; mutate(&#123; id, pin &#125;).then(props.refresh) return ...&#125; 有两个业务场景：点击星号，列表无感知刷新；两个组件在代码中离得很远，怎样交互？","categories":[{"name":"React","slug":"React","permalink":"https://scarlett9354.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://scarlett9354.github.io/tags/React/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://scarlett9354.github.io/tags/TypeScript/"},{"name":"React Hook","slug":"React-Hook","permalink":"https://scarlett9354.github.io/tags/React-Hook/"}]},{"title":"React17+React Hook+TS4 最佳实践，仿 Jira 企业级项目(一)","slug":"React17-ReactHook-TS4最佳实践，仿Jira企业级项目-一","date":"2021-07-27T02:10:59.000Z","updated":"2021-11-10T07:47:28.551Z","comments":true,"path":"2021/07/27/React17-ReactHook-TS4最佳实践，仿Jira企业级项目-一/","link":"","permalink":"https://scarlett9354.github.io/2021/07/27/React17-ReactHook-TS4%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%EF%BC%8C%E4%BB%BFJira%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%A1%B9%E7%9B%AE-%E4%B8%80/","excerpt":"","text":"第1章 课程介绍(了解本课程必看)1-1 课程导学技术栈： React、React Hooks、TS、React Query、React/Router、Redux tookit、CSS in JS React17 JSX、State、事件处理等必备知识 状态提升、组件解耦、组合 Refs转发 高阶组件 Render Props 错误边界(Error Boundaries) React Hook useState、useRef等自带Hook详解 自定义Hook：异步操作、状态管理、debounce、路由、增删改查等 发挥Hook的最大威力 TypeScript4 第四大受欢迎编程语言 可以不用但绝不能不会 其他 Hook + Context / Redux Toolkit管理客户端全局状态 React Query管理服务端全局状态 服务端全局状态主要指从api返回的全局数据 性能优化、性能监控、性能报告 自动化测试：单元测试、集成测试、e2e测试 CSS in JS、Grid、Flexbox React Router 6 第2章 项目起航：项目初始化与配置2-1 用 Create React App 初始化项目 命令：$ npx create-react-app jira --template typescript 项目介绍： src是源代码文件夹，参与打包工具打包。 index.tsx是入口文件，负责一些准备工作； App.tsx描述app本身； react-app-env.d.ts 引入一些预先定义好的typescript的类点； reportWebVitals.ts 用来做埋点上报； setupTests.ts 用来配置单元测试，本项目将使用testing-library测试库。 public文件夹不参与打包，包含的都是静态文件，这里的字体、图片等资源都是为index.html服务的，src会被打包成bundle.js，也会被引入到html中。 在src源代码中使用到的图片、字体都需要在src下，像引入模块似的引入即可，而不是放到public里。 manifest.json 用来做PWA，配置pwa的加载情况，包括icon、start_url、主题色等； robots.txt 用来配置想让搜索引擎怎么对待我们的项目，比如Disallow的功能就是，当搜索引擎抓到我们的页面时，我们不允许它访问什么。 .gitignore 让git仓库忽略的文件 package.json 是每个前端项目的入口文件 tsconfig.json 用来配置typescript 如配置&quot;baseUrl&quot;: &quot;./src&quot;绝对路径就会去src下寻找 package-lock.json用来精确锁定版本号，在package.json中^是能限定到倒数第二或第一位，并不能精确锁定。 启动：$ npm start 2-2 配置 eslint、 prettier 和 commitlint 规范工程 安装prettier：$ npm install --save-dev --save-exact prettier 添加配置文件：$ echo &#123;&#125;&gt; .prettierrc.json 在根目录手动创建.prettierignore文件，里面配置的是不需要格式化的文件 借助Pre-commit Hook自动格式化，运行安装$ npx mrm lint-staged，可以在package.json中看到安装了husky和lint-staged。 husky是方便地管理git hook的工具，在pre-commit阶段运行lint-staged，即运行prettier --write格式化命令，补充扩展名： 123&quot;lint-staged&quot;: &#123; &quot;*.&#123;js,css,md,ts,tsx&#125;&quot;: &quot;prettier --write&quot;&#125; creat-react-app自带了eslint，因为prettier和eslint会有冲突，所以需要安装$ npm i eslint-config-prettier -D，安装完成后，在package.json中的eslint后补充prettier，即用prettier的规则覆盖一部分原来的规则： 1234567&quot;eslintConfig&quot;: &#123; &quot;extends&quot;: [ &quot;react-app&quot;, &quot;react-app/jest&quot;, &quot;prettier&quot; ]&#125;, 在vscode的设置中勾选： 2-3 对比常见 Mock 方案 配置 JSON SERVER 在本地安装node服务器 代表：json-server 优点： 配置简单，json-server甚至可以0代码30s启动一个REST API Server 自定义程度高，一切尽在掌握中 增删改查真实模拟 缺点：与接口管理工具swagger等相比，无法随着后端API的修改而自动修改 30s内安装： 全局安装$ npm i json-server -g 在项目根目录下创建db.json文件： 123&#123; &quot;users&quot;: []&#125; 启动：$ json-server --watch db.json 验证：将http://localhost:3000/users粘到postman中，可以任意尝试 安装到项目中： $ npm i json-server -D 在根目录创建文件夹__json_server_mock__，前面的两个_是为了告诉别人，这个文件夹下的代码与本项目无关，只是作为辅助存在的。 把刚才的db.json挪到这下面。 在package.json中添加启动命令，并运行$ npm run json-server 123&quot;scripts&quot;: &#123; &quot;json-server&quot;: &quot;json-server __json_server_mock__/db.json --watch --port 3001&quot;&#125;, REST API 是一种api的设计风格，一句话总结：URI代表资源/对象，METHOD代表行为。 GET /tickets // 列表 GET /tickets/12 // 详情 POST /tickets // 增加 PUT /tickets/12 // 替换 PATCH /tickets/12 // 修改 DELETE /tickets/12 // 删除 第3章 React 与 Hook 应用：实现项目列表3-1 用 JSX 列表渲染开发工程列表页面 需求：input表单+select下拉框，输入或筛选时，下面的列表中展示相应的内容。 编写search-panel.jsx： 写一个react组件要先找它的状态，这里有项目名和负责人的id，将这两个合二为一定义，并添加input和select： 1234567891011121314151617181920const [param, setParam] = useState(&#123; name: &#x27;&#x27;, personId: &#x27;&#x27;&#125;)return &lt;form&gt; &lt;div&gt; &lt;input type=&quot;text&quot; value=&#123;param.name&#125; onChange=&#123;evt =&gt; setParam(&#123; ...param, name: evt.target.value &#125;)&#125; /&gt; &lt;select value=&#123;param.personId&#125; onChange=&#123;evt =&gt; setParam(&#123; ...param, personId: evt.target.value &#125;)&#125;&gt; &lt;option value=&quot;&quot;&gt;负责人&lt;/option&gt; &#123;/* 负责人列表见下方 */&#125; &lt;/select&gt; &lt;/div&gt;&lt;/form&gt; 还需要另外一个状态，即负责人列表： 12345const [users, setUsers] = useState([])&#123;/* 多余的部分已省略，见上方 */&#125;&#123; users.map(user =&gt; &lt;option value=&#123;user.personId&#125;&gt;&#123;user.name&#125;&lt;/option&gt;)&#125; 当参数改变时，发起请求： 12345678910const [list, setList] = useState([])useEffect(() =&gt; &#123; fetch(&#x27;&#x27;).then(async response =&gt; &#123; if (response.ok) &#123; // 说明请求成功了，还得添加一个table列表的state↑ setList(await response.json()) &#125; &#125;)&#125;, [param]) 这里涉及到“状态提升”： 因为参数param在这个子组件里，我们就把请求工程列表list的请求也写在了这个子组件里，但是list子组件怎么去渲染这个工程列表呢？这就要做状态提升了。 3-2 用状态提升分享组件状态，完成工程列表页面 将search-panel中的跟list组件相关的代码提到父组件index.jsx中： index.jsx: 123456789101112131415161718192021222324252627282930313233343536import React, &#123; useEffect, useState &#125; from &quot;react&quot;import &#123; List &#125; from &quot;./list&quot;import &#123; SearchPanel &#125; from &quot;./search-panel&quot;export const ProjectListScreen = () =&gt; &#123; const [param, setParam] = useState(&#123; name: &#x27;&#x27;, personId: &#x27;&#x27; &#125;) const [users, setUsers] = useState([]) const [list, setList] = useState([]) // 传入[]表示只在页面初始化时触发一次 useEffect(() =&gt; &#123; fetch(&#x27;&#x27;).then(async response =&gt; &#123; if (response.ok) &#123; // 说明请求成功了，还得添加一个table列表的state setUsers(await response.json()) &#125; &#125;) &#125;, []) useEffect(() =&gt; &#123; fetch(&#x27;&#x27;).then(async response =&gt; &#123; if (response.ok) &#123; // 说明请求成功了，还得添加一个table列表的state setList(await response.json()) &#125; &#125;) &#125;, [param]) return &lt;div&gt; &lt;SearchPanel users=&#123;users&#125; param=&#123;param&#125; setParam=&#123;setParam&#125;&gt;&lt;/SearchPanel&gt; &lt;List list=&#123;list&#125; users=&#123;users&#125;&gt;&lt;/List&gt; &lt;/div&gt;&#125; search-panel.jsx： 123456789101112131415161718192021import React, &#123; useState &#125; from &quot;react&quot;export const SearchPanel = (&#123; users, param, setParam &#125;) =&gt; &#123; return &lt;form&gt; &lt;div&gt; &lt;input type=&quot;text&quot; value=&#123;param.name&#125; onChange=&#123;evt =&gt; setParam(&#123; ...param, name: evt.target.value &#125;)&#125; /&gt; &lt;select value=&#123;param.personId&#125; onChange=&#123;evt =&gt; setParam(&#123; ...param, personId: evt.target.value &#125;)&#125;&gt; &lt;option value=&quot;&quot;&gt;负责人&lt;/option&gt; &#123; users.map(user =&gt; &lt;option value=&#123;user.personId&#125;&gt;&#123;user.name&#125;&lt;/option&gt;) &#125; &lt;/select&gt; &lt;/div&gt; &lt;/form&gt;&#125; list.jsx： 123456789101112131415161718192021import React from &quot;react&quot;export const List = (&#123; list, users &#125;) =&gt; &#123; return &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;负责人&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123; list.map(project =&gt; &lt;tr&gt; &lt;td&gt;&#123;project.name&#125;&lt;/td&gt; &#123;/* 可能为undefined.name */&#125; &lt;td&gt;&#123;users.find(user =&gt; user.id === project.personId)?.name || &#x27;未知&#x27;&#125;&lt;/td&gt; &lt;/tr&gt;) &#125; &lt;/tbody&gt; &lt;/table&gt;&#125; 配置请求地址： 在根目录新建.env和.env.development文件，其中定义变量REACT_APP_API_URL=http://localhost:3001，在index.jsx中使用如下： 在运行$ npm start时，webpack会读取.env.devlopment中的变量，运行$ npm run build时，读取.env中的变量。 12345678910111213141516const apiUrl = process.env.REACT_APP_API_URLexport const ProjectListScreen = () =&gt; &#123; ... useEffect(() =&gt; &#123; fetch(`$&#123;apiUrl&#125;/users`).then(async response =&gt; &#123; ... &#125;) &#125;, []) useEffect(() =&gt; &#123; fetch(`$&#123;apiUrl&#125;/peojects`).then(async response =&gt; &#123; ... &#125;) &#125;, [param]) ...&#125; 向db.json中模拟数据，并运行$ npm run json-server 暂时将ProjectListScreen放到App.tsx中运行看下页面： 123456789101112import React from &#x27;react&#x27;;import &#x27;./App.css&#x27;;import &#123; ProjectListScreen &#125; from &#x27;screens/project-list&#x27;;function App() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;ProjectListScreen /&gt; &lt;/div&gt; );&#125;export default App; 优化以上代码： 主要两点：1. projects接口参数中值为空时，应当将其裁剪掉；2. 参数特别多时，不可能挨个罗列，可以借助qs工具，安装$ npm i qs -S。 index.jsx: 12345678910111213...import &#123; cleanObject &#125; from &quot;utils&quot;import * as qs from &quot;qs&quot;export const ProjectListScreen = () =&gt; &#123; ... useEffect(() =&gt; &#123; fetch(`$&#123;apiUrl&#125;/projects?$&#123;qs.stringify(cleanObject(param))&#125;`).then(async response =&gt; &#123; ... &#125;) &#125;, [param]) ...&#125; 新建src/utils/index.js： 12345678910111213// 排除value为0的情况export const isFalsy = (value) =&gt; value === 0 ? false : !valueexport const cleanObject = (obj) =&gt; &#123; const result = &#123; ...obj &#125; Object.keys(result).forEach(key =&gt; &#123; const value = result[key] if (isFalsy(value)) &#123; delete result[key] &#125; &#125;) return result&#125; 3-3 学习自定义Hook - 用useDebounce减少工程搜索请求频率用Custom Hook提取并复用组件代码，即DRY原则don’t repeat yourself。 第一个自定义Hooke - useMount，类似class中的componentDidMount 在src/utils/index.js中编写： 12345export const useMount = (callback) =&gt; &#123; useEffect(() =&gt; &#123; callback() &#125;, [])&#125; 改写index.jsx中的相应代码: 12345678910import &#123; useMount &#125; from &quot;utils&quot;export const ProjectListScreen = () =&gt; &#123; ... useMount(() =&gt; &#123; fetch(`$&#123;apiUrl&#125;/users`).then(async response =&gt; &#123; ... &#125;) &#125;) ...&#125; 另一个自定义Hook - useDebounce，常用来监听快速的事件，如鼠标事件、改变窗口的事件、keyboard事件。 12345678910111213141516// 普通的debounce函数：const debounce = (func, delay) =&gt; &#123; let timeout return () =&gt; &#123; if (timeout) &#123; clearTimeout(timeout) &#125; timeout = setTimeout(() =&gt; &#123; func() &#125;, delay) &#125;&#125;const log = debounce(() =&gt; console.log(&#x27;call&#x27;), 5000)log()log()log() 以上的运行结果是，过5s后只打印出一个’call’。观察本函数，里面先定义了一个timeout，再return一个函数，里面这个函数中又使用到了外层的timeout，这涉及到闭包，把这个函数return后，这个timeout的引用依然会被debounce函数保留住，下面定义的log就是return出来的那个函数。内部函数里，如果timeout有值，就把定时器取消掉，第一次运行时，timeout是undefined，会走下面的setTimeout。 原理讲解： 0s ———–&gt; 1s ———–&gt; 2s ————&gt; … 首先必须理解的是：这三个log函数都是同步操作，所以它们都是在0-1s这个时间段内瞬间完成的； log()#1 // timeout#1 log()#2 // 发现timeout#1! 取消之，然后设置timeout#2 log()#3 // 发现timeout#2! 取消之，然后设置timeout#3 ​ // 所以，log()#3 结束后，就只剩timeout#3在独自等待了 1234567891011// 自定义debounce hookexport const useDebounce = (value, delay) =&gt; &#123; const [debouncedValue, setDebouncedValue] = useState(value) useEffect(() =&gt; &#123; // 每次在value变化以后，设置一个定时器 const timeout = setTimeout(() =&gt; setDebouncedValue(value), delay) // 每次在上一个useEffect处理完以后再运行 return () =&gt; clearTimeout(timeout) &#125;, [value, delay]) return debouncedValue&#125; 在index.jsx中使用： 12345678910111213...import &#123; useDebounce &#125; from &quot;utils&quot;export const ProjectListScreen = () =&gt; &#123; ... const debouncedParam = useDebounce(param, 200) useEffect(() =&gt; &#123; fetch(`$&#123;apiUrl&#125;/projects?$&#123;qs.stringify(cleanObject(debouncedParam))&#125;`).then(async response =&gt; &#123; ... &#125;) &#125;, [debouncedParam]) ...&#125; 如果这个函数里必须要用到其他的hook，就可以把它封装成自定义hook，否则就做普通函数即可。 第4章 TS 应用：JS神助攻 - 强类型4-1 为什么我们需要TS - 真实场景学习 TS 的必要性 将.jsx后缀直接改成.tsx，将.js后缀直接改成.js即可。 .d.ts文件是纯粹的说明书文件，只是用来规定类型。 先解决search-panel.tsx的报错，其实就是根据ts错误提示添加对应的类型，如下： 12345678910111213141516171819202122import React from &quot;react&quot;interface User &#123; id: string name: string email: string title: string organization: string&#125;interface SearchPanelProps &#123; users: User[] param: &#123; name: string personId: string &#125; setParam: (param: SearchPanelProps[&#x27;param&#x27;]) =&gt; void&#125;export const SearchPanel = (&#123; users, param, setParam &#125;: SearchPanelProps) =&gt; &#123; return &lt;form&gt; ... &lt;/form&gt;&#125; 4-2 将项目列表页面JS改造成TS，增强类型，减少Bug 解决像qs这样的非ts的库报错问题，直接安装个ts的补丁$ npm i --save-dev @types/qs，可以在node_modules/@types/qs中看到它的类型定义文件index.d.ts。 解决list.tsx的报错，也是根据ts错误提示添加对应的类型，如下： 1234567891011121314151617...import &#123; User &#125; from &#x27;screens/project-list/search-panel&#x27;interface Project &#123; id: string name: string personId: string pin: Boolean organization: string&#125;interface ListProps &#123; list: Project[] users: User[]&#125;export const List = (&#123; list, users &#125;: ListProps) =&gt; &#123; return ...&#125; 这个User要从search-panel.tsx中export出来，就不用重复定义了，即export interface User 解决index.ts的报错： 12345678910111213141516171819...// 排除value为0的情况export const isFalsy = (value: any) =&gt; value === 0 ? false : !valueexport const cleanObject = (obj: object) =&gt; &#123; ...&#125;// Custom Hookexport const useMount = (callback: () =&gt; void) =&gt; &#123; useEffect(() =&gt; &#123; callback() // eslint-disable-next-line react-hooks/exhaustive-deps &#125;, [])&#125;// ?: 表示可有可无export const useDebounce = (value: any, delay?: number) =&gt; &#123; ...&#125; 4-3 TS知识梳理、总结与提高详见TypeScript 基本知识梳理 any类型在ts中是有害的，轻易不要用，可以用unknown类型代替，index.ts中修改如下： 1234567export const isFalsy = (value: unknown) =&gt; value === 0 ? false : !value// 我们希望的结果是最终返回的debouncedValue和传进来的value的类型相同，这就需要用泛型来规范类型export const useDebounce = (value: unknown, delay?: number) =&gt; &#123; const [debouncedValue, setDebouncedValue] = useState(value) ... return debouncedValue&#125; 上面修改后，index.tsx中的debouncedParam却出现了报错： 1234567const debouncedParam = useDebounce(param, 200)useEffect(() =&gt; &#123; // 报错：类型“unknown”的参数不能赋给类型“object”的参数 fetch(`$&#123;apiUrl&#125;/projects?$&#123;qs.stringify(cleanObject(debouncedParam))&#125;`).then(async response =&gt; &#123; ... &#125;)&#125;, [debouncedParam]) 这是因为unknown类型可以给它赋任何值，但是不能将它赋给其他变量或读取任何方法，如： 123456let value:unknownvalue = undefinedvalue = []let valueNumber = 1valueNumber = value // 报错：不能将类型“unknown”分配给类型“number”value.a // 报错 4-4 学习泛型，用泛型增强useDebounce类型灵活性 其实useState也使用了泛型，因为它在定义时，无法知道将会传入什么类型，但它又想让返回的tuple类型和传入的保持一致，所以必须用泛型。 泛型的大概实现： 先定义一个泛型的占位符即用尖括号框住类型&lt;S&gt;，里面的参数使用这个S类型，返回值也用这个S类型，这样这三个S类型就绑定到了一起。 1function useState&lt;S&gt;(initialState: S | (() =&gt; S)): [S, Dispatch&lt;SetStateAction&lt;S&gt;&gt;] 改写index.ts中的自定义hook useDebounce： 123456// 注意箭头函数泛型的占位符位置export const useDebounce = &lt;V&gt;(value: V, delay?: number) =&gt; &#123; const [debouncedValue, setDebouncedValue] = useState(value) ... return debouncedValue&#125; 在index.tsx中使用它时，就能看到debouncedParam类型和传入的param一致了： 1234567891011const [param, setParam] = useState(&#123; name: &#x27;&#x27;, personId: &#x27;&#x27;&#125;)// 类型为&#123;name:string; personId:string;&#125;const debouncedParam = useDebounce(param, 200)useEffect(() =&gt; &#123; fetch(`$&#123;apiUrl&#125;/projects?$&#123;qs.stringify(cleanObject(debouncedParam))&#125;`).then(async response =&gt; &#123; ... &#125;)&#125;, [debouncedParam]) 4-5 作业 - 用 Hook + TS + TS泛型实现useArray 新建try-use-array.tsx，调用自定义hook： 12345678910111213141516171819202122232425262728293031323334import React from &quot;react&quot;;import &#123; useArray, useMount &#125; from &quot;utils&quot;export const TsReactTest = () =&gt; &#123; const persons: &#123; name: string; age: number &#125;[] = [ &#123; name: &#x27;jack&#x27;, age: 25 &#125;, &#123; name: &#x27;ma&#x27;, age: 22 &#125; ] const &#123; value, clear, removeIndex, add &#125; = useArray(persons) useMount(() =&gt; &#123; // 期待这里报错 // console.log(value.notExist) // add(&#123; name: &quot;david&quot; &#125;) // removeIndex(&quot;123&quot;) &#125;) return ( &lt;div&gt; &#123;/* 点击以后增加john */&#125; &lt;button onClick=&#123;() =&gt; add(&#123; name: &#x27;john&#x27;, age: 22 &#125;)&#125;&gt;add john&lt;/button&gt; &#123;/* 点击以后删除第一项 */&#125; &lt;button onClick=&#123;() =&gt; removeIndex(0)&#125;&gt;remove 0&lt;/button&gt; &#123;/* 点击以后清空列表 */&#125; &lt;button style=&#123;&#123; marginBottom: &#x27;50px&#x27; &#125;&#125; onClick=&#123;() =&gt; clear()&#125;&gt;clear&lt;/button&gt; &#123;value.map((person: &#123; age: number; name: string &#125;, index: number) =&gt; ( &lt;div key=&#123;index&#125; style=&#123;&#123; marginBottom: &#x27;30px&#x27; &#125;&#125;&gt; &lt;span style=&#123;&#123; color: &#x27;red&#x27; &#125;&#125;&gt;&#123;index&#125;&lt;/span&gt; &lt;span&gt;&#123;person.name&#125;&lt;/span&gt; &lt;span&gt;&#123;person.age&#125;&lt;/span&gt; &lt;/div&gt; ))&#125; &lt;/div&gt; )&#125; 在utils/index.ts中定义： 12345678910111213export const useArray = &lt;T&gt;(initialArray: T[]) =&gt; &#123; const [value, setValue] = useState(initialArray) return &#123; value, add: (item: T) =&gt; setValue([...value, item]), clear: () =&gt; setValue([]), removeIndex: (index: number) =&gt; &#123; const copy = [...value] copy.splice(index, 1) setValue(copy) &#125; &#125;&#125; 第5章 JWT、用户认证与异步请求5-1 用React表单、TS的类型继承和鸭子类型实现登录表单 用extends实现类型继承，如果需要的类型是个低级，传入的确实更高级的类型，ts不会报错，反之就会，举例说明： 1234567891011interface Base &#123; id: number&#125;interface Advance extends Base &#123; name: string&#125;const test = (p: Base) =&gt; &#123;&#125;const a: Advance = &#123; id: 1, name: &#x27;jack&#x27; &#125;// b的类型如果是Advance，因为Advance继承自Base，所以它必须要包含Base的必需类型id和Advance的必需类型name才可// const b: Advance = &#123; name: &#x27;ma&#x27; &#125;test(a) ts是鸭子类型(duck typing)，即面向接口编程，而不是面向对象编程。 比如上例，把常量a的类型Advance删掉，因为它的值含有id和name，所以即使不显示地给它定义类型，在使用它时依然不会报错。也就是说，test方法并不在乎传入的参数p是Base还是Advance类型，只有这个参数本身符合那个接口定义的类型就行。 123456789interface Base &#123; id: number&#125;interface Advance extends Base &#123; name: string&#125;const test = (p: Base) =&gt; &#123;&#125;const a = &#123; id: 1, name: &#x27;jack&#x27; &#125;test(a) 添加登录逻辑： 新建src/screens/login/index.tsx，并将它引入到App.tsx中： 1234567891011121314151617181920212223242526272829303132333435363738import React, &#123; FormEvent &#125; from &quot;react&quot;;const apiUrl = process.env.REACT_APP_API_URLexport const LoginScreen = () =&gt; &#123; const login = (param: &#123; username: string; password: string &#125;) =&gt; &#123; fetch(`$&#123;apiUrl&#125;/login`, &#123; method: &#x27;POST&#x27;, headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27; &#125;, body: JSON.stringify(param) &#125;).then(async response =&gt; &#123; if (response.ok) &#123; &#125; &#125;) &#125; // HtmlFormElement extends Element const handleSubmit = (event: FormEvent&lt;HTMLFormElement&gt;) =&gt; &#123; event.preventDefault() // 此处如果不断言成HtmlInputElement，就会报错：“Element”上不存在属性“value” const username = (event.currentTarget.elements[0] as HTMLInputElement).value const password = (event.currentTarget.elements[1] as HTMLInputElement).value login(&#123; username, password &#125;) &#125; return &lt;form onSubmit=&#123;handleSubmit&#125;&gt; &lt;div&gt; &lt;label htmlFor=&quot;username&quot;&gt;用户名&lt;/label&gt; &lt;input type=&quot;text&quot; id=&#123;&#x27;username&#x27;&#125; /&gt; &lt;/div&gt; &lt;div&gt; &lt;label htmlFor=&quot;password&quot;&gt;密码&lt;/label&gt; &lt;input type=&quot;password&quot; id=&#123;&#x27;password&#x27;&#125; /&gt; &lt;/div&gt; &lt;button type=&#123;&#x27;submit&#x27;&#125;&gt;登录&lt;/button&gt; &lt;/form&gt;&#125; 以上登录操作报404，是因为我们在json-server中并没有配置这个接口。 json-server的限制是只能模拟标准的restful api，需要通过json-server的middleware来实现用json-server模拟自定义的api。 新建__json_server_mock__/middleware.js： 1234567891011121314module.exports = (req, res, next) =&gt; &#123; if (req.method === &#x27;POST&#x27; &amp;&amp; req.path === &#x27;/login&#x27;) &#123; if (req.body.username === &#x27;jack&#x27; &amp;&amp; req.body.password === &#x27;123456&#x27;) &#123; return res.status(200).json(&#123; user: &#123; token: &#x27;123&#x27; &#125; &#125;) &#125; else &#123; return res.status(400).json(&#123; message: &#x27;用户名或者密码错误&#x27; &#125;) &#125; &#125; next()&#125; 并将其注入到package.json中的json-server中： 123&quot;scripts&quot;: &#123; &quot;json-server&quot;: &quot;json-server __json_server_mock__/db.json --watch --port 3001 --middlewares ./__json_server_mock__/middleware.js&quot;&#125;, 运行$ npm run json-server重启服务，并使用jack/123456登录即可。 5-2 连接真实服务端 - 专属开发者⼯具介绍与安装 详见 https://www.npmjs.com/package/jira-dev-tool，运行$ npx imooc-jira-tool进行安装，windows由于不能识别yarn命令，还要手动安装$ npm i jira-dev-tool -S 在src/index.tsx中引入并使用： 12345678910import &#123; loadDevTools &#125; from &quot;jira-dev-tool&quot;;loadDevTools(() =&gt; &#123; ReactDOM.render( &lt;React.StrictMode&gt; &lt;App /&gt; &lt;/React.StrictMode&gt;, document.getElementById(&#x27;root&#x27;) );&#125;) 重启项目，调用接口发现此时未启动json-server，状态码也报400 Bad Request (from service worker)而非404了，并且浏览器右下角多出一个齿轮，可以手动控制 HTTP请求的时间、失败概率、失败规则。 5-3 JWT原理与auth-provider实现 JWT全称JSON Web Tokens，一切是以token为核心。 将login/index.tsx中的登录相关改成注册，使用jira/jira注册个新用户： 1234567891011121314151617181920export const LoginScreen = () =&gt; &#123; const login = (param: &#123; username: string; password: string &#125;) =&gt; &#123; fetch(`$&#123;apiUrl&#125;/register`, &#123; ... &#125;).then(async response =&gt; &#123; ... &#125;) &#125; // HtmlFormElement extends Element const handleSubmit = (event: FormEvent&lt;HTMLFormElement&gt;) =&gt; &#123; ... login(&#123; username, password &#125;) &#125; return &lt;form onSubmit=&#123;handleSubmit&#125;&gt; ... &lt;button type=&#123;&#x27;submit&#x27;&#125;&gt;注册&lt;/button&gt; &lt;/form&gt;&#125; 注册成功，返回结果如下： 1&#123;&quot;user&quot;:&#123;&quot;id&quot;:2087569429,&quot;name&quot;:&quot;jira&quot;,&quot;token&quot;:&quot;MjA4NzU2OTQyOQ==&quot;&#125;&#125; 新建src/auth-provider.ts，注意在真实环境中，如果使用firebase这种第三方auth服务的话，本文件不需要开发者开发： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import &#123; User &#125; from &quot;screens/project-list/search-panel&quot;const localStorageKey = &#x27;__auth_provider_token__&#x27;export const getToken = () =&gt; window.localStorage.getItem(localStorageKey)export const handleUserResponse = (&#123; user &#125;: &#123; user: User &#125;) =&gt; &#123; window.localStorage.setItem(localStorageKey, user.token || &#x27;&#x27;) return user&#125;const apiUrl = process.env.REACT_APP_API_URLexport const login = (data: &#123; username: string; password: string &#125;) =&gt; &#123; return fetch(`$&#123;apiUrl&#125;/login`, &#123; method: &#x27;POST&#x27;, headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27; &#125;, body: JSON.stringify(data) &#125;).then(async response =&gt; &#123; if (response.ok) &#123; return handleUserResponse(await response.json()) &#125; else &#123; // 相当于throw new Error return Promise.reject(data) &#125; &#125;)&#125;export const register = (data: &#123; username: string; password: string &#125;) =&gt; &#123; return fetch(`$&#123;apiUrl&#125;/register`, &#123; method: &#x27;POST&#x27;, headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27; &#125;, body: JSON.stringify(data) &#125;).then(async response =&gt; &#123; if (response.ok) &#123; return handleUserResponse(await response.json()) &#125; else &#123; // 相当于throw new Error return Promise.reject(data) &#125; &#125;)&#125;export const logout = async() =&gt; window.localStorage.removeItem(localStorageKey) 5-4 用useContext存储全局用户信息 一般涉及到地区偏好、UI主题、登录注册系统的token和用户信息等(即通常所说的全局状态)都需要用到context，现在不妨试着使用context代替原来的redux。 首先，新建文件src/context/auth-context.tsx： 123456789101112131415161718192021222324252627282930313233343536import React, &#123; ReactNode, useState &#125; from &quot;react&quot;import * as auth from &#x27;auth-provider&#x27;import &#123; User &#125; from &quot;screens/project-list/search-panel&quot;export interface AuthForm &#123; username: string password: string&#125;const AuthContext = React.createContext&lt;&#123; user: User | null register: (form: AuthForm) =&gt; Promise&lt;void&gt; login: (form: AuthForm) =&gt; Promise&lt;void&gt; logout: () =&gt; Promise&lt;void&gt;&#125; | undefined&gt;(undefined)// 主要用户devtool中，项目实际应用中没有任何作用AuthContext.displayName = &#x27;AuthContext&#x27;export const AuthProvider = (&#123; children &#125;: &#123; children: ReactNode &#125;) =&gt; &#123; const [user, setUser] = useState&lt;User | null&gt;(null) // const login = (form: AuthForm) =&gt; auth.login(form).then(user =&gt; setUser(user)) // const register = (form: AuthForm) =&gt; auth.register(form).then(user =&gt; setUser(user)) // 消参：point free const login = (form: AuthForm) =&gt; auth.login(form).then(setUser) const register = (form: AuthForm) =&gt; auth.register(form).then(setUser) const logout = () =&gt; auth.logout().then(() =&gt; setUser(null)) return &lt;AuthContext.Provider children=&#123;children&#125; value=&#123;&#123; user, login, register, logout &#125;&#125; /&gt;&#125;export const useAuth = () =&gt; &#123; const context = React.useContext(AuthContext) if (!context) &#123; throw new Error(&#x27;useAuth必须在AuthProvider中使用&#x27;) &#125; return context&#125; 然后去使用上面定义的AuthProvider： 先填好入口文件src/context/index.tsx: 12345678import &#123; ReactNode &#125; from &quot;react&quot;;import &#123; AuthProvider &#125; from &quot;./auth-context&quot;;export const AppProviders = (&#123; children &#125;: &#123; children: ReactNode &#125;) =&gt; &#123; return &lt;AuthProvider&gt; &#123;children&#125; &lt;/AuthProvider&gt;&#125; 未来所有app级别的provider都会上面的入口文件中添加，并在整个项目的入口文件src/index.tsx中把App组件包裹住： 123456789101112import &#123; AppProviders &#125; from &#x27;context&#x27;;loadDevTools(() =&gt; &#123; ReactDOM.render( &lt;React.StrictMode&gt; &lt;AppProviders&gt; &lt;App /&gt; &lt;/AppProviders&gt; &lt;/React.StrictMode&gt;, document.getElementById(&#x27;root&#x27;) );&#125;) 最后去页面组件src/screens/login/index.tsx中使用上面最主要的自定义hook useAuth： 12345678910111213141516171819202122import &#123; useAuth &#125; from &quot;context/auth-context&quot;;import React, &#123; FormEvent &#125; from &quot;react&quot;;export const LoginScreen = () =&gt; &#123; const &#123; login, user &#125; = useAuth() // HtmlFormElement extends Element const handleSubmit = (event: FormEvent&lt;HTMLFormElement&gt;) =&gt; &#123; ... login(&#123; username, password &#125;) &#125; return &lt;form onSubmit=&#123;handleSubmit&#125;&gt; &#123; user ? &lt;div&gt; 登录成功，用户名：&#123;user?.name&#125; token: &#123;user.token&#125; &lt;/div&gt; : null &#125; ... &lt;/form&gt;&#125; 5-5 用useAuth切换登录与非登录状态整合之前的代码，将我们的工程分成两部分：登录状态的app和非登录状态的app 非登录状态： 新建文件夹src/unauthenticated-app，在下面新建login.tsx、register.tsx，将screens/login/index.tsx中代码剪切到login.tsx和register.tsx中各一份，并将register中代码对应修改成注册相关。 在这个文件夹下新建入口文件index.tsx： 1234567891011121314import React, &#123; useState &#125; from &quot;react&quot;import &#123; LoginScreen &#125; from &quot;./login&quot;import &#123; RegisterScreen &#125; from &quot;./register&quot;export const UnauthenticatedApp = () =&gt; &#123; // 默认登录页 const [isRegister, setIsRegister] = useState(false) return &lt;div&gt; &#123; isRegister ? &lt;RegisterScreen /&gt; : &lt;LoginScreen /&gt; &#125; &lt;button onClick=&#123;() =&gt; setIsRegister(!isRegister)&#125;&gt;切换到&#123;isRegister ? &#x27;登录&#x27; : &#x27;注册&#x27;&#125;&lt;/button&gt; &lt;/div&gt;&#125; 登录状态： 新建文件src/authenticated-app.tsx： 12345678import React from &quot;react&quot;;import &#123; ProjectListScreen &#125; from &quot;screens/project-list&quot;;export const AuthenticatedApp = () =&gt; &#123; return &lt;div&gt; &lt;ProjectListScreen /&gt; &lt;/div&gt;&#125; 修改App.tsx： 12345678910111213141516import React from &#x27;react&#x27;;import &#123; useAuth &#125; from &#x27;context/auth-context&#x27;;import &#123; AuthenticatedApp &#125; from &#x27;authenticated-app&#x27;;import &#123; UnauthenticatedApp &#125; from &#x27;unauthenticated-app&#x27;;import &#x27;./App.css&#x27;;function App() &#123; const &#123; user &#125; = useAuth() return ( &lt;div className=&quot;App&quot;&gt; &#123;user ? &lt;AuthenticatedApp /&gt; : &lt;UnauthenticatedApp /&gt;&#125; &lt;/div&gt; );&#125;export default App; 在authenticated-app.tsx中再添加登出逻辑： 12345678910...import &#123; useAuth &#125; from &quot;context/auth-context&quot;;export const AuthenticatedApp = () =&gt; &#123; const &#123; logout &#125; = useAuth() return &lt;div&gt; &lt;button onClick=&#123;logout&#125;&gt;登出&lt;/button&gt; &lt;ProjectListScreen /&gt; &lt;/div&gt;&#125; 以上都准备完毕，快去页面进行注册/登录吧~ 5-6 用fetch抽象通用HTTP请求方法，增强通用性新建src/utils/http.ts： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import qs from &#x27;qs&#x27;import * as auth from &#x27;auth-provider&#x27;const apiUrl = process.env.REACT_APP_API_URL/** * @param endpoint 接口 * @param param1 fetch的一些配置 * @returns */interface Config extends RequestInit &#123; token?: string data?: object&#125;export const http = async (endpoint: string, &#123; data, token, headers, ...customConfig &#125;: Config) =&gt; &#123; const config = &#123; method: &#x27;GET&#x27;, headers: &#123; Authorization: token ? `Bearer $&#123;token&#125;` : &#x27;&#x27;, &#x27;Content-Type&#x27;: data ? &#x27;application/json&#x27; : &#x27;&#x27; &#125;, ...customConfig &#125; // get请求中的参数直接带到url里，post、patch、delete直接放到body中 if (config.method.toUpperCase() === &#x27;GET&#x27;) &#123; endpoint += `?$&#123;qs.stringify(data)&#125;` &#125; else &#123; config.body = JSON.stringify(data || &#123;&#125;) &#125; // 如果不记得像fetch这样的api定义的参数，直接鼠标+ctrl就能看到它的类型定义 return window.fetch(`$&#123;apiUrl&#125;/$&#123;endpoint&#125;`, config).then(async response =&gt; &#123; if (response.status === 401) &#123; // 未登录或者token失效 await auth.logout() window.location.reload() return Promise.reject(&#123; message: &#x27;请重新登录&#x27; &#125;) &#125; const data = await response.json() if (response.ok) &#123; return data &#125; else &#123; // 这里之所以要主动返回reject，是因为在fetch api中服务端返回的异常状态并不能在它的catch中抛出异常，只有断网、网络连接失败时才抛出 // axios和fetch的表现不一样，axios可以直接在返回状态不为2xx时抛出异常 return Promise.reject(data) &#125; &#125;)&#125; 5-7 用useHttp管理JWT和登录状态，保持登录状态优化5-6： 封装自动携带JWT token的方法，因为里面要使用hook，所以也要将这个方法封装成hook： 1234567export const useHttp = () =&gt; &#123; const &#123; user &#125; = useAuth() // [string, Config]类型和上面http的参数类型完全一致，可以复用 - 使用Parameters操作 // return ([endpoint, config]: [string, Config]) =&gt; http(endpoint, &#123; ...config, token: user?.token &#125;) // 注意这里返回的函数参数之所以加个...操作符，是为了传实参时更加方便 return (...[endpoint, config]: Parameters&lt;typeof http&gt;) =&gt; http(endpoint, &#123; ...config, token: user?.token &#125;)&#125; 在src/screens/project-list/index.tsx中使用： 12345678910111213141516171819import React, &#123; useEffect, useState &#125; from &quot;react&quot;import &#123; cleanObject, useDebounce, useMount &#125; from &quot;utils&quot;import &#123; useHttp &#125; from &quot;utils/http&quot;export const ProjectListScreen = () =&gt; &#123; ... const client = useHttp() useMount(() =&gt; &#123; client(&#x27;users&#x27;).then(setUsers) &#125;) const debouncedParam = useDebounce(param, 200) useEffect(() =&gt; &#123; client(&#x27;projects&#x27;, &#123; data: cleanObject(debouncedParam) &#125;).then(setList) &#125;, [debouncedParam]) return ...&#125; 当刷新页面时，又变成登出状态了，是因为初始化定义的user为null，所以我们要重新初始化user，在src/context/auth-context.tsx中： 12345678910111213141516171819...// 从localStorage读取我们存的token，用token获取user信息，并赋给setUserexport const bootstrapUser = async () =&gt; &#123; let user = null const token = auth.getToken() if (token) &#123; const data = await http(&#x27;me&#x27;, &#123; token &#125;) user = data.user &#125; return user&#125;...export const AuthProvider = (&#123; children &#125;: &#123; children: ReactNode &#125;) =&gt; &#123; ... useMount(() =&gt; &#123; bootstrapUser().then(setUser) &#125;) return ...&#125; 5-8 TS的联合类型、Partial和Omit介绍 联合类型 用符号”|”表示 1let myFavoriteNumber: string | number 类型别名 12type FavoriteNumber = string | numberlet roseFavoriteNumber: FavoriteNumber = &#x27;6&#x27; 类型别名在很多情况下可以和interface互换： 12345// interface Person &#123;// name: string// &#125;type Person = &#123; name: string &#125;const xiaoming: Person = &#123; name: &#x27;xiaoming&#x27; &#125; 类型别名和interface的主要区别： 定义联合类型、交叉类型，interface没法代替type interface也没法实现Utility Type，比如前面提到的Parameters，它当时的用法是变量: Parammeters&lt;typeof http&gt; 注意区分： js中的typeof，是在runtime时运行； ts中的typeof，是在静态环境运行的，它的作用是把后面传的变量http的类型提取出来，typeof http整体就代表这个变量的类型，而且必是个函数类型，Parameters后面的泛型就是能读出这个函数类型的参数类型。 综上，Utility Type的作用是用泛型给它传入一个其他类型，然后utility type对这个类型进行某种操作。 常用的类型别名举例： 假如有个固定的类型： 1234type Person = &#123; name: string age: number&#125; 例1：xiaoming只包含类型Person中的部分属性或全都不包含，即把Person中的属性都变成可选的，用Partial&lt;类型&gt;更方便实现。 1const xiaoming: Partial&lt;Person&gt; = &#123; name: &#x27;xiaoming&#x27; &#125; 例2：shenminren只确定有年龄没有名字，就要用Omit&lt;类型1, 类型2&gt;实现了，类型1是要编辑的基本类型，类型2是要删除的属性名。 1const shenmiren: Omit&lt;Person, &#x27;name&#x27;&gt; = &#123; age: 18 &#125; 例3：如果这个shenmiren既没有年龄也没有名字，就得结合联合类型将二者对应的属性都删掉。 1const shenmiren: Omit&lt;Person, &#39;name&#39; | &#39;age&#39;&gt; &#x3D; &#123;&#125; 5-9 TS的Utility Types-Pick、Exclude、Partial和Omit实现 Partical 类型别名起名叫Partial，通过泛型传入一个新的类型，就是要用Partial进行操作的类型，返回的类型由两部分组成，键和值。 键中含有操作符keyof，用法举例type PersonKeys = keyof Person，作用就是从Person中把key都取出来，形成一个联合类型。 1234type Partial&lt;T&gt; = &#123; // 定义的新泛型P要遍历经过keyof处理得到的联合类型 [P in keyof T]?: T[P]&#125; Pick 简单用法：在对象里挑选几个键值来组成新的类型。 1type PersonOnlyName = Pick&lt;Person, &#x27;name&#x27;&gt; Pick的定义： 123type Record&lt;K extends keyof any, T&gt; = &#123; [P in K]: T;&#125;; K extends keyof T意味着K必须是经过keyof处理得到的键的联合类型的子集，所以下面这样会报错： 1type PersonOnlyName = Pick&lt;Person, &#x27;name&#x27; | &#x27;age1&#x27;&gt; Exclude 简单用法：第一个参数类型是总的联合类型，第二个参数类型是要删除掉的类型/属性。 12type PersonKeys = keyof Persontype Age = Exclude&lt;PersonKeys, &#x27;name&#x27;&gt; Exclude的定义： 1type Exclude&lt;T, U&gt; = T extends U ? never : T; 后面的返回值解读： 因为T是个联合类型（比如是name | age），可以将它想象成一个遍历，首先用name判断是否扩展自第二个参数U，案例中是’name’，如果是就返回never类型；再用age判断是否extends name，不是，就把age返回，就形成了一个删除name的效果。 Omit 简单用法举例： 1const shenmiren: Omit&lt;Person, &#x27;name&#x27;&gt; = &#123; age: 18 &#125; Omit的定义： 1type Omit&lt;T, K extends keyof any&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;; 解读上例： 从Person中删除name，keyof T就是name | age，K extends keyof any就是name，所以Exclude&lt;keyof T, K&gt;是从Person的键组成的联合类型中删除name，就只剩了age。 Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;就是从Person中把age挑出来，最后返回一个只剩age的对象。 第6章 CSS 其实很简单 - 用 CSS-in-JS 添加样式6-1 安装与使用 antd 组件库本节主要介绍ant design、emotion （它是用js的方式写css）、布局方面用到flex和grid。 antd： 安装：$ npm i antd -S 在入口文件src/index.tsx中的jira-dev-tool(也用到了antd)后面引入import &#39;antd/dist/antd.less&#39;，之所以引入less文件，是为了自定义antd主题变量。 由于我们用的create-react-app创建的工程，就需要使用craco来覆盖create-react-app的一些默认配置，安装$ npm install @craco/craco --save，安装完成后替换package.json中的命令： 12345678&quot;scripts&quot;: &#123; - &quot;start&quot;: &quot;react-scripts start&quot;, - &quot;build&quot;: &quot;react-scripts build&quot;, - &quot;test&quot;: &quot;react-scripts test&quot;, + &quot;start&quot;: &quot;craco start&quot;, + &quot;build&quot;: &quot;craco build&quot;, + &quot;test&quot;: &quot;craco test&quot;,&#125; 安装$ npm install craco-less --save，并在根文件夹创建文件craco.config.js，添加内容： 1234567891011121314151617const CracoLessPlugin = require(&#x27;craco-less&#x27;);module.exports = &#123; plugins: [ &#123; plugin: CracoLessPlugin, options: &#123; lessLoaderOptions: &#123; lessOptions: &#123; modifyVars: &#123; &#x27;@primary-color&#x27;: &#x27;rgb(0,82,204)&#x27;, &#x27;@font-size-base&#x27;: &#x27;16px&#x27; &#125;, javascriptEnabled: true, &#125;, &#125;, &#125;, &#125;, ],&#125;; 并根据主题变量可以做出相应的修改了，重启项目即可。 使用antd替换项目中原生的元素： src/unauthenticated-app/login.tsx：form-&gt;Form，相应的子元素div-&gt;Form.Item，input-&gt;Input，button-&gt;Button，ant对event也做了相应的处理，最终改成： 123456789101112131415161718192021222324import &#123; useAuth &#125; from &quot;context/auth-context&quot;;import React from &quot;react&quot;;import &#123; Button, Form, Input &#125; from &#x27;antd&#x27;export const LoginScreen = () =&gt; &#123; const &#123; login &#125; = useAuth() // values是由Form.Item的name属性来推断的 const handleSubmit = (values: &#123; username: string, password: string &#125;) =&gt; &#123; login(values) &#125; return &lt;Form onFinish=&#123;handleSubmit&#125;&gt; &lt;Form.Item name=&#123;&#x27;username&#x27;&#125; rules=&#123;[&#123; required: true, message: &#x27;请输入用户名&#x27; &#125;]&#125;&gt; &lt;Input placeholder=&#123;&#x27;用户名&#x27;&#125; type=&quot;text&quot; id=&#123;&#x27;username&#x27;&#125; /&gt; &lt;/Form.Item&gt; &lt;Form.Item name=&#123;&#x27;password&#x27;&#125; rules=&#123;[&#123; required: true, message: &#x27;请输入密码&#x27; &#125;]&#125;&gt; &lt;Input placeholder=&#123;&#x27;密码&#x27;&#125; type=&quot;password&quot; id=&#123;&#x27;password&#x27;&#125; /&gt; &lt;/Form.Item&gt; &lt;Form.Item&gt; &lt;Button htmlType=&#123;&#x27;submit&#x27;&#125; type=&#123;&#x27;primary&#x27;&#125;&gt;登录&lt;/Button&gt; &lt;/Form.Item&gt; &lt;/Form&gt;&#125; src/unauthenticated-app/register.tsx：和login类似 1234567891011121314151617181920212223import &#123; useAuth &#125; from &quot;context/auth-context&quot;;import React from &quot;react&quot;;import &#123; Button, Form, Input &#125; from &#x27;antd&#x27;export const RegisterScreen = () =&gt; &#123; const &#123; register &#125; = useAuth() const handleSubmit = (values: &#123; username: string, password: string &#125;) =&gt; &#123; register(values) &#125; return &lt;Form onFinish=&#123;handleSubmit&#125;&gt; &lt;Form.Item name=&#123;&#x27;username&#x27;&#125; rules=&#123;[&#123; required: true, message: &#x27;请输入用户名&#x27; &#125;]&#125;&gt; &lt;Input placeholder=&#123;&#x27;用户名&#x27;&#125; type=&quot;text&quot; id=&#123;&#x27;username&#x27;&#125; /&gt; &lt;/Form.Item&gt; &lt;Form.Item name=&#123;&#x27;password&#x27;&#125; rules=&#123;[&#123; required: true, message: &#x27;请输入密码&#x27; &#125;]&#125;&gt; &lt;Input placeholder=&#123;&#x27;密码&#x27;&#125; type=&quot;password&quot; id=&#123;&#x27;password&#x27;&#125; /&gt; &lt;/Form.Item&gt; &lt;Form.Item&gt; &lt;Button htmlType=&#123;&#x27;submit&#x27;&#125; type=&#123;&#x27;primary&#x27;&#125;&gt;注册&lt;/Button&gt; &lt;/Form.Item&gt; &lt;/Form&gt;&#125; src/unauthenticated-app/index.tsx：使用Card优化样式和布局 1234567891011121314151617import React, &#123; useState &#125; from &quot;react&quot;import &#123; LoginScreen &#125; from &quot;./login&quot;import &#123; RegisterScreen &#125; from &quot;./register&quot;import &#123; Card &#125; from &#x27;antd&#x27;export const UnauthenticatedApp = () =&gt; &#123; // 默认登录页 const [isRegister, setIsRegister] = useState(false) return &lt;div style=&#123;&#123; display: &#x27;flex&#x27;, justifyContent: &#x27;center&#x27; &#125;&#125;&gt; &lt;Card&gt; &#123; isRegister ? &lt;RegisterScreen /&gt; : &lt;LoginScreen /&gt; &#125; &lt;button onClick=&#123;() =&gt; setIsRegister(!isRegister)&#125;&gt;切换到&#123;isRegister ? &#x27;登录&#x27; : &#x27;注册&#x27;&#125;&lt;/button&gt; &lt;/Card&gt; &lt;/div&gt;&#125; src/screens/project-list/list.tsx： 12345678910111213141516171819202122232425262728293031import React from &quot;react&quot;import &#123; User &#125; from &#x27;screens/project-list/search-panel&#x27;import &#123; Table &#125; from &#x27;antd&#x27;interface Project &#123; id: string name: string personId: string pin: Boolean organization: string&#125;interface ListProps &#123; list: Project[] users: User[]&#125;export const List = (&#123; list, users &#125;: ListProps) =&gt; &#123; return &lt;Table pagination=&#123;false&#125; columns=&#123;[&#123; title: &#x27;名称&#x27;, dataIndex: &#x27;name&#x27;, sorter: (a, b) =&gt; a.name.localeCompare(b.name) // 可以排序中文字符 &#125;, &#123; title: &#x27;负责人&#x27;, render(value, project) &#123; return &lt;span&gt; &#123;users.find(user =&gt; user.id === project.personId)?.name || &#x27;未知&#x27;&#125; &lt;/span&gt; &#125; &#125;]&#125; dataSource=&#123;list&#125; /&gt;&#125; src/screens/project-list/search-panel.tsx： 123456789101112131415161718192021222324252627282930313233343536373839import React from &quot;react&quot;import &#123; Input, Select &#125; from &#x27;antd&#x27;export interface User &#123; id: string name: string email: string title: string organization: string token: string&#125;interface SearchPanelProps &#123; users: User[] param: &#123; name: string personId: string &#125; setParam: (param: SearchPanelProps[&#x27;param&#x27;]) =&gt; void&#125;export const SearchPanel = (&#123; users, param, setParam &#125;: SearchPanelProps) =&gt; &#123; return &lt;form&gt; &lt;div&gt; &lt;Input type=&quot;text&quot; value=&#123;param.name&#125; onChange=&#123;evt =&gt; setParam(&#123; ...param, name: evt.target.value &#125;)&#125; /&gt; &lt;Select value=&#123;param.personId&#125; onChange=&#123;value =&gt; setParam(&#123; ...param, personId: value &#125;)&#125;&gt; &lt;Select.Option value=&quot;&quot;&gt;负责人&lt;/Select.Option&gt; &#123; users.map(user =&gt; &lt;Select.Option key=&#123;user.id&#125; value=&#123;user.id&#125;&gt;&#123;user.name&#125;&lt;/Select.Option&gt;) &#125; &lt;/Select&gt; &lt;/div&gt; &lt;/form&gt;&#125; 6-2 为什么我们需要CSS-in-JS方案 -通过传统CSS缺陷学习CSS-in-JS必要性6-3 最受欢迎的CSS-in-JS方案 - Emotion的安装与使用 emotion用来规避全局样式带来的危害，但是我们也需要部分全局样式，写在src/App.css中： 123456789101112html &#123; /* rem em */ /* em 相对于父元素的font-size */ /* rem 相对于根元素html的font-size，r是root的意思 */ /* 默认16px，16*62.5%=10px */ /* 1rem=10px */ font-size: 62.5%;&#125;/* viewport height = vh，1vh=1%的视口高度，100vh就等于整个视口高度 */html body #root .App &#123; min-height: 100vh;&#125; 安装$ npm i @emotion/react @emotion/styled -S，给vscode安装插件vscode-styled-components，这样编辑器中语法便会有高亮提示。 src/unauthenticated-app/index.tsx，主题添加了logo、背景图、优化了card等的样式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import React, &#123; useState &#125; from &quot;react&quot;import &#123; LoginScreen &#125; from &quot;./login&quot;import &#123; RegisterScreen &#125; from &quot;./register&quot;import &#123; Card, Divider &#125; from &#x27;antd&#x27;import styled from &#x27;@emotion/styled&#x27;import logo from &#x27;assets/logo.svg&#x27;import left from &#x27;assets/left.jpg&#x27;import right from &#x27;assets/right.jpg&#x27;export const UnauthenticatedApp = () =&gt; &#123; // 默认登录页 const [isRegister, setIsRegister] = useState(false) return &lt;Container&gt; &lt;Header /&gt; &lt;Background /&gt; &lt;ShadowCard&gt; &lt;Title&gt; &#123;isRegister ? &#x27;请注册&#x27; : &#x27;请登录&#x27;&#125; &lt;/Title&gt; &#123; isRegister ? &lt;RegisterScreen /&gt; : &lt;LoginScreen /&gt; &#125; &lt;Divider /&gt; &lt;a onClick=&#123;() =&gt; setIsRegister(!isRegister)&#125;&gt; &#123;isRegister ? &#x27;已经有账号了？直接登录&#x27; : &#x27;没有账号？注册新账号&#x27;&#125; &lt;/a&gt; &lt;/ShadowCard&gt; &lt;/Container&gt;&#125;const Title = styled.h2`margin-bottom: 2.4rem;color: rgb(94,108,132);`const Background = styled.div`position: absolute;width: 100%;height: 100%;background-repeat: no-repeat;background-attachment: fixed; // 决定背景图是否会随着页面的滑动而一起滑动background-position: left bottom, right bottom;background-size: calc((100vw - 40rem) / 2 - 3.2rem), calc((100vw - 40rem) / 2 - 3.2rem), cover;background-image: url($&#123;left&#125;), url($&#123;right&#125;);`const Header = styled.header`background: url($&#123;logo&#125;) no-repeat center;padding: 5rem 0;background-size: 8rem;width: 100%;`const ShadowCard = styled(Card)`width: 40rem;min-height: 56rem;padding: 3.2rem 4rem;border-radius: 0.3rem;box-sizing: border-box;box-shadow: rgba(0,0,0,0.1) 0 0 10px;text-align: center;`const Container = styled.div`display: flex;flex-direction: column;align-items: center;min-height: 100vh;` 在src/unauthenticated-app/index.tsx中导出LongButton，并将其应用在login.tsx和register.tsx中： 12345import &#123; Button &#125; from &#x27;antd&#x27;export const LongButton = styled(Button)`width: 100%;` 123import &#123; LongButton &#125; from &quot;unauthenticated-app&quot;;&lt;LongButton htmlType=&#123;&#x27;submit&#x27;&#125; type=&#123;&#x27;primary&#x27;&#125;&gt;登录&lt;/LongButton&gt; 将src/index.css删掉，并删除其他文件对它的引用。 6-4 用Grid和Flexbox布局优化项目列表页面 用grid system和flexbox共同实现类似这样的布局，在src/authenticated-app.tsx里演示： 先用grid system实现整体布局看看效果： 123456789101112131415161718192021222324252627282930313233343536export const AuthenticatedApp = () =&gt; &#123; const &#123; logout &#125; = useAuth() return &lt;Container&gt; &lt;Header&gt; &lt;button onClick=&#123;logout&#125;&gt;登出&lt;/button&gt; &lt;/Header&gt; &lt;Nav&gt;nav&lt;/Nav&gt; &lt;Main&gt; &lt;ProjectListScreen /&gt; &lt;/Main&gt; &lt;Aside&gt;aside&lt;/Aside&gt; &lt;Footer&gt;footer&lt;/Footer&gt; &lt;/Container&gt;&#125;// step2.写container的布局样式const Container = styled.div`display: grid; // grid布局grid-template-rows: 6rem 1fr 6rem; // 从上到下的高度，即header和footer各高6rem，中间高100vh - 12remgrid-template-columns: 20rem 1fr 20rem; // // 从左到右的宽度，注意把header和footer也切成了3列grid-template-areas: // 元素的排列方式&quot;header header header&quot; // header独占一行，高6rem&quot;nav main aside&quot; // 左nav 中间main 右aside，分别宽20rem 1fr 20rem&quot;footer footer footer&quot; // footer独占一行，高6rem;height: 100vh;grid-gap: 10rem; // 形容块与块之间的距离`// step1.分别定义这五个子元素// grid-area 用来给grid子元素起名字const Header = styled.header`grid-area: header`const Main = styled.main`grid-area: main`const Nav = styled.nav`grid-area: nav`const Aside = styled.aside`grid-area: aside`const Footer = styled.footer`grid-area: footer` 接下来应用flex box实现heder的布局： 12345678910111213141516171819202122232425262728293031export const AuthenticatedApp = () =&gt; &#123; const &#123; logout &#125; = useAuth() return &lt;Container&gt; &lt;Header&gt; &lt;HeaderLeft&gt; &lt;h3&gt;logo&lt;/h3&gt; &lt;h3&gt;项目&lt;/h3&gt; &lt;h3&gt;用户&lt;/h3&gt; &lt;/HeaderLeft&gt; &lt;HeaderRight&gt; &lt;button onClick=&#123;logout&#125;&gt;登出&lt;/button&gt; &lt;/HeaderRight&gt; &lt;/Header&gt; ... &lt;/Container&gt;&#125;...// step1.分别定义这五个子元素// grid-area 用来给grid子元素起名字const Header = styled.header`grid-area: header;display: flex;align-items: center;justify-content: space-between;`const HeaderLeft = styled.div`display: flex;align-items: center;`const HeaderRight = styled.div``... grid和flex各自的应用场景： 要考虑，是一维布局(只有横布局或竖布局) 还是二维布局(横竖都有) 一般来说，一维布局用flex，二维布局用grid 是从内容出发还是从布局出发？ 从内容出发：你先有一组内容(数量一般不固定，比如数据遍历的，或者未来可能会在上面添加新的元素)，然后希望他们均匀地分布在容器中，由内容自己的大小决定占据的空间 从布局出发：先规划网格(数量一般比较固定)，然后再把元素往里填充 从内容出发，用flex；从布局出发，用grid。 精简src/authenticated-app.tsx成我们项目需要的界面： 1234567891011121314151617181920212223242526272829303132333435363738394041424344export const AuthenticatedApp = () =&gt; &#123; const &#123; logout &#125; = useAuth() return &lt;Container&gt; &lt;Header&gt; &lt;HeaderLeft&gt; &lt;h3&gt;logo&lt;/h3&gt; &lt;h3&gt;项目&lt;/h3&gt; &lt;h3&gt;用户&lt;/h3&gt; &lt;/HeaderLeft&gt; &lt;HeaderRight&gt; &lt;button onClick=&#123;logout&#125;&gt;登出&lt;/button&gt; &lt;/HeaderRight&gt; &lt;/Header&gt; &lt;Main&gt; &lt;ProjectListScreen /&gt; &lt;/Main&gt; &lt;/Container&gt;&#125;// step2.写container的布局样式const Container = styled.div`display: grid; // grid布局grid-template-rows: 6rem 1fr;grid-template-areas:&quot;header&quot;&quot;main&quot;;height: 100vh;`// step1.分别定义这五个子元素// grid-area 用来给grid子元素起名字const Header = styled.header`grid-area: header;display: flex;align-items: center;justify-content: space-between;`const HeaderLeft = styled.div`display: flex;align-items: center;`const HeaderRight = styled.div``const Main = styled.main`grid-area: main` 6-5 用CSS-in-JS状态工程创建自定义组件：Row组件实现 新建src/components/lib.tsx： 123456789101112131415161718import styled from &#x27;@emotion/styled&#x27;export const Row = styled.div&lt;&#123; gap?: number | boolean, between?: boolean, marginBottom?: number&#125;&gt;`display: flex;align-items: center;justify-content: $&#123;props =&gt; props.between ? &#x27;space-between&#x27; : undefined&#125;;margin-bottom: $&#123;props =&gt; props.marginBottom + &#x27;rem&#x27;&#125;;&gt; * &#123;margin-top: 0!important;margin-bottom: 0!important;margin-right: $&#123;props =&gt; typeof props.gap === &#x27;number&#x27; ? props.gap + &#x27;rem&#x27; : props.gap ? &#x27;2rem&#x27; : undefined&#125;;&#125;` 在src/authenticated-app.tsx中使用： 1234567891011121314151617181920212223242526...import styled from &quot;@emotion/styled&quot;;import &#123; Row &#125; from &quot;components/lib&quot;;export const AuthenticatedApp = () =&gt; &#123; const &#123; logout &#125; = useAuth() return &lt;Container&gt; &lt;Header between&gt; &lt;HeaderLeft gap&gt; &lt;h2&gt;logo&lt;/h2&gt; &lt;h2&gt;项目&lt;/h2&gt; &lt;h2&gt;用户&lt;/h2&gt; &lt;/HeaderLeft&gt; &lt;HeaderRight&gt; &lt;button onClick=&#123;logout&#125;&gt;登出&lt;/button&gt; &lt;/HeaderRight&gt; &lt;/Header&gt; ... &lt;/Container&gt;&#125;...const Header = styled(Row)`grid-area: header;`const HeaderLeft = styled(Row)``... 6-6 完善项目列表页面样式 先调整src/screens/project-list/search-panel.tsx中的表单： 123456789101112import &#123; Input, Select, Form &#125; from &#x27;antd&#x27;...export const SearchPanel = (&#123; users, param, setParam &#125;: SearchPanelProps) =&gt; &#123; return &lt;Form layout=&#123;&#x27;inline&#x27;&#125;&gt; &lt;Form.Item&gt; &lt;Input /&gt; &lt;/Form.Item&gt; &lt;Form.Item&gt; &lt;Select&gt;...&lt;/Select&gt; &lt;/Form.Item&gt; &lt;/Form&gt;&#125; 再调整src/screens/project-list/index.tsx外层的container： 1234567891011121314...import styled from &quot;@emotion/styled&quot;export const ProjectListScreen = () =&gt; &#123; ... return &lt;Container&gt; &lt;h1&gt;项目列表&lt;/h1&gt; ... &lt;/Container&gt;&#125;const Container = styled.div`padding: 3.2rem;` 调整src/screens/project-list/list.tsx： 表格中添加【部门】列： 123456export const List = (&#123; list, users &#125;: ListProps) =&gt; &#123; return &lt;Table pagination=&#123;false&#125; columns=&#123;[..., &#123; title: &#x27;部门&#x27;, dataIndex: &#x27;organization&#x27; &#125;]&#125; dataSource=&#123;list&#125; /&gt;&#125; 安装轻量库dayjs$ npm i dayjs -S处理【创建时间】列(注意momentjs已停止维护，不再建议使用)： 12345678910export const List = (&#123; list, users &#125;: ListProps) =&gt; &#123; return &lt;Table pagination=&#123;false&#125; columns=&#123;[..., &#123; title: &#x27;创建时间&#x27;, render(value, project) &#123; return &lt;span&gt; &#123;project.created ? dayjs(project.created).format(&#x27;YYYY-MM-DD&#x27;) : &#x27;无&#x27;&#125; &lt;/span&gt; &#125; &#125;]&#125; dataSource=&#123;list&#125; /&gt;&#125; 调整src/authenticated-app.tsx中的logo： 由于svg图片用img渲染后没法自定义样式，所以需要使用react组件方式并以svg的形式渲染出来： 12345678910111213141516171819202122...import &#123; ReactComponent as SoftwareLogo &#125; from &#x27;assets/logo.svg&#x27;export const AuthenticatedApp = () =&gt; &#123; const &#123; logout &#125; = useAuth() return &lt;Container&gt; &lt;Header between&gt; &lt;HeaderLeft gap&gt; &lt;SoftwareLogo width=&#123;&#x27;6rem&#x27;&#125; color=&#123;&#x27;rgb(38,132,255)&#x27;&#125; /&gt; ... &lt;/HeaderLeft&gt; ... &lt;/Header&gt; ... &lt;/Container&gt;&#125;...const Header = styled(Row)`grid-area: header;padding: 3.2rem;`... 调整登出下拉框和显示用户： 123456789101112131415161718192021222324...import &#123; Dropdown, Menu &#125; from &quot;antd&quot;;export const AuthenticatedApp = () =&gt; &#123; const &#123; logout, user &#125; = useAuth() return &lt;Container&gt; &lt;Header between&gt; ... &lt;HeaderRight&gt; &lt;Dropdown overlay=&#123;&lt;Menu&gt; &lt;Menu.Item key=&#123;&#x27;logoout&#x27;&#125;&gt; &lt;a onClick=&#123;logout&#125;&gt;登出&lt;/a&gt; &lt;/Menu.Item&gt; &lt;/Menu&gt;&#125;&gt; &lt;a onClick=&#123;e =&gt; e.preventDefault()&#125;&gt; Hi, &#123;user?.name&#125; &lt;/a&gt; &lt;/Dropdown&gt; &lt;/HeaderRight&gt; &lt;/Header&gt; ... &lt;/Container&gt;&#125;... 给header添加底部分割线： 12345const Header = styled(Row)`...box-shadow: 0 0 5px 0 rgba(0,0,0,0.1);z-index: 1;` 6-7 清除前面课程留下的警告信息 如果把一个变量指定为object类型，它可能是&#123;name:&#39;jack&#39;&#125;、()=&gt;&#123;&#125;、new RegExp(&#39;&#39;)、&#123;...(()=&gt;&#123;&#125;)&#125;等形式，所以我们得到的值可能就是个空对象{}，所以轻易不要使用object类型，而要更加具体地指定它的类型，在src/utils/index.ts中做如下修改： 123456789101112// export const cleanObject = (obj: object) =&gt; &#123;...&#125;// 改为：export const cleanObject = (obj: &#123; [key: string]: unknown &#125;) =&gt; &#123; const result = &#123; ...obj &#125; Object.keys(result).forEach(key =&gt; &#123; const value = result[key] if (isFalsy(value)) &#123; delete result[key] &#125; &#125;) return result&#125; 再解决isFalsy()方法可能会导致的bug：假如我们传入的是false的字面量如&#123;checked:false&#125;，在cleanObject()中也会被删掉，在src/utils/index.ts中做如下修改： 12345678910111213// 将上面的isFalsy改为isVoid:export const isVoid = (value: unknown) =&gt; value === undefined || value === null || value === &#x27;&#x27;export const cleanObject = (obj: &#123; [key: string]: unknown &#125;) =&gt; &#123; const result = &#123; ...obj &#125; Object.keys(result).forEach(key =&gt; &#123; const value = result[key] if (isVoid(value)) &#123; delete result[key] &#125; &#125;) return result&#125; 处理控制台的警告： 【The href attribute is required for an anchor to be keyboard accessible. Provide a valid, navigable address as the href value. If you cannot provide an href, but still need the element to resemble a link, use a button and change it with appropriate styles.】 是指a标签没有合法的超链接href地址，改为使用： 12import &#123; Button &#125; from &quot;antd&quot;;&lt;Button type=&#123;&#x27;link&#x27;&#125;&gt;登出&lt;/Button&gt; 【React Hook useEffect has a missing dependency: ‘callback’. Either include it or remove the dependency array. If ‘callback’ changes too often, find the parent component that defines it and wrap that definition in useCallback react-hooks/exhaustive-deps】 这种情况不予处理，因为依赖项里加上callback会造成无限循环，这个和useCallback以及useMemo有关系： 123456export const useMount = (callback: () =&gt; void) =&gt; &#123; useEffect(() =&gt; &#123; callback() // eslint-disable-next-line react-hooks/exhaustive-deps &#125;, [])&#125; 报错【Detected outdated Service Worker: Currently active Service Worker (a615cd395ea10f948a628bce3857a385) is behind the latest published one (65d33ca82955e1c5928aed19d1bdf3f9).】 是由于jira-dev-tool和我们实际的项目有点冲突，安装另一个版本$ npm i jira-dev-tool@next -S，按照视频讲解，这个版本不能使用。","categories":[{"name":"React","slug":"React","permalink":"https://scarlett9354.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://scarlett9354.github.io/tags/React/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://scarlett9354.github.io/tags/TypeScript/"},{"name":"React Hook","slug":"React-Hook","permalink":"https://scarlett9354.github.io/tags/React-Hook/"}]},{"title":"工作记录","slug":"工作记录","date":"2021-06-25T07:05:07.000Z","updated":"2021-10-14T07:42:18.712Z","comments":true,"path":"2021/06/25/工作记录/","link":"","permalink":"https://scarlett9354.github.io/2021/06/25/%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95/","excerpt":"","text":"一个带有参数的函数作为另一个函数的参数1234567function add(n) &#123; return n + 5&#125;function show(fn(n)) &#123; alert(fn(n))&#125;show(add(5)) // 17 可以改写为： 1234567function add(n) &#123; return n + 5&#125;function show(n, fn) &#123; alert(fn(n))&#125;show(5, add) // 17 用es6进一步简化： 1234function show(n, fn) &#123; alert(fn(n))&#125;show(5, n =&gt; n + 5) // 17 git commit 提交信息&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt; 如 fix(首页): some message fix指本次做了什么；some message是详细的说明 类型有： 主要type feat -feature: 增加新功能 fix: 修复bug 特殊type docs: 只改动了文档相关的内容 style: (样式改动)不影响代码含义的改动，例如去掉空格、改变缩进、增删分号 build: 构造工具的或者外部依赖的改动，例如webpack，npm refactor: 代码重构时使用 revert: 执行git revert打印的message 暂不使用type test: 添加测试或者修改现有测试 perf -performance: 提高性能的改动 ci: 与CI（持续集成服务）有关的改动 chore: 修改src或者test的其余修改，例如构建过程或辅助工具的变动 当一次改动包括主要type与特殊type时，统一采用主要type。 怎么成为微信小程序开发服务商？我是一家软件定制开发公司，业务需要为客户开发小程序，目前要开发管理的小程序越来越多，之前看过别的同行企业可以统一管理、发布、更新客户的小程序，而不用索取客户账号信息进行发布、更新小程序，怎么实现的呢？ https://open.weixin.qq.com https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/Third_party_platform_appid.html 怎么申请成为服务商？ https://kf.qq.com/touch/faq/170823BnEfey1708233mIVj2.html?platform=15 https://developers.weixin.qq.com/doc/oplatform/Third-party_Platforms/2.0/product/how_to_dev.html 第三方平台代开发：https://developers.weixin.qq.com/miniprogram/dev/devtools/ext.html 微信开放平台第三方代实现小程序业务简述 官方※https://developers.weixin.qq.com/community/business/doc/000648e11201c0ca44da6a4fb56c0d","categories":[{"name":"工作相关","slug":"工作相关","permalink":"https://scarlett9354.github.io/categories/%E5%B7%A5%E4%BD%9C%E7%9B%B8%E5%85%B3/"}],"tags":[]},{"title":"ES6精讲","slug":"ES6精讲","date":"2021-06-25T07:00:00.000Z","updated":"2021-06-28T08:50:46.320Z","comments":true,"path":"2021/06/25/ES6精讲/","link":"","permalink":"https://scarlett9354.github.io/2021/06/25/ES6%E7%B2%BE%E8%AE%B2/","excerpt":"","text":"箭头函数简写函数，需要注意两点： 如果有且仅有一个参数，()也可以不写 1234function show(n, fn) &#123; alert(fn(n))&#125;show(5, n =&gt; n + 5) // 17 如果有且仅有一个语句并且是return，{return }也可以不写 123let arr = [12, 8, 37, 26, 9]arr.sort((n1, n2) =&gt; n1 - n2)console.log(arr) // [8, 9, 12, 26, 37] this 展开符（三个点…）12345let arr1 = [12, 5, 8]function show(a, b, c) &#123; alert(a + b + c)&#125;show(arr1) // 12,5,8undefinedundefined 相当于arr1的三个元素全都作为参数a了，并且函数体中的+号就变成了字符串拼接了，arr1的三个参数就用,号拼接了。 1show(...arr1) // 25 Array方法map 映射：一一对应（进去几个，出来对应的几个） 1[68, 53, 12, 98, 65] =&gt; [及格，不及格，不及格，及格，及格] reduce 缩减（进去n个，出来就剩1个） 常见场景：求平均分，求和 123456789let arr = [68, 53, 12, 98, 65]let res = arr.reduce((tmp, item, index) =&gt; &#123; if(index === arr.length - 1) &#123; return (tmp + item) / index &#125;else &#123; return tmp + item &#125;&#125;)console.log(res) // 59.2 第一次循环tmp是第一个元素68，item是它后面的那个即第二个元素53，index指的第几次运算（也可以理解为当前item对应的脚标）。 filter 过滤 （进去n个，出来几个不一定，得符合条件） forEach 遍历，没有返回值 模块 常见的导出方式（声明模块）： 声明并导出 export let a = 12 export const a = 12 导出 export &#123;name1, name2, ...&#125; 导出方法 export function show() &#123; ... &#125; 导出类，react和vue的组件都用的这种方式 export class ClassName &#123; ... &#125; 导出默认成员 export default xx 常见的引入方式： import * as mod1 from &#39;xxx&#39; 引入所有export的成员 import mod1 from &#39;xxx&#39; 引入default成员 import &#123;a, b as name2, [...]&#125; from &#39;xxx&#39; 选择引入成员 import &#39;xxx&#39; 只引入，常用于引入css let promise = import(&#39;./mod1&#39;) 异步引入，import引入的结果是个promise，可以用来做路由懒加载 ES7 幂操作 3**5 代替了原来的 Math.pow(3, 5)，表示3的5次方 Array.includes() 检测…是否存在 ES8 async/await promise ES9 rest/spread 消除异步操作的 异步迭代 解决forEach不能暂停的问题 Promise.finally() 当所有请求完成，无论成功还是失败，都会执行finally 正则表达式 参考ES6精讲-blue老师","categories":[{"name":"ES6-7","slug":"ES6-7","permalink":"https://scarlett9354.github.io/categories/ES6-7/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://scarlett9354.github.io/tags/ES6/"}]},{"title":"async_await详解-彻底摆脱回调地狱","slug":"async-await详解-彻底摆脱回调地狱","date":"2021-06-18T07:58:40.000Z","updated":"2022-02-28T06:53:50.742Z","comments":true,"path":"2021/06/18/async-await详解-彻底摆脱回调地狱/","link":"","permalink":"https://scarlett9354.github.io/2021/06/18/async-await%E8%AF%A6%E8%A7%A3-%E5%BD%BB%E5%BA%95%E6%91%86%E8%84%B1%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1/","excerpt":"","text":"1丨编写第一个asyn-await函数 2丨将async函数用在promise-chain中 3丨把任意类型的函数转成async风格 4丨处理async函数中的错误 5丨正确处理多个await操作的并行串行 6丨使用Promise.all()让多个await操作并行 7丨结合await和任意兼容.then()的代码 8丨在for循环中正确地使用await 1丨编写第一个asyn-await函数 假设一个场景，我们请求知乎专栏的api，拿到专栏的详情，然后打印专栏的名称和简介。 以前的写法： 1234567891011const fetch = require(&#x27;node-fetch&#x27;)function getZhihuColumn(id) &#123; const url = `https://zhuanlan.zhihu.com/api/columns/$&#123;id&#125;` fetch(url) .then(response =&gt; response.json()) .then(column =&gt; &#123; console.log(`NAME: $&#123;column.name&#125;`) console.log(`INTRO: $&#123;column.intro&#125;`) &#125;)&#125;getZhihuColumn(&#x27;feweekly&#x27;) 用async-await把它改的更扁平一些： 第一步，在函数前面加上async关键字： 1async function getZhihuColumn(id) &#123;&#125; 然后拿到专栏的详情的数据，并将其转成json： 123456const fetch = require(&#x27;node-fetch&#x27;)async function getZhihuColumn(id) &#123; const url = `https://zhuanlan.zhihu.com/api/columns/$&#123;id&#125;` const response = await fetch(url) const column = await response.json()&#125; await关键字接收一个promise，在promise resolve时把resolve的值赋给表达式左边的变量，即response；当promise reject时就会抛出一个错误，throw一个error。 然后把专栏的名称和简介打印出来： 12345678const fetch = require(&#x27;node-fetch&#x27;)async function getZhihuColumn(id) &#123; const url = `https://zhuanlan.zhihu.com/api/columns/$&#123;id&#125;` const response = await fetch(url) const column = await response.json() console.log(`NAME: $&#123;column.name&#125;`) console.log(`INTRO: $&#123;column.intro&#125;`)&#125; 最后，正常调用： 123456789const fetch = require(&#x27;node-fetch&#x27;)async function getZhihuColumn(id) &#123; const url = `https://zhuanlan.zhihu.com/api/columns/$&#123;id&#125;` const response = await fetch(url) const column = await response.json() console.log(`NAME: $&#123;column.name&#125;`) console.log(`INTRO: $&#123;column.intro&#125;`)&#125;getZhihuColumn(&#x27;feweekly&#x27;) 这个函数的函数体读起来更像是同步的代码，即从上向下执行。 2丨将async函数用在promise-chain中 因为所有的async函数都会返回一个promise，所以可以像使用promise一样来使用async函数的返回值。 重构上面的demo： 首先在getZhihuColumn()中return column： 1234567const fetch = require(&#x27;node-fetch&#x27;)async function getZhihuColumn(id) &#123; const url = `https://zhuanlan.zhihu.com/api/columns/$&#123;id&#125;` const response = await fetch(url) const column = await response.json() return column&#125; 然后在调用这个async函数的地方把它当作promise来使用： 12345getZhihuColumn(&#x27;feweekly&#x27;) .then(column =&gt; &#123; console.log(`NAME: $&#123;column.name&#125;`) console.log(`INTRO: $&#123;column.intro&#125;`) &#125;) 在vscode中将光标hover到这个getZhihuColumn(‘feweekly’)函数上，可以明显看出它返回的是个promise的值： function getZhihuColumn(id: any): Promise&lt;any&gt; ，所以我们可以利用promise-chain把多个函数串起来，也可以调用promise的catch方法。 进一步简化上面的demo： 1234567891011const fetch = require(&#x27;node-fetch&#x27;)async function getZhihuColumn(id) &#123; const url = `https://zhuanlan.zhihu.com/api/columns/$&#123;id&#125;` const response = await fetch(url) return await response.json()&#125;getZhihuColumn(&#x27;feweekly&#x27;) .then(column =&gt; &#123; console.log(`NAME: $&#123;column.name&#125;`) console.log(`INTRO: $&#123;column.intro&#125;`) &#125;) 3丨把任意类型的函数转成async风格 async关键字理论上可以适用于js中所有的函数形态，可以把async用到函数表达式、箭头函数以及方法上面。 用到函数表达式上： 1const getZhihuColumn = async function (id) &#123;&#125; 用到箭头函数上： 1const getZhihuColumn = async (id) =&gt; &#123;&#125; 举例： 例：无论在nodejs还是浏览器中，在代码的顶级作用域下使用async关键字是非法的，所以需要声明一个匿名的函数表达式，并立即执行。 12345(async () =&gt; &#123; const column = await getZhihuColumn(&#x27;feweekly&#x27;) console.log(`NAME: $&#123;column.name&#125;`) console.log(`INTRO: $&#123;column.intro&#125;`)&#125;)() 例：在一个类的函数上面使用async-await 12345678910111213class APIClient &#123; async getColumn(id) &#123; const url = `https://zhuanlan.zhihu.com/api/columns/$&#123;id&#125;` const response = await fetch(url) return await response.json() &#125;&#125;(async () =&gt; &#123; const client = new APIClient() const column = await client.getColumn(&#x27;feweekly&#x27;) console.log(`NAME: $&#123;column.name&#125;`) console.log(`INTRO: $&#123;column.intro&#125;`)&#125;)() 在对象上声明async方法时，可以类似于在类上声明的方式。 4丨处理async函数中的错误 在请求一个并不存在的专栏，如getZhihuColumn(&#39;feweekly123&#39;)，执行时会报UnhandledPromiseRejectionWarning，即有未处理的promise rejection，所以我们的async函数中有报错，因为它返回一个promise。 如果服务端代码异常，我们应该抛出一个错误，后续的代码来处理这个错误： 12345678async function getZhihuColumn(id) &#123; const url = `https://zhuanlan.zhihu.com/api/columns/$&#123;id&#125;` const response = await fetch(url) if(response.status !== 200) &#123; throw new Error(response.statusText) &#125; return await response.json()&#125; 在调用时我们可以使用promise的catch方法，也可以在另外一个async函数中调用那个定义的async函数： 12345678910const showColumnInfo = async(id) =&gt; &#123; try &#123; const column = await getZhihuColumn(id) console.log(`NAME: $&#123;column.name&#125;`) console.log(`INTRO: $&#123;column.intro&#125;`) &#125;catch(err) &#123; console.error(err) &#125; &#125;showColumnInfo(&#x27;feweekly&#x27;) 这样就会是我们自己打出的错误，而不是系统运行时报的错误，若使代码变得健壮，错误处理是必不可少的部分。 5丨正确处理多个await操作的并行串行 在之前那个demo基础上，我们请求两个专栏的信息，并把这两个专栏的信息展示出来： 1234567891011121314async function getZhihuColumn(id) &#123; const url = `https://zhuanlan.zhihu.com/api/columns/$&#123;id&#125;` const response = await fetch(url) return await response.json()&#125;const showColumnInfo = async() =&gt; &#123; const feweekly = await getZhihuColumn(&#x27;feweekly&#x27;) const toolingtips = await getZhihuColumn(&#x27;toolingtips&#x27;) console.log(`NAME: $&#123;feweekly.name&#125;`) console.log(`INTRO: $&#123;feweekly.intro&#125;`) console.log(`NAME: $&#123;toolingtips.name&#125;`) console.log(`INTRO: $&#123;toolingtips.intro&#125;`) &#125;showColumnInfo() 这两个await是串行的，即等待第一个请求完成后发起第二个请求。 怎么使这两个请求是并行的呢？ 1234567891011const showColumnInfo = async() =&gt; &#123; // 先定义两个promise，它们是直接发起异步请求，再await它的结果 const feweeklyPromise = getZhihuColumn(&#x27;feweekly&#x27;) const toolingtipsPromise = getZhihuColumn(&#x27;toolingtips&#x27;) const feweekly = await feweeklyPromise const toolingtips = await toolingtipsPromise console.log(`NAME: $&#123;feweekly.name&#125;`) console.log(`INTRO: $&#123;feweekly.intro&#125;`) console.log(`NAME: $&#123;toolingtips.name&#125;`) console.log(`INTRO: $&#123;toolingtips.intro&#125;`) &#125; 把串行的请求改成并行，通常能让我们的代码运行得更快，为了验证这个结论，可进行如下操作： 123456789101112131415161718192021222324// 定义一个sleep函数，接收一个参数timout就是超时，返回一个new Promise，在里面等待2s后再resolve，这个2s可以自定义const sleep = (timeout = 2000) =&gt; new Promise(resolve = &gt; &#123; setTimeout(resolve, timeout)&#125;)// 每次获取知乎专栏之前等待2sasync function getZhihuColumn(id) &#123; await sleep(2000) const url = `https://zhuanlan.zhihu.com/api/columns/$&#123;id&#125;` const response = await fetch(url) return await response.json()&#125;// 为了方便看到时间，在showColumnInfo中加上console的计时const showColumnInfo = async() =&gt; &#123; console.time(&#x27;showColumnInfo&#x27;) const feweeklyPromise = getZhihuColumn(&#x27;feweekly&#x27;) const toolingtipsPromise = getZhihuColumn(&#x27;toolingtips&#x27;) const feweekly = await feweeklyPromise const toolingtips = await toolingtipsPromise console.log(`NAME: $&#123;feweekly.name&#125;`) console.log(`INTRO: $&#123;feweekly.intro&#125;`) console.log(`NAME: $&#123;toolingtips.name&#125;`) console.log(`INTRO: $&#123;toolingtips.intro&#125;`) console.timeEnd(&#x27;showColumnInfo&#x27;)&#125; 打印结果为： 12345NAME: 前端周刊INTRO: 在前端领域...NAME: tooling bitsINTRO: 工欲善其事必先利其器showColumnInfo: 2638.513ms // 两个请求一个花的时间 将这两个请求还原成串行代码，再次打印下时间： 12345678910const showColumnInfo = async() =&gt; &#123; console.time(&#x27;showColumnInfo&#x27;) const feweekly = await getZhihuColumn(&#x27;feweekly&#x27;) const toolingtips = await getZhihuColumn(&#x27;toolingtips&#x27;) console.log(`NAME: $&#123;feweekly.name&#125;`) console.log(`INTRO: $&#123;feweekly.intro&#125;`) console.log(`NAME: $&#123;toolingtips.name&#125;`) console.log(`INTRO: $&#123;toolingtips.intro&#125;`) console.timeEnd(&#x27;showColumnInfo&#x27;)&#125; 打印结果为： 12...showColumnInfo: 4425.278ms // 两个请求一个花的时间 6丨使用Promise.all()让多个await操作并行123456789101112const showColumnInfo = async() =&gt; &#123; // Promise.all()中可以接收一个数组，数组中每个元素都可以是个promise // 它也是返回一个promise，所以可以在上面用await关键字，它再返回的结果就是每个异步操作结束后的结果，会放在一个数组中 const [feweekly, toolingtips] = await Promise.all([ getZhihuColumn(&#x27;feweekly&#x27;), getZhihuColumn(&#x27;toolingtips&#x27;) ]) console.log(`NAME: $&#123;feweekly.name&#125;`) console.log(`INTRO: $&#123;feweekly.intro&#125;`) console.log(`NAME: $&#123;toolingtips.name&#125;`) console.log(`INTRO: $&#123;toolingtips.intro&#125;`) &#125; 7丨结合await和任意兼容.then()的代码 我们已经知道，await操作符后面通常会跟一个promise，如果后面不是跟的promise，会怎样呢？ 12345async function main() &#123; const number = await 890 console.log(number)&#125; main() // 890 这就是await的特性，如果后面跟的不是promise，就会有个隐式的Promise.resolve调用，相当于将890转成一个立即resolve的promise。 上面意味着await操作符可以和任何兼容promise或者和带有then方法的库结合使用，以bluebird库举例： 1234567const bluebird = require(&#x27;bluebird&#x27;)async function main() &#123; console.log(&#x27;waiting...&#x27;) await bluebird.delay(2000) console.log(&#x27;done!&#x27;)&#125; main() // 运行结果是：先打出waiting...，隔2s后再打出done! 8丨在for循环中正确地使用await123456789101112const fetch = require(&#x27;node-fetch&#x27;)const bluebird = require(&#x27;bluebird&#x27;)async function getZhihuColumn(id) &#123; await bluebird.delay(1000) const url = `https://zhuanlan.zhihu.com/api/columns/$&#123;id&#125;` const response = await fetch(url) return await response.json()&#125;const showColumnInfo = async() =&gt; &#123; ...&#125;showColumnInfo() 以下只修改showColumnInfo()函数： 在循环中串行 12345678910const showColumnInfo = async() =&gt; &#123; console.time(&#x27;showColumnInfo&#x27;) const names = [&#x27;feweekly&#x27;, &#x27;toolingtips&#x27;] for(const name of names) &#123; const column = await getZhihuColumn(name) console.log(`NAME: $&#123;column.name&#125;`) console.log(`INTRO: $&#123;column.intro&#125;`) &#125; console.timeEnd(&#x27;showColumnInfo&#x27;)&#125; 执行结果为： 12345NAME: 前端周刊INTRO: 在前端领域...NAME: tooling bitsINTRO: 工欲善其事必先利其器showColumnInfo: 2673.296ms // 两个请求一个花的时间 在循环中并行 - 思路：先触发所有请求，然后拿到一个promise数组，并遍历它，等待里面的结果resolve 1234567891011const showColumnInfo = async() =&gt; &#123; console.time(&#x27;showColumnInfo&#x27;) const names = [&#x27;feweekly&#x27;, &#x27;toolingtips&#x27;] const promises = names.map(x =&gt; getZhihuColumn(x)) for(const promise of promises) &#123; const column = await promise console.log(`NAME: $&#123;column.name&#125;`) console.log(`INTRO: $&#123;column.intro&#125;`) &#125; console.timeEnd(&#x27;showColumnInfo&#x27;)&#125; 执行结果为： 12...showColumnInfo: 1557.730ms // 两个请求一个花的时间 可以明显地看到，循环总共花费的时间已经小于2s了。","categories":[{"name":"工作相关","slug":"工作相关","permalink":"https://scarlett9354.github.io/categories/%E5%B7%A5%E4%BD%9C%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"ES7","slug":"ES7","permalink":"https://scarlett9354.github.io/tags/ES7/"}]},{"title":"Vue中页面前进刷新回退不刷新的实现","slug":"Vue中页面前进刷新回退不刷新的实现","date":"2021-05-14T07:31:53.000Z","updated":"2021-06-18T07:57:47.447Z","comments":true,"path":"2021/05/14/Vue中页面前进刷新回退不刷新的实现/","link":"","permalink":"https://scarlett9354.github.io/2021/05/14/Vue%E4%B8%AD%E9%A1%B5%E9%9D%A2%E5%89%8D%E8%BF%9B%E5%88%B7%E6%96%B0%E5%9B%9E%E9%80%80%E4%B8%8D%E5%88%B7%E6%96%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"需求场景点击某个分页加载的商品列表中的某个中间位置的商品，跳到对应的详情页，从详情页返回列表不刷新页面。","categories":[{"name":"工作相关","slug":"工作相关","permalink":"https://scarlett9354.github.io/categories/%E5%B7%A5%E4%BD%9C%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://scarlett9354.github.io/tags/vue/"}]},{"title":"React16.4 开发简书项目 从零基础入门到实战","slug":"React16.4 开发简书项目 从零基础入门到实战","date":"2021-05-11T09:25:48.000Z","updated":"2021-05-12T08:18:19.020Z","comments":true,"path":"2021/05/11/React16.4 开发简书项目 从零基础入门到实战/","link":"","permalink":"https://scarlett9354.github.io/2021/05/11/React16.4%20%E5%BC%80%E5%8F%91%E7%AE%80%E4%B9%A6%E9%A1%B9%E7%9B%AE%20%E4%BB%8E%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E6%88%98/","excerpt":"","text":"第1章 课程导学 第2章 react初探 2-1 react简介 2-2 react开发环境准备-安装 2-3 工程目录简介 2-4 react中的组件 2-5 react中最基础的jsx语法 第3章 react基础精讲 3-1 使用react编写todolist功能 3-2 react中的响应式设计思想和事件绑定 3-3 实现todolist增和删功能 3-4 jsx语法细节补充 3-5 拆分组件与组件之间的传值 3-6 代码优化 3-7 围绕react衍生出的思考 第4章 react高级内容 4-1 react开发调试工具developer-tools的安装和使用 4-2 prop-types与default-types的应用 4-3 props, state和render函数的关系 4-4 react中的虚拟dom-以下为react底层真正的实现 4-5 深入了解虚拟dom 4-6 虚拟dom中的diff算法 4-7 react中ref的使用 4-8 react的生命周期函数 4-9 react生命周期函数的使用场景 4-10 使用charles实现本地数据mock (模拟) 4-11 react中实现css过渡动画 4-12 react中使用css动画效果 4-13 使用react-transition-group实现动画 4-14 使用react-transition-group实现多个元素间的动画效果 第5章 redux入门 5-1 redux概念简述 5-2 redux的工作流程 5-3 使用ant-design实现todolist页面布局 5-4 创建redux中的store 5-5 action和reducer的编写 5-6 使用redux完成todolist的删除功能 5-7 action-types的拆分 5-8 使用action-creator统一创建action 5-9 redux知识点复习补充 第6章 redux进阶 6-1 ui组件和容器组件 6-2 无状态组件 6-3 redux中发送异步请求获取数据 6-4 什么是redux的中间件 第1章 课程导学第2章 react初探2-1 react简介2-2 react开发环境准备-安装先安装node，再执行以下命令安装react脚手架工具： 1234$ npm install -g create-react-app$ create-react-app todolist$ cd todolist$ npm start 2-3 工程目录简介 src/index.js是整个程序的入口文件，react的设计理念是all in js，所以在js中可以引入index.css serviceWorker实际是PWA（progressive web application），它的理念是让我们通过写网页的形式来写一些app的应用。 假设我们写了个网页并上线到一台支持https协议的服务器上，那么当用户第一次访问这个网页的时候需要连网才能看到，一旦断网了，如果项目引用了该文件，下次再访问也依然能看到之前的页面，因为会帮助存储在浏览器之内。 manifest.json是PWA serviceWorker存储的页面的快捷方式的配置。 精简后项目 App.js负责显示页面内容，index.js负责引入App并渲染到页面中。 2-4 react中的组件 App.js: 实际上是react的一个组件，所以必须引入component来生成组件。 123456789101112131415// component结构赋值引入：import &#123; Component &#125; from &#x27;react&#x27; // 等价于import React from &#x27;react&#x27;const Component = React.Component// 使用：class App extends Component &#123; render() &#123; return ( &lt;div&gt; hello &lt;/div&gt; ) &#125;&#125;export default App 以上render函数中的div标签使用的也是jsx语法，所以必须引入react才能正常编译。 index.js: ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;))将App组件挂载到id=&#39;root&#39;的dom下，在public/index.html中。 以上挂载组件&lt;App /&gt;使用的是jsx语法，所以必须引入react才能正常编译。 2-5 react中最基础的jsx语法即在js中使用html原生标签或自定义组件标签（首字母大写） 第3章 react基础精讲3-1 使用react编写todolist功能render函数return的元素必须包在一个标签里如div，若不想让该标签显示，可以使用Fragment占位符： 3-2 react中的响应式设计思想和事件绑定 TodoList这个类必有构造函数constructor，当我们使用该组件时，constructor会最优先被执行； 因为TodoList组件继承了React中的Component组件，所以要在创建TodoList时要super即调用一次父类Component的构造函数，此句为固定代码，接收props参数和调用super(props)方法： 需要注意的点： (1) 数据都放在state中； (2) jsx中想用js的表达式要用{}包裹； (3) 事件绑定时要用bind(this)对函数的作用域进行变更； (4) 若想改变state中内容，需要通过setState函数。 3-3 实现todolist增和删功能 新增 删除 注意：React中有个immutable，即state不允许我们直接用this.state做任何改变，可以拷贝副本修改，再用setState赋值。 3-4 jsx语法细节补充 注释 1234&#123;/*注释内容*/&#125;&#123; // 注释内容&#125; 在js文件中定义class，要使用className 如果需要解析标签，可以添加属性dangerouslySetInnerHTML： label的for属性会被react误认为是for循环，要替换成htmlFor： 3-5 拆分组件与组件之间的传值 父组件向子组件传值 通过属性传递 子组件TodoItem.js： 父组件TodoList.js： 父组件向子组件传值后，子组件加click事件： 子组件TodoItem.js如下，使用constructor改变this指向以提高性能： 父组件向子组件传递方法： 父组件TodoList.js： ps：此处的handleLiDelete一定要bind(this)让this指向父组件本身。 子组件TodoItem.js： 3-6 代码优化 TodoItem.js: 采用ES6的解构赋值进行优化： 优化前： 优化后： TodoList.js: 将行内bind(this)的方法移到constructor中bind html中涉及逻辑的代码最好都写成方法return出去 新版React建议setState方法用异步返回，可以提升性能： (1) this.setState返回值的完整写法和缩写 (2) 注意此处的e.target.value需要存成一个变量，否则会报错; (3) setState的参数prevState等价于this.state 3-7 围绕react衍生出的思考 声明式开发 – 不直接操作dom 可以与其他框架并存 – react挂载到index.html中id为root中，其他框架可以操作与之并列的dom，互不干扰 组件化 单向数据流 – 父组件允许向子组件传值，但子组件只能使用该值而不能改变它 视图层框架 – 大型项目中需要借助数据层框架如flux、redux传值 函数式编程 第4章 react高级内容4-1 react开发调试工具developer-tools的安装和使用安装需要翻墙啊啊啊~~ 4-2 prop-types与default-types的应用 propTypes – 限制父组件给子组件传的值的类型 defaultProps – 在某些情况下某个父组件给子组件传不了某个属性如test，但子组件中又要求test是必填的，就会用到defaultProps (1) prop类型通常有array数组、bool布尔值、func函数、number数字、object对象、string字符串、symbol、node和element (2) 如果该属性既可以是string，也可以是number，可以用oneOfType，即 ​ content: PropTypes.oneOfType([PropTypes.string, PropTypes.number]) ​ 参考网站：https://reactjs.org/docs/typechecking-with-proptypes.html 4-3 props, state和render函数的关系 当组件的state或props发生改变时，render函数就会重新执行； 当父组件的render函数被运行时，它的所有子组件的render函数都将被重新运行一次 4-4 react中的虚拟dom-以下为react底层真正的实现 所以，虚拟DOM是什么？ ​ 本质上它就是个JS对象，它之所以能提高性能，本质上是因为在JS里比较JS对象不怎么耗性能，但是比较真实的DOM很耗性能。 4-5 深入了解虚拟dom 在渲染JSX模板时，会经历JSX模板-&gt;createElement方法-&gt;虚拟DOM(JS对象)-&gt;真实的DOM 虚拟DOM的优点： 性能提升了 – DOM的比对变成了JS对象的比对 它使得跨端应用得以实现 – React Native (回头反复看) 4-6 虚拟dom中的diff算法 在4-4的第7步中当state或props改变后，比较原始虚拟DOM和新的虚拟DOM的差异，就叫做Diff算法 setState之所以要异步，就是可以把多次setState结合成一次，减少虚拟DOM比对的次数 React的虚拟DOM是同层比对的，如果一层不满足匹配的要求，下面就不会再比对了，直接用新的替换掉老的，提升性能 循环中之所以要求有key值，就是提高虚拟DOM比对的性能，尽量不要用index做key值，可以用item 4-7 react中ref的使用 ref能代替e.target，但react中尽量不要来操作DOM ref与setState合用时会有问题，解决办法就是要把ref获取DOM的方法放到setState回调函数里执行： 4-8 react的生命周期函数 概念 生命周期函数是指在某一个时刻组件会自动调用执行的函数 详细讲解 Initialization初始化过程 初始化数据state和props，具体是在constructor中： Mounting挂载过程 当组件第一次被挂载到页面中，会有三个生命周期函数： (1) componentWillMount ​ 当组件即将被挂载到页面的时刻自动执行 (2) render ​ 挂载页面；但是在state和props改变时，render还会自动执行 (3) componentDidMount ​ 组件被挂载到页面之后自动执行 Updating组件更新过程 当props或states改变时，有以下四个共同的生命周期函数： (1) shouldComponentUpdate ​ 组件被更新之前自动执行，该组件必须返回布尔值，否则会报错； ​ 返回true组件会被更新，返回false组件将不会被更新； ​ 此函数会在render之前执行。 (2) componentWillUpdate ​ 组件被更新之前会自动执行，但是它在shouldComponentUpdate之后执行； ​ 如果shouldComponentUpdate返回true，它才会被执行，返回false，就不会执行。 (3) render ​ props或states更新时，重新渲染虚拟DOM和真实DOM，更新页面 (4) componentDidUpdate ​ 组件更新完成后被自动执行 当props改变时，会先经历一个独有的生命周期： componentWillReceiveProps 当一个子组件从父组件接收了参数，只要父组件的render函数被重新执行了，它就会被执行，即如果该子组件第一次存在于父组件中，不会执行，但如果该子组件之前已经存在于父组件中，才会执行 Unmounting把组件从页面去除的过程 componentWillUnmount 当这个组件即将被从页面中剔除的时候自动执行 4-9 react生命周期函数的使用场景 除了render函数，其他生命周期函数都可以不存在，因为组件继承自React.Component，它里面默认内置了其他所有生命周期函数，唯独没有render函数。 shouldComponentUpdate的应用场景 因为父组件render函数发生改变，子组件也会重新render，这会大大影响性能，可以在子组件中用shouldComponentUpdate函数进行限制： 总结React中提升性能的做法： 方法改变作用域，在constructor中操作，这样可以保证整个函数中的作用域绑定只会执行一次，而且可以避免子组件的一些无谓渲染。 setState方法内置了性能提升的机制，它是个异步的函数，可以把多次数据的改变结合成一次做，降低了虚拟DOM的比对频率。 React底层用虚拟DOM的概念、同层比对和key值，来提升虚拟DOM比对的速度。 借助shouldComponentUpdate函数避免无谓的组件的render函数的运行。 在componentDidMount函数中发送ajax异步请求，绝对不能放在render函数中，因为componentDidMount只在组件被挂载到页面后执行一次，之后便不再重新执行了； 不在componentWillMount中发送请求，是因为它可能会和React的更高端的技术产生冲突。 axios发送异步请求 安装 $ npm install axios –S 然后重启服务 使用 4-10 使用charles实现本地数据mock (模拟) 它是中间的代理服务器，能够抓到浏览器的请求。 下载安装 https://www.charlesproxy.com/latest-release/download.do 配置步骤 工具栏tools Map Local 点击Add 配置 点击choose选择某个目录下的xxx.json文件 点击OK，即可在页面中使用‘/api/todolist‘接口了 调接口 4-11 react中实现css过渡动画 4-12 react中使用css动画效果 4-13 使用react-transition-group实现动画 github地址：https://github.com/reactjs/react-transition-group 安装 $ npm install react-transition-group --save CSSTransition 先引入 包裹在要动画的元素外，必须要设置以下属性： in对应要改变的数据，才能向行间增加样式 timeout动画要执行多久 classNames定义样式名前缀 unmountOnExit当fade-exit后会把dom移除 钩子函数onEnter, onEntering, onEntered, onExit, onExiting, onExited。例如： 定义样式 入场动画： (1) .fade-enter 刚要入场但尚未入场时 (2) .fade-enter-active 从入场动画执行的第二个时刻到入场动画执行完成之前的阶段 (3) .fade-enter-done 当整个入场动画执行完成后 出场动画 (1) .fade-exit 出场动画执行的第一个时刻 (2) .fade-exit-active 出场动画执行的过程 (3) .fade-exit-done 当整个出场动画执行完成后 怎么使页面刚加载时就执行一遍动画呢？ 需要引用属性appear={true}，并设置相应的样式 当使用CSSTransition实现不了某个动画时，可以查下Transition，基本能实现需求： https://reactcommunity.org/react-transition-group/transition 4-14 使用react-transition-group实现多个元素间的动画效果TransitionGroup和CSSTransition配合使用： TransitionGroup写在所以的React组件外部，而CSSTransition写在具体的某个React组件或元素的外部，对一个元素或组件进行动画效果的管理。 注意CSSTransition中的属性in就不需要了。 第5章 redux入门5-1 redux概念简述 Redux把组件中的数据放到一个公用的存储区域store里存储，该组件改变数据，其他组件会感知到store里的数据改变，然后就能取到改变后的数据。 Redux = Reducer + Flux Flux是官方推出的最原始的辅助React使用的数据层框架，缺点：数据存储区域store有很多个，可能在存储时存在数据依赖问题。 5-2 redux的工作流程Redux Flow React Components指页面上的每个组件 Store指存储数据的公共区域 举例：这是个图书馆，React Components代表每一个借书的用户；用户对管理员说‘要借什么书’这句话，这就是Action Creators；Store就是指管理员；管理要从他的记录本查你这本书，这个记录本就是Reducers；记录本就告诉了管理员那本书在哪，管理员找到后就把书借给了用户。 5-3 使用ant-design实现todolist页面布局 antd地址：https://ant.design/docs/react/introduce-cn 安装 $ npm install antd –save 重启 使用 5-4 创建redux中的store 安装redux $ npm install redux --save 使用的步骤： 创建‘笔记本’store/reducer.js，导出的必须是函数 在src下新建store/index.js，引入redux中的createStore方法，并把‘笔记本或仓库’中的记录传给store，此时store已经完整的存在了 组件连接store，并从中取用数据 5-5 action和reducer的编写 redux开发者工具的安装与配置 使用shadowsocks翻墙 在chrome网上应用商店找到redux devtools安装 在调试栏打开redux选项，提示No store found，需要进一步配置store/index.js window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__() 配置完成后，呈现这样的面板 改变页面input框数据，怎样才能改变store中的数据呢？ 前提条件是当input中数据改变时，才改变store中的数据 把action当作‘借书人对管理员说的那句话’，创建action 把‘这句话’即action传给store store会自动拿着当前state的数据和当前的action去‘查手册’，即传给reducer，所以reducer能接收到以下的state和action 所以，这里的state指store里上一次存储的数据，action指用户传过来的‘那句话’ reducer根据action的type，先深拷贝state，再把其中的inputValue改成新传来的action中的value，最后把新的state即newState返回给store (1) reducer可以接收state，但不能直接修改state (2) 注意不符合条件时要返回state，否则会严重报错 组件根据store中的新数据进行更新，先订阅store，即只要store里数据发生改变，subscribe订阅的函数就会自动执行，在该函数中就可以先调用getState方法从store中重新取数据，然后用setState替换掉当前组件中的数据 小栗：点击提交，列表新增数据，巧妙地运用store中数据 5-6 使用redux完成todolist的删除功能 5-7 action-types的拆分 在store中新建actionTypes文件，定义常量，并在相应文件中使用。 拆分的意义： 定义成actionTypes常量，如果在使用时写错，工作台会有报错，但普通字符串就看不出来报错。 5-8 使用action-creator统一创建action优点：便于维护、便于自动化测试。 5-9 redux知识点复习补充 Redux设计和使用的三项原则 store是唯一的 只有store能够改变自己的内容 Reducer必须是纯函数，纯函数指的是，给定固定的输入，就一定会有固定的输出，而且不会有任何副作用。 换言之： (1) 如果函数中有日期函数、ajax请求或setTimeout等，就不是纯函数。 (2) 纯函数绝不能直接对参数做出修改。 Redux的核心API createStore创建store store.dispatch方法：派发action，这个action会传递给store store.getState方法：获取store中所有的数据内容 store.subscribe方法：订阅store的改变，只要store发生改变，该函数接收的回调函数就会被执行 第6章 redux进阶6-1 ui组件和容器组件 UI组件负责页面的渲染 容器组件负责页面的逻辑，即不管里面有多少UI组件，它只管处理逻辑 6-2 无状态组件当一个组件只有一个render函数，没有其他东西时如TodoListUi组件，就可以用无状态组件来定义它，所以TodoListUi组件可以改写成： 无状态组件比普通组件性能更好，建议当UI组件只有render函数时，将其定义成无状态组件。 6-3 redux中发送异步请求获取数据 Step1: 用charles工具配置接口 Step2: 在TodoList.js中通过axios调用该接口 Step3: 因为要修改store中数据，所以先在actionCreators.js中定义方法，返回action Step4: 回到TodoList.js，在请求回调中dispatch该action Step5: 在reducer.js中用action中新数据替换旧的已被克隆的state，并返回state 6-4 什么是redux的中间件 未完待续……","categories":[{"name":"React","slug":"React","permalink":"https://scarlett9354.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://scarlett9354.github.io/tags/React/"},{"name":"React16.4","slug":"React16-4","permalink":"https://scarlett9354.github.io/tags/React16-4/"}]},{"title":"vue2.0学习笔记","slug":"vue2-0学习笔记","date":"2021-05-08T02:13:20.000Z","updated":"2021-05-10T07:44:38.713Z","comments":true,"path":"2021/05/08/vue2-0学习笔记/","link":"","permalink":"https://scarlett9354.github.io/2021/05/08/vue2-0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"第一章 1丨优点 2丨功能 3丨课程包含 4丨vuejs简介 5丨vuejs学习资源 6丨vuejs的特点 7丨vuejs的实例对象 8丨vuejs的组件 9丨vue的基本概念 第二章 1丨基本结构 2丨列表渲染v-for 数组丨对象丨子组件 3丨列表数据的同步更新方法 4丨vue标签属性和条件渲染 5丨事件绑定 6丨计算属性computed和数据监听watch 第三章 深入vue组件 part1 组件 1丨组件基础 2丨组件之间的通信 3丨动态组件 4丨总结 part2 vuejs的高级功能 1丨过渡或动画 2丨自定义指令 3丨插件 4丨单文件组件和vue-cli 5丨es6语法 6丨vue-router 7丨vuex-状态管理插件 (原理) 补充知识点 第一章1丨优点轻量级、高效率、上手快、简单易学、文档全面而简洁 2丨功能 模板渲染 模块化 扩展功能：路由、Ajax 3丨课程包含 Vue实例 Vue组件 Vue指令 内置组件 实例方法 实例选项 实例属性 模板渲染 条件渲染 组件交互 标签属性 事件绑定 计算属性 属性监听 表单 动画 vue-cli项目搭建 Vue-router理由：实现单页面切换 vuex 4丨vuejs简介 轻量级的前端界面框架 2016.10发布最新2.0版本，更强大，更快速 主要包括： 数据渲染/数据同步 组件化/模块化 其他功能：路由、ajax、数据流 5丨vuejs学习资源 6丨vuejs的特点 双向数据绑定 组件化/模块化 单文件组件 - js、css、html存在于一个.vue文件内 通过什么实现呢？ （1）webpack+vue-loader （2）Browserify+vueify 单文件组件的优点： （1）可以在一个文件里编辑html、css和js （2）&lt;style scoped&gt;&lt;/style&gt;样式上的scoped属性规定了该样式的作用域，防止污染到其他组件 （3）可以定义语言，如：&lt;template lang=&quot;jade&quot;&gt;&lt;/template&gt;预加载器和&lt;style lang=&quot;less&quot;&gt;&lt;/style&gt;预处理器 （4）可以使用webpack打包工具，利用它的功能 7丨vuejs的实例对象 概念：当项目引入vue.js后，在全局里会有个js的vue的类，通过vue类来实例化的对象就是vue实例对象。通过关键字new Vue()实例。 选项 el - 决定该vue实例装载到页面的什么位置 模板template - 装载的东西，是指包含指令或html的一个片段，如：template: &#39;&lt;div&gt;&lt;other-component&gt;&lt;/div&gt;&#39; 数据data - data中的数据会被代理到实例对象里，如： 123data: &#123; fruit: &#x27;apple&#x27;&#125; 可以通过vm.fruit访问代理到的内容 也可以将data中的数据渲染到template中，如：template: &#39;&lt;div&gt;&#123;&#123; fruit &#125;&#125;&lt;/div&gt;&#39; 组件component - 引入其他子组件，如：component: &#123;App&#125; 实际项目中如何使用组件和组件间如何引入 通常一个项目里，我们可以在main.js或入口的js中首先实例化一个根组件，把这个根组件挂载到某个容器中，然后引入第一个子组件App，当然App中也会有其他的组件，比如header、sidebar、footer等，我们的每个页面也是以同样的方式引入到App这样的组件里，然后一层层树状结构，形成一个组件树。 生命周期 Vue的一个组件或者vue的一个实例化对象在不同的阶段，vue.js提供了不同的钩子，我们通过这些钩子在特定的阶段执行特定的操作。 钩子函数包括： （1）beforeCreate – 实例刚刚创建的时候 （2）created – 初始化完成这样的一个事件 （3）beforeMount – 渲染的时候 （4）mounted – 渲染完毕 （5）beforeDestory &amp; destoryed – 调用摧毁方法 8丨vuejs的组件如何实现vue.js的根组件及组件之间的相互关系？ 通过vue的脚手架工具生成项目 在main.js中通过es6语法引入vue的一个库并赋予Vue这个变量： 123import Vue from &#x27;vue&#x27;;// &#x27;vue&#x27; — vue库或模块// Vue — 变量 实例化根组件并进行数据渲染 先关注main.js和index.html：在main.js中 123456789import Vue from &#x27;vue&#x27;/* eslint-disable no-new */new Vue(&#123; el: &#x27;#app&#x27;, template: &#x27;&lt;p&gt;hello world &#123;&#123; word &#125;&#125;&lt;/p&gt;&#x27;, data: &#123; word: &#x27;hello world&#x27; &#125;&#125;) Vue是自底向上增量开发 组件注册与引入 – 实现组件树 通过Vue.component(&#39;组件名&#39;, &#123;组件对象，含有参数template&#125;)方法注册全局组件，此处的组件对象相当于new Vue方法，涉及到一个“语法糖”功能。 注册全局组件 123Vue.component(&#x27;my-header&#x27;, &#123; template: &#x27;&lt;p&gt;this is my header&lt;/p&gt;&#x27;&#125;) 123&lt;div id=&quot;app&quot;&gt; &lt;my-header&gt;&lt;/my-header&gt; &lt;/div&gt; 注册局部组件、子孙组件构成组件树 1234567891011121314151617181920// 孙组件var myHeaderChild = &#123; template: &#x27;&lt;p&gt;this is my header child&lt;/p&gt;&#x27;&#125;// 子组件var myHeader = &#123; template: &#x27;&lt;p&gt;&lt;my-header-child&gt;&lt;/my-header-child&gt;this is my header&lt;/p&gt;&#x27;, components: &#123; &#x27;my-header-child&#x27;: myHeaderChild &#125;&#125;new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; word: &#x27;hello world&#x27; &#125;, components: &#123; &#x27;my-header&#x27;: myHeader &#125;&#125;) 123&lt;div id=&quot;app&quot;&gt; &lt;my-header&gt;&lt;/my-header&gt; &lt;/div&gt; 局部组件my-header只能在#app中使用。 实际项目中在components文件夹中存放组件，跟它同级的App.vue引入不同的component，在导出pages的时候使用components来引入其它component就非常清晰。 避免data引用赋值 如果直接给组件的data赋一些值，这样做如果有多个组件用到这个data，其中一个通过事件改变data后，另一些组件中的data也会发生改变，采用return方法返回所需要的数据可避免这种情况。 123456789101112var myHeader = &#123; template: &#x27;&lt;p&gt;&lt;my-header-child&gt;&lt;/my-header-child&gt;this is my header&lt;/p&gt;&#x27;, components: &#123; &#x27;my-header-child&#x27;: myHeaderChild &#125;, data () &#123; return &#123; f1: 0, f2: 2 &#125; &#125;&#125; 9丨vue的基本概念 全局api – vue的实例对象提供的全局方法 Vue.extend(options) – 用于扩展vue的构造器 Vue.set(object, key, value) – 是给全局vue设置属性的一个方法 Vue.component(id, [definition]) – 添加全局组件 Vue.use(plugin) – 通过它来注册类似vue router、vuex之类的插件 实例选项 Data–与数据相关： （1）data （2）computed – 计算属性值 （3）props （4）methods （5）watch 与DOM相关的： （1）el （2）template （3）render – 方法 Lifecycle Hooks – 生命周期的钩子 Assets （1）directives – 输入指令 （2）filters – 过滤器 （3）components Misc – 合集的一些选项 （1）extends （2）functional 实例属性/方法 – 以$开头，直接从实例对象调用：root.$data/ root.$on 123456789101112131415var root = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; word: &#x27;hello world&#x27; &#125;, components: &#123; &#x27;my-header&#x27;: myHeader &#125;&#125;)// 属性&amp;方法console.log(root.$data)root.$on(&#x27;emit&#x27;, function () &#123; alert(1)&#125;) 指令 – 写在模板里，通过模板与组件的数据进行交互的方法，有时这个指令还包含参数，如v-on:事件 v-html – 将数据渲染到元素内部 与v-text的区别：前者渲染出的是DOM元素，后者渲染成字符串文本 &#123;&#123;msg&#125;&#125;与v-text类似，双花括号里可以是一元js表达式 12345678910111213141516171819&lt;template&gt; &lt;div&gt; &lt;p v-text&#x3D;&quot;hello&quot;&gt;&lt;&#x2F;p&gt; &lt;p v-html&#x3D;&quot;hello&quot;&gt;&lt;&#x2F;p&gt; &#123;&#123; hello &#125;&#125; &#123;&#123; status ? &#39;success&#39; : &#39;fail&#39; &#125;&#125; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; hello: &#39;&lt;span&gt;world&lt;&#x2F;span&gt;&#39;, status: true &#125; &#125;&#125;&lt;&#x2F;script&gt; v-on:事件 缩写@:事件 有时会与修饰器“.”结合 构成v-on:参数.修饰器 123456789101112var myHeader = &#123; template: &#x27;&lt;p v-html=&quot;&quot; v-on:click=&quot;&quot; v-on:keydown.enter=&quot;&quot;&gt;&lt;my-header-child&gt;&lt;/my-header-child&gt;this is my header&lt;/p&gt;&#x27;, components: &#123; &#x27;my-header-child&#x27;: myHeaderChild &#125;, data () &#123; return &#123; f1: 0, f2: 2 &#125; &#125;&#125; 常用的修饰器有： （1）.stop 阻止冒泡 （2）.prevent （3）.capture （4）.self （5）.&#123;keyCode | keyAlias&#125; – 如：.enter （6）.native v-if v-for – （详细介绍参见第二章第二项） 内置组件 – 不是自己注册的，而是vue自带的组件 &lt;component&gt;&lt;/component&gt; 它身上包含:is方法，通过此方法将变量传进去来指定这个组件是个什么样的组件。 &lt;router-view&gt;&lt;/router-view&gt; 是路由提供的内置组件 &lt;keep-alive&gt;&lt;/keep-alive&gt; 可以通过它来将上面的router组件进行缓存，即在进行切换的时候，router-view里的内容只要被访问过的就会被缓存起来。 123456789101112var myHeader = &#123; template: &#x27;&lt;p v-html=&quot;&quot; v-on:click=&quot;&quot; v-on:keydown.enter=&quot;&quot;&gt; &lt;component :is=&quot;&quot;&gt;&lt;/component&gt; this is my header&lt;/p&gt; &lt;keep-alive&gt;&lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;&#x27;, components: &#123; &#x27;my-header-child&#x27;: myHeaderChild &#125;, data () &#123; return &#123; f1: 0, f2: 2 &#125; &#125;&#125; &lt;transition&gt;&lt;/transition&gt; 动画组件 第二章1丨基本结构 在index.html中写下div，并赋予id 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;vue2.0&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 在main.js中通过import引入vue模块（每个项目必引）和相应的组件模块如App.vue 12345678import Vue from &#x27;vue&#x27;import App from &#x27;./App&#x27;/* eslint-disable no-new */new Vue(&#123; el: &#x27;#app&#x27;, render: h =&gt; h(App)&#125;) 在App.vue中定义template、script、style三部分，在script中使用export导出要显示的页面 123456789101112131415161718192021222324&lt;template&gt; &lt;div&gt;&#123;&#123; hello &#125;&#125;&lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; hello: &#39;world&#39; &#125; &#125;&#125;&lt;&#x2F;script&gt;&lt;style&gt; #app &#123; font-family: &#39;Avenir&#39;, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; &#125;&lt;&#x2F;style&gt; 2丨列表渲染v-for 数组丨对象丨子组件 v-for指令实现列表循环 – 数组形式 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;li v-for&#x3D;&quot;item in lists&quot;&gt;&#123;&#123;item.name&#125;&#125;的价格是&#123;&#123;item.price&#125;&#125;元&lt;&#x2F;li&gt; &lt;!--或采用v-text指令：--&gt; &lt;li v-for&#x3D;&quot;item in lists&quot; v-text&#x3D;&quot;item.name + &#39;---&#39; + item.price&quot;&gt;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; lists: [ &#123; name: &#39;apple&#39;, price: 34 &#125;, &#123; name: &#39;banana&#39;, price: 56 &#125; ] &#125; &#125;&#125;&lt;&#x2F;script&gt; 需要注意的是，v-for指令应加在要循环的那一项上面，而不是它的父级。 此外，也可以声明每一项的index 1&lt;li v-for&#x3D;&quot;(item, index) in lists&quot; :class&#x3D;&quot;&#123;odd: index % 2&#125;&quot;&gt;&#123;&#123; index &#125;&#125;-&#123;&#123; item.name &#125;&#125;的价格是&#123;&#123; item.price &#125;&#125;元&lt;&#x2F;li&gt; 注：此处的:class的值如果是对象，一定别忘记写花括号。 v-for指令实现列表循环 – 对象形式 1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;!-- &lt;li v-for&#x3D;&quot;value in listObj&quot;&gt;&#123;&#123; value &#125;&#125;&lt;&#x2F;li&gt; --&gt; &lt;!--或：--&gt; &lt;li v-for&#x3D;&quot;(value, key) in listObj&quot;&gt;&#123;&#123; key + value&#125;&#125;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; listObj: &#123; name: &#39;apple&#39;, price: 34, weight: &#39;100g&#39; &#125; &#125; &#125;&#125;&lt;&#x2F;script&gt; 注：这里的v-for指令中必须用key、value in obj，与数组的item(不是定死的)和index in arr相对应。 组件之间的相互引用及列表循环之子组件间的渲染 组件间的相互引用 (1) 第一步：在script中的export前先把组件引进来 1234&lt;script&gt; import componentA from &#39;.&#x2F;components&#x2F;a&#39; export default &#123;&#125;&lt;&#x2F;script&gt; 注：此处的componentA代表这个a.vue，在其他组件中直接用 (2) 第二步：注册 – 通过components选项注册到当前组件里 123456export default &#123; components: &#123;componentA&#125;, data () &#123; return &#123; &#125; &#125;&#125; (3) 第三步：使用、渲染 – 将组件componentA的template渲染到当前的组件的template中 12345&lt;template&gt; &lt;div&gt; &lt;component-a&gt;&lt;&#x2F;component-a&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt; 列表循环之子组件间的渲染 只需要在template中的componetA组件上添加v-for指令即可： &lt;componentA v-for=&quot;(value, key) in listObj&quot; :key=&quot;key&quot;&gt;&lt;/componentA&gt; 组件渲染的意义： 可以动态的将父组件的数据传给子组件componentA，如上例中通过绑定属性key，然后子组件a.vue中可以拿到传过来的值进行使用。 3丨列表数据的同步更新方法 methods 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;li v-for&#x3D;&quot;item in list&quot;&gt;&#123;&#123; item.name &#125;&#125; -- &#123;&#123;item.price&#125;&#125;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;button @click&#x3D;&quot;addItem&quot;&gt;addItem&lt;&#x2F;button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; list: [ &#123; name: &#39;apple&#39;, price: 34 &#125;, &#123; name: &#39;banana&#39;, price: 56 &#125; ] &#125; &#125;, methods: &#123; addItem () &#123; this.list.push(&#123;name: &#39;pineapple&#39;, price: 78&#125;) &#125; &#125;&#125;&lt;&#x2F;script&gt; 此处的逻辑是点击按钮，向列表中添加一项。 数组中并不是所有的方法都能触发列表的更新，下面的这些方法可以触发： push() 在后面添加一项 pop() 从后面删除一项 shift() 在前面添加一项 unshift() 从前面删除一项 splice() 删除或替换一项 sort() 排序 reverse() 反转 这些方法或情形不会触发列表更新： filter() 过滤 concat() 拼接数组 slice() 切割数组 两种情形： 直接为其中某一项赋值，如vm.items[indexOfItem] = newValue 所以下例这种情况不生效： 12345678methods: &#123; addItem () &#123; this.list[1] = &#123; name: &#x27;pineapple&#x27;, price: 78 &#125; &#125;&#125; 如果硬要改变第1项实现列表数据更新，就要借助Vue.set()方法： 1234567methods: &#123; addItem () &#123; Vue.set(this.list, 1, &#123; name: &#x27;pineapple&#x27;, price: 78 &#125;)&#125;&#125; 其中第一个参数是数组本身，第二个是要被改变的那项的index，第三项是改变成什么。 但在使用Vue的set方法前，需要在该组件中引入Vue组件，否则会报错 1234&lt;script&gt; import Vue from &#39;Vue&#39; export ...&lt;&#x2F;script&gt; 改变数组的长度，如vm.items.length = newLength 4丨vue标签属性和条件渲染 通过v-bind:参数名 = &quot;数据&quot; 进行动态绑定标签属性，当数据被修改后，该属性对应的数据在页面也会同步更新。 1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;a :href&#x3D;&quot;link&quot; :title&#x3D;&quot;hello&quot;&gt;to baidu&lt;&#x2F;a&gt; &lt;componentA :dataA &#x3D; &quot;dataA&quot;&gt;&lt;&#x2F;componentA&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; hello: &#39;world&#39;, link: &#39;http:&#x2F;&#x2F;www.baidu.com&#39;, dataA: 112 &#125; &#125;&#125;&lt;&#x2F;script&gt; 使用v-bind绑定的是个变量，不使用v-bind绑定的属性就只是个字符串。 如：&lt;a class=&quot;link-href&quot; :class=&quot;classStr&quot;&gt;to baidu&lt;/a&gt; 这里的两个class不会冲突。 :class延伸：class属性的几种添加方式 (1) 字符串形式：如上例 (2) 对象形式：如果class绑定的是一个对象，就可以根据对象的值进行判断是否展示该对象的属性作为class。如： 123456789&lt;a class=&quot;link-href&quot; :class=&quot;classObj&quot;&gt;点我啊&lt;/a&gt;data () &#123; return &#123; classObj: &#123; &#x27;red-font&#x27;: true, &#x27;blue-font&#x27;: false &#125; &#125;&#125; (3) 数组形式： 123456&lt;a class=&quot;link-href&quot; :class=&quot;classArr&quot;&gt;再点我啊&lt;/a&gt;data () &#123; return &#123; classArr: [&#x27;red-font&#x27;, &#x27;blue-font&#x27;] &#125;&#125; PS：以上三种形式都可以直接写到行间。 (4) 数组、对象混用 1234567&lt;a class=&quot;link-href&quot; :class=&quot;[classA, &#123;&#x27;red-font&#x27;: hasError&#125;]&quot;&gt;第三次点击&lt;/a&gt;data () &#123; return &#123; classA: &#x27;blue-font&#x27;, hasError: true &#125;&#125; 也可以通过:style内联样式将样式展示到标签上： 123456789&lt;a :style=&quot;styleCss&quot;&gt;测试内联样式&lt;/a&gt;data () &#123; return &#123; styleCss: &#123; color: &#x27;red&#x27;, &#x27;font-size&#x27;: &#x27;30px&#x27; &#125; &#125;&#125; 这时，可以在js中如methods中对this.styleCss进行操作来改变a标签的样式。 如果v-bind属性绑定到子组件标签componentA上，那么在子组件内部a.vue中也可以使用该属性。 条件渲染之v-if、v-show 123456789101112131415161718192021&lt;template&gt; &lt;div&gt; &lt;p v-if&#x3D;&quot;isPartA&quot;&gt;partA&lt;&#x2F;p&gt; &lt;p v-show&#x3D;&quot;!isPartA&quot;&gt;partB&lt;&#x2F;p&gt; &lt;button @click&#x3D;&quot;toggle&quot;&gt;toggle&lt;&#x2F;button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; isPartA: false &#125; &#125;, methods: &#123; toggle () &#123; this.isPartA &#x3D; !this.isPartA &#125; &#125;&#125;&lt;&#x2F;script&gt; v-if和v-show的区别： v-if在DOM元素中不存在，使用v-show时元素存在，只是加了个display=&quot;none&quot; 二者都可以配合v-else指令使用： 12&lt;p v-if=&quot;isPartA&quot;&gt;partA&lt;/p&gt;&lt;p v-else&gt;no data&lt;/p&gt; 5丨事件绑定 基本/内置的事件绑定通过v-on:参数或缩写@:绑定，有时后会用到修饰符“.” 自定义事件绑定 流程描述：在子组件中通过点击触发了自己的方法，这个方法 $emit发出一个自定义事件（可带参数），父组件监听这个自定义事件，并触发父组件自己的一个方法，这个方法就是要处理的结果，方法中传递参数，可访问到子组件中$emit发出的那个参数。 12345678910111213141516171819202122232425262728293031323334353637&lt;!--父组件App.vue中：--&gt;&lt;template&gt; &lt;comA @my-event&#x3D;&quot;onComaMyEvent&quot;&gt;&lt;&#x2F;comA&gt;&lt;&#x2F;template&gt;&lt;script&gt;import comA from &#39;.&#x2F;components&#x2F;a&#39;export default &#123; components: &#123;comA&#125;, data () &#123; return &#123; &#125; &#125;, methods: &#123; onComaMyEvent (paramFromA) &#123; console.log(&#39;onComaMyEvent&#39; + paramFromA) &#125; &#125;&#125;&lt;&#x2F;script&gt;&lt;!--子组件a.vue中：--&gt;&lt;template&gt; &lt;button @click&#x3D;&quot;emitMyEvent&quot;&gt;emit&lt;&#x2F;button&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; hello: &#39;I am a component A!&#39; &#125; &#125;, methods: &#123; emitMyEvent () &#123; this.$emit(&#39;my-event&#39;, this.hello) &#125; &#125;&#125;&lt;&#x2F;script&gt; 表单事件绑定 – 双向数据绑定（v-model） 普通的input框 123456789101112131415&lt;template&gt; &lt;div&gt; &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;myValue&quot;&gt; &lt;p&gt;&#123;&#123; myValue &#125;&#125;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; myValue: &#39;&#39; &#125; &#125;&#125;&lt;&#x2F;script&gt; 复选框 1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;input v-model&#x3D;&quot;myBox&quot; type&#x3D;&quot;checkbox&quot; value&#x3D;&quot;apple&quot;&gt; &lt;input v-model&#x3D;&quot;myBox&quot; type&#x3D;&quot;checkbox&quot; value&#x3D;&quot;banana&quot;&gt; &lt;input v-model&#x3D;&quot;myBox&quot; type&#x3D;&quot;checkbox&quot; value&#x3D;&quot;pineapple&quot;&gt; &lt;p&gt;&#123;&#123; myBox &#125;&#125;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; myBox: [] &#125; &#125;&#125;&lt;&#x2F;script&gt; 单选框 1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;input v-model&#x3D;&quot;myRadio&quot; type&#x3D;&quot;radio&quot; value&#x3D;&quot;apple&quot;&gt; &lt;input v-model&#x3D;&quot;myRadio&quot; type&#x3D;&quot;radio&quot; value&#x3D;&quot;banana&quot;&gt; &lt;input v-model&#x3D;&quot;myRadio&quot; type&#x3D;&quot;radio&quot; value&#x3D;&quot;pineapple&quot;&gt; &lt;p&gt;&#123;&#123; myRadio &#125;&#125;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; myRadio: &#39;&#39; &#125; &#125;&#125;&lt;&#x2F;script&gt; 下拉框 12345678910111213141516171819&lt;template&gt; &lt;div&gt; &lt;select name&#x3D;&quot;&quot; id&#x3D;&quot;&quot; v-model&#x3D;&quot;selection&quot;&gt; &lt;option value&#x3D;&quot;apple&quot;&gt;apple&lt;&#x2F;option&gt; &lt;option value&#x3D;&quot;banana&quot;&gt;banana&lt;&#x2F;option&gt; &lt;option value&#x3D;&quot;pineapple&quot;&gt;pineapple&lt;&#x2F;option&gt; &lt;&#x2F;select&gt; &lt;p&gt;&#123;&#123; selection &#125;&#125;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; selection: null &#125; &#125;&#125;&lt;&#x2F;script&gt; 上述的option可以通过v-for循环渲染 select标签及指令不变，只在option上v-for循环即可： 123456789101112131415&lt;option v-for&#x3D;&quot;item in selectObj&quot; :value&#x3D;&quot;item.id&quot;&gt;&#123;&#123; item.text&#125;&#125;&lt;&#x2F;option&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; selection: null, selectObj: [ &#123;id: 0, text: &#39;apple&#39;&#125;, &#123;id: 1, text: &#39;pineapple&#39;&#125;, &#123;id: 2, text: &#39;banana&#39;&#125; ] &#125; &#125;&#125;&lt;&#x2F;script&gt; 另外，也可以把select抽成组件如vSelect，上面也可以绑定自定义事件，并通过操作自定义事件和$emit来实现父子组件之间的通信。 v-model.lazy 懒加载 当输入框输完失去焦点后才进行双向数据绑定。 v-model.number转换数据类型 由string转为number 注意：字母和数字组合为NaN，数据类型也是number v-model.trim 裁剪空格，只是裁两端空格 6丨计算属性computed和数据监听watch 计算属性computed是个vue选项，通过computed、通过一个方法来return一个值，这个值可以使用data里面的数据，通过this来引用。会被缓存。 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;myValue&quot;&gt; &lt;p&gt;&#123;&#123; myValueWithoutNum &#125;&#125;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; myValue: &#39;&#39; &#125; &#125;, computed: &#123; myValueWithoutNum () &#123; return this.myValue.replace(&#x2F;\\d&#x2F;g, &#39;&#39;) &#125; &#125;&#125;&lt;&#x2F;script&gt; 也可以在methods通过方法myValueWithoutNum()来实现该功能。 二者的区别： 计算属性的更新只会根据另外一个值如myValue进行更新，假如myValue不再更新，那么myValueWithNum也不再更新。 而当我们调用方法里的myValueWithNum()时，无论何时调用，都会重新获取该myValue。 数据监听watch 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;li v-for&#x3D;&quot;item in myList&quot;&gt;&#123;&#123; item.text &#125;&#125;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; &lt;button @click&#x3D;&quot;changeList&quot;&gt;change&lt;&#x2F;button&gt;&lt;&#x2F;template&gt; &lt;&#x2F;div&gt;&lt;script&gt;import Vue from &#39;vue&#39;export default &#123; data () &#123; return &#123; myList: [ &#123;text: &#39;apple&#39;&#125;, &#123;text: &#39;banana&#39;&#125; ] &#125; &#125;, methods: &#123; changeList () &#123; Vue.set(this.myList, 1, &#123; text: &#39;pineapple&#39; &#125;) &#125;, tellUser () &#123; alert(&#39;will change！&#39;) &#125; &#125;, watch: &#123; myList () &#123; this.tellUser() &#125; &#125;&#125;&lt;&#x2F;script&gt; 适用场景：对列表进行更改，可以在watch里进行监听，只要更改就调用methods的某个方法。 第三章 深入vue组件part1 组件1丨组件基础 组件名、属性在template中最好把驼峰格式转成中线格式。 可以通过:is=&quot;&quot;方法在template中使用组件。 2丨组件之间的通信​ 主要有三种：属性、emit、slot插槽 ​ 父向子传 用props，即标签属性 父传子之静态属性传递 12345678910111213141516171819202122232425262728293031323334&lt;!--父组件App.vue中：--&gt;&lt;template&gt; &lt;div&gt; &lt;comp-a number-to-do &#x3D; 78&gt;&lt;&#x2F;comp-a&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import compA from &#39;.&#x2F;components&#x2F;a&#39;export default &#123; components: &#123; compA &#125;, data () &#123; return &#123;&#125; &#125;&#125;&lt;&#x2F;script&gt;&lt;!--子组件a.vue中：--&gt;&lt;template&gt; &lt;div&gt; &#123;&#123; hello &#125;&#125; &#123;&#123; numberToDo &#125;&#125; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; props: [&#39;number-to-do&#39;], data () &#123; return &#123; hello: &#39;I am a component A!&#39; &#125; &#125;&#125;&lt;&#x2F;script&gt; 注意以上三处加粗的代码的名字转换。 在子组件中通过props接收父组件传过来的数据，就相当于在自己的data中添加了该数据，在data中就不必重新定义。 props除了可以接收数组外，还可以接收对象，对象里可以定义接收的数据类型。 123456&lt;!--父组件中：--&gt;&lt;comp-a number-to-do&#x3D;78&gt;&lt;&#x2F;comp-a&gt; &lt;!--子组件中：--&gt;props: &#123; &#39;number-to-do&#39;: [Number, String]&#125;, 父组件中的78不管加不加引号，都是String类型，如果子组件中props未指定该类型，就会报错，指定了就不会。 父传子之动态属性传递 123456789101112131415161718192021222324252627282930313233343536373839&lt;!--父组件App.vue中：--&gt;&lt;template&gt; &lt;div&gt; &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;myVal&quot;&gt; &lt;comp-a :my-value&#x3D;&quot;myVal&quot;&gt;&lt;&#x2F;comp-a&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import compA from &#39;.&#x2F;components&#x2F;a&#39;export default &#123; components: &#123; compA &#125;, data () &#123; return &#123; myVal: &#39;&#39; &#125; &#125;&#125;&lt;&#x2F;script&gt;&lt;!--子组件a.vue中：--&gt;&lt;template&gt; &lt;div&gt; &#123;&#123; hello &#125;&#125; &#123;&#123; myValue &#125;&#125; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; props: &#123; &#39;my-value&#39;: [Number, String] &#125;, data () &#123; return &#123; hello: &#39;I am a component A!&#39; &#125; &#125;&#125;&lt;&#x2F;script&gt; 注意属性如:my-value、事件如@my-event只能用中划线，不能用驼峰方式。 父传子之插槽 如果父组件想向子组件插入一个模板标签元素，要借助&lt;slot&gt;标签。 12345678910111213141516&lt;!--父组件App.vue中：--&gt;&lt;template&gt; &lt;div&gt; &lt;comp-a :my-value&#x3D;&quot;myVal&quot;&gt; &lt;p&gt;123&lt;&#x2F;p&gt; &lt;&#x2F;comp-a&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;!--子组件a.vue中：--&gt;&lt;template&gt; &lt;div&gt; &#123;&#123; hello &#125;&#125; &#123;&#123; myValue &#125;&#125; &lt;slot&gt;&lt;&#x2F;slot&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt; 上例中就把父组件放到子组件标签中的p标签插到了子组件的slot位置。 插槽的便捷之处： (1) 常用场景： ​ 比如子组件&lt;comp-a&gt;是个dialog，标签里可以插入任何元素&lt;p&gt;、&lt;span&gt;之类的，这样就可以实现弹框内容不同了。 (2) 比如子组件&lt;comp-a&gt;中没有内容，可以在插槽&lt;slot&gt;标签中写内容，就会被显示，若子组件有内容，就只展示子组件的内容，而不展示插槽的。 关于具名slot – 可以知道不同部分的插入 1234567891011&lt;!--父组件中：--&gt;&lt;comp-a :my-value&#x3D;&quot;myVal&quot;&gt; &lt;p&gt;123&lt;&#x2F;p&gt; &lt;p slot&#x3D;&quot;header&quot;&gt;xxx header&lt;&#x2F;p&gt; &lt;p slot&#x3D;&quot;footer&quot;&gt;yyy footer&lt;&#x2F;p&gt;&lt;&#x2F;comp-a&gt;&lt;!--子组件中：--&gt;&lt;slot&gt;&lt;&#x2F;slot&gt;&lt;slot name&#x3D;&quot;header&quot;&gt;no header&lt;&#x2F;slot&gt;balabala&lt;slot name&#x3D;&quot;footer&quot;&gt;no footer&lt;&#x2F;slot&gt; 子向父传 用emit，即通过去触发一个事件，这个事件只有emit触发和on监听两种方法 使用emit和v-on:，参照第三章P16第五事件绑定。 3丨动态组件 通过:is=＂变量如：currentView＂，将某个组件渲染到某个位置，我们就可以通过currentView来载入不同的组件到那个位置。 常用场景： 比如tab切换，tab切换下面会展现不同的小组件，这个小组件由一个组件切换成另一个组件，所以我们只要在切换的方法中更新currentView就会将组件同步更新到相应的位置。 动态组件有些类似路由，换句话说&lt;router-view&gt;就相当于一个动态组件。 跟路由相似，动态组件也支持&lt;keep-alive&gt;内置标签，可以缓存组件，提高组件的加载速度。 12345678910111213141516&lt;template&gt; &lt;keep-alive&gt; &lt;p :is &#x3D; &quot;currentView&quot;&gt;&lt;&#x2F;p&gt; &lt;&#x2F;keep-alive&gt;&lt;&#x2F;template&gt;&lt;script&gt;import comA from &#39;.&#x2F;components&#x2F;a&#39;export default &#123; components: &#123;comA&#125;, data () &#123; return &#123; currentView: &#39;com-a&#39; &#125; &#125;&#125;&lt;&#x2F;script&gt; 加粗的com-a就是子组件变量，该子组件一定要先import再注册，否则就会报错。 4丨总结 part2 vuejs的高级功能1丨过渡或动画 css实现过渡 css阶段类名： 通过&lt;transition&gt;标签与v-show或v-if指令以及style样式配合，样式中一般都是opacity/transform样式： (1) 淡入淡出 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div&gt; &lt;button @click&#x3D;&quot;show &#x3D; !show&quot;&gt;toggle&lt;&#x2F;button&gt; &lt;div&gt; &lt;transition name&#x3D;&quot;fade&quot;&gt; &lt;p v-show&#x3D;&quot;show&quot;&gt;this is toggle show&lt;&#x2F;p&gt; &lt;&#x2F;transition&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; show: true &#125; &#125;&#125;&lt;&#x2F;script&gt;&lt;style&gt; .fade-enter, .fade-leave-active &#123; opacity: 0; &#125; .fade-enter-active, .fade-leave-active &#123; transition: all .5s ease-out; &#125;&lt;&#x2F;style&gt; style中的.fade-和&lt;transition&gt;标签的name是对应的。 (2) 自定义动画，如位移 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div&gt; &lt;button @click&#x3D;&quot;show &#x3D; !show&quot;&gt;toggle&lt;&#x2F;button&gt; &lt;div&gt; &lt;transition name&#x3D;&quot;my-trans&quot;&gt; &lt;p v-show&#x3D;&quot;show&quot;&gt;this is toggle show&lt;&#x2F;p&gt; &lt;&#x2F;transition&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;&#x2F;&#x2F; 同上&lt;&#x2F;script&gt;&lt;style&gt; .my-trans-enter-active, .my-trans-leave-active &#123; transition: all 1s ease-out; &#125; .my-trans-enter &#123; transform: translateY(-500px); opacity: 0; &#125; .my-trans-leave-active &#123; transform: translateY(500px); opacity: 0; &#125;&lt;&#x2F;style&gt; (3) 接受的过渡状态、多元素过渡 方式一 123456789101112131415161718192021222324252627282930313233343536373839&lt;template&gt; &lt;div&gt; &lt;button @click&#x3D;&quot;toggleCom&quot;&gt;toggle&lt;&#x2F;button&gt; &lt;transition name&#x3D;&quot;fade&quot; mode&#x3D;&quot;out-in&quot;&gt; &lt;div :is&#x3D;&quot;currentView&quot;&gt;&lt;&#x2F;div&gt; &lt;&#x2F;transition&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import comA from &#39;.&#x2F;components&#x2F;a&#39;import comB from &#39;.&#x2F;components&#x2F;b&#39;export default &#123; components: &#123;comA, comB&#125;, data () &#123; return &#123; currentView: &#39;com-b&#39; &#125; &#125;, methods: &#123; toggleCom () &#123; if (this.currentView &#x3D;&#x3D;&#x3D; &#39;com-a&#39;) &#123; this.currentView &#x3D; &#39;com-b&#39; &#125; else &#123; this.currentView &#x3D; &#39;com-a&#39; &#125; &#125; &#125;&#125;&lt;&#x2F;script&gt;&lt;style&gt; .fade-enter, .fade-leave-active &#123; opacity: 0; &#125; .fade-enter-active, .fade-leave-active &#123; transition: all .5s ease-out; &#125;&lt;&#x2F;style&gt; style中的.fade-和&lt;transition&gt;标签的name是对应的。 与直接用css过渡不同之处在于，标签上不用加v-show/v-if指令。 &lt;transition&gt;标签默认的mode为in-out即新的先进来旧的再出去，这样体验很不好，所以修改为out-in即旧的先出新的再进。 方式二 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div&gt; &lt;button @click&#x3D;&quot;show &#x3D; !show&quot;&gt;toggle&lt;&#x2F;button&gt; &lt;transition name&#x3D;&quot;fade&quot; mode&#x3D;&quot;out-in&quot;&gt; &lt;p v-if&#x3D;&quot;show&quot;&gt;I am show&lt;&#x2F;p&gt; &lt;div v-else&gt;I am not show&lt;&#x2F;div&gt; &lt;&#x2F;transition&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import comA from &#39;.&#x2F;components&#x2F;a&#39;import comB from &#39;.&#x2F;components&#x2F;b&#39;export default &#123; components: &#123;comA, comB&#125;, data () &#123; return &#123; currentView: &#39;com-b&#39;, show: true &#125; &#125;&#125;&lt;&#x2F;script&gt;&lt;style&gt; .fade-enter, .fade-leave-active &#123; opacity: 0; &#125; .fade-enter-active, .fade-leave-active &#123; transition: all .5s ease-out; &#125;&lt;&#x2F;style&gt; 在vue中如果&lt;transition&gt;中的两个元素是相同标签如都是&lt;p&gt;，则不会执行该动画，需要添加key区分两个标签，动画才能正常执行。 1234&lt;transition name&#x3D;&quot;fade&quot; mode&#x3D;&quot;out-in&quot;&gt; &lt;p v-if&#x3D;&quot;show&quot; key&#x3D;&quot;0&quot;&gt;I am show&lt;&#x2F;p&gt; &lt;p v-else key&#x3D;&quot;1&quot;&gt;not in show&lt;&#x2F;p&gt;&lt;&#x2F;transition&gt; JS过渡 同样也分为一些过渡阶段，与css过渡不同的是，js通过v-on来监听这些事件钩子。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;template&gt; &lt;div&gt; &lt;transition @before-enter&#x3D;&quot;beforeEnter&quot; @enter&#x3D;&quot;enter&quot; @leave&#x3D;&quot;leave&quot; :css&#x3D;&quot;false&quot;&gt; &lt;p class&#x3D;&quot;animate-p&quot; v-show&#x3D;&quot;show&quot;&gt;I am show&lt;&#x2F;p&gt; &lt;&#x2F;transition&gt; &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;button @click&#x3D;&quot;show &#x3D; !show&quot;&gt;toggle&lt;&#x2F;button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import $ from &#39;jquery&#39;export default &#123; data () &#123; return &#123; show: true &#125; &#125;, methods: &#123; beforeEnter (el) &#123; $(el).css(&#123; left: &#39;-500px&#39;, opacity: 1 &#125;) &#125;, enter (el, done) &#123; $(el).stop().animate(&#123; left: 0, opacity: 1 &#125;, &#123; duration: 1500, complete: done &#125;) &#125;, leave (el, done) &#123; $(el).stop().animate(&#123; left: &#39;500px&#39;, opacity: 0 &#125;, &#123; duration: 1500, complete: done &#125;) &#125; &#125;&#125;&lt;&#x2F;script&gt;&lt;style&gt; .animate-p &#123; position: absolute; left: 0; top: 0; &#125;&lt;&#x2F;style&gt; 注意： &lt;transition&gt;标签不需要name，但需要绑定属性:css=&quot;false&quot;,避免该标签去检查css中指定的选项。 每个方法其实都要操作传过来的参数el，这个el是&lt;transition&gt;体内的DOM元素。 其中的两个方法enter、leave除了参数el外，还有个done（必须调用），是在两个动作执行完了执行。 用js操作时可能需要用到jquery等公用库，最好把它在index.html中引入，因为那儿的代码不会经过打包和处理资源，只会作为一个入口的页面往里加东西。 扩展：如何在项目中引入jquery？ 在当前项目的目录下（就是package.json），运行命令$ cnpm install jquery --save-dev 这样就将jquery安装到了这个项目中。然后修改webpack.base.conf.js(在build文件下)两个地方： 小注：上面的–save是为了更新package.json，使得别人在用的时候也是更新后的。 加入 1var webpack=require(&#x27;webpack&#x27;); 在module.exports的里面加入 1234567plugins: [ new webpack.optimize.CommonsChunkPlugin(&#x27;common.js&#x27;), new webpack.ProvidePlugin(&#123; jQuery: &quot;jquery&quot;, $: &quot;jquery&quot; &#125;)] 最后在main.js中加入import $ from &#39;jquery&#39;,完成jquery的引入 2丨自定义指令通过选项directives定义如v-color指令，在directives指令选项中定义color函数，传el和binding两个参数，el就代表v-color指令所在的元素，binding是个对象，指它绑定的一些变量或计算表达式等，binding.value指的是指令接收到值。 局部指令 – 把该指令定义到普通组件的directives里 1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; &lt;p v-color&#x3D;&quot;&#39;red&#39;&quot;&gt;这是一个段落&lt;&#x2F;p&gt; &lt;p v-custom&#x3D;&quot;&#39;40px&#39;&quot;&gt;第二段&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; directives: &#123; color (el, binding) &#123; el.style.color &#x3D; binding.value &#125;, custom: &#123; bind (el, binding) &#123; &#125;, inserted (el, binding) &#123; el.style.fontSize &#x3D; binding.value &#125; &#125; &#125;&#125;&lt;&#x2F;script&gt; 全局指令 – 把该指令定义到main.js的根组件的directives里，定义方法同上 如上例中，color指令方法为合写，custom指令方法为分写，详细介绍参见下面： 自定义指令适用场景 实现该元素一插入到页面就获取焦点： 12345678910111213&lt;template&gt; &lt;input type&#x3D;&quot;text&quot; v-focus&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; directives: &#123; focus: &#123; inserted (el, binding) &#123; el.focus() &#125; &#125; &#125;&#125;&lt;&#x2F;script&gt; 3丨插件​ 功能完整的一套组件，独立于vue而存在的 例如vue-router，如何安装并引用呢？ 第一步，在当前项目的目录下（就是package.json），运行命令cnpm install vue-router --save 第二步，如果全局使用，就在main.js中import VueRouter from &#39;vue-router&#39;，等同于var VueRouter = require(&#39;vue-router&#39;) 第三步，注册使用该插件Vue.use(VueRouter) 第四步，实例化该插件let router = new VueRouter() 第五步，正式使用，在根组件中直接使用上面定义的router 以下为入口文件main.js： 1234567891011121314import Vue from &#x27;vue&#x27;import App from &#x27;./App&#x27;import VueRouter from &#x27;vue-router&#x27;// 注册Vue.use(VueRouter)// 实例化let router = new VueRouter()/* eslint-disable no-new */new Vue(&#123; router, // 正式使用 el: &#x27;#app&#x27;, render: h =&gt; h(App)&#125;) 例如vue-resource，它的安装同vue-router，在main.js中引入时直接注册即可，不需要实例化，这样在每个子组件的方法中都可以直接采用this.$http.get()方法。 更多插件详见https://github.com/vuejs 4丨单文件组件和vue-cli 单文件组件 概念：vue本身是通过vue-cli工具搭建成的，单文件组件是.vue文件，它把template、script和css都集中到一个文件里，实现组件及组件树。所有的组件都是个.vue文件，最终在main.js中将根组件App.vue拼装到页面里。 单文件组件的实现得益于vue-loader，配合webpack，经过一定的处理，最终把template和css插到组件里。 关于css: 在style标签上添加scoped，就限制该css为当前组件的样式，如果不加scoped，样式就会泄漏到全局，导致所有引入该组件的父组件也会接收到这样的样式。 vue-cli 用于初始化vue项目，是vue官方提供的一个脚手架工具。 使用vue-cli的优势： (1) 它是一套成熟的vue项目架构设计，会随着版本的更迭而更新（现为2.0） (2) 提供了一套本地的测试服务器 (3) 提供了一套自己的打包上线的方案webpack vue-cli对系统的要求 – 它是命令行的一个工具 (1) 系统必须装NodeJs（&gt;=4.0） (2) git 下载代码 (3) 一个能使用Node的命令行终端 使用流程（使用NodeJs的包管理工具）： (1) 全局安装vue-cli npm install vue-cli -g (2) 初始化项目 vue init webpack my-project 规定了使用webpack打包方式 (3) 安装项目依赖 npm install (4) 在localhost启动测试服务器 npm run dev ​ 或：生成上线目录（部署） npm run build (5) 缺少第五章项目安装等笔记 5丨es6语法 import、export 语法格式 12import 变量名 from &#x27;&#x27;export default &#123;&#125; export后面必须跟default，只有这样才可以直接import一个default的内容作为一个变量来引入当前文件。也可以引入或导出一个变量import/export {变量名}，但必须带花括号。 对象缩写 如 components: &#123;hello&#125; 区分var和let、const 用var在代码块中定义变量，在外面也能取到该变量，用let可避免这种泄露。 const用来声明常量，也可以避免泄露。 函数简写 如 data () &#123;&#125; 6丨vue-router 概念：根据不同的地址发到不同的页面 单页面应用：不用频繁地去请求服务器，我们只是通过ajax在切换的时候请求新数据，就实现了不需要刷新整个页面的功能 什么是前端路由？ 举例说明，当我们请求foo页面，展示其中一个页面，请求bar时展示另一个页面。 前端路由在由一个页面请求另一个页面时，公共的框架、css、js、环境之类的不再请求，只请求页面的不同之处。 设置路由 安装路由 cnpm install vue-router --save 在入口文件main.js中引入vue-router 1234567891011121314import Vue from &#x27;vue&#x27;import App from &#x27;./App&#x27;import VueRouter from &#x27;vue-router&#x27;// 注册Vue.use(VueRouter)// 实例化let router = new VueRouter()/* eslint-disable no-new */new Vue(&#123; router, // 正式使用 el: &#x27;#app&#x27;, render: h =&gt; h(App)&#125;) 使用vue-router有三个关键点： (1) 一份map ​ 规定什么样的地址访问什么样的页面或组件，在它上上级routes并列要加哈西mode: &#39;history&#39; — 路由map (2) router-view ​ 规定什么样的位置或什么样的区域显示不同的页面 — 路由视图 ​ 如何使用？ 第一步，提前写好两个组件apple.vue和banana.vue，并在main.js中引入组件： 12import Apple from &#x27;./components/apple&#x27;import Banana from &#x27;./components/banana&#x27; 第二步，在上述实例化中通过routes选项进行配置（映射关系）： 12345678910111213let router = new VueRouter(&#123; mode: &#x27;history&#x27;, routes: [ &#123; path: &#x27;/apple&#x27;, component: Apple &#125;, &#123; path: &#x27;/banana, component: Banana &#125; ]&#125;) 第三步，规定在路由里设定的组件在哪显示 —— 在App.vue的template中 123&lt;template&gt; &lt;router-view&gt;&lt;&#x2F;router-view&gt;&lt;&#x2F;template&gt; 第四步，访问地址分别为localhost:8080/#/apple和localhost:8080/#/banana，第二步中使用Mode哈西，地址中就不需要写#了。 (3) router-link ​ 在页面上如何跳转到下个页面 — 路由导航 ​ 使用&lt;router-link&gt;组件，要绑定:to属性 12345&lt;template&gt; &lt;router-view&gt;&lt;&#x2F;router-view&gt; &lt;router-link :to&#x3D;&quot;&#123;path: &#39;apple&#39;&#125;&quot;&gt;toApple&lt;&#x2F;router-link&gt; &lt;router-link :to&#x3D;&quot;&#123;path: &#39;banana&#39;&#125;&quot;&gt;banana&lt;&#x2F;router-link&gt;&lt;&#x2F;template&gt; 这个组件会默认渲染成一个a标签，to代表它的href 路由参数 我们原来的地址会加上?type=1&amp;mode=2之类的参数，vue-router要在映射表中加入参数： 12345678910111213let router = new VueRouter(&#123; mode: &#x27;history&#x27;, routes: [ &#123; path: &#x27;/apple/:color/detail/:type&#x27;, component: Apple &#125;, &#123; path: &#x27;/banana&#x27;, component: Banana &#125; ]&#125;) 上面的path中只有带引号的才是能被下面的$router.params获取的参数。 使用时，在地址中直接通过’/参数值’添加： localhost:8080/apple/red/detail/3 在组件如apple.vue内部如何获取刚设定的这个参数？ 设完参数以后，路由会往每个组件的全局的router对象里插入当前页面的params，我们在每个子组件里就可以通过this.**$route**这样的全局对象来获取当前路由的参数，获取到的是一个参数对象，如&#123;color:&#39;red&#39;, type: 3&#125;，或者在template用花括号直接访问如&#123;&#123;$route.params.color&#125;&#125;。 12345678910111213141516&lt;!--apple.vue中：--&gt;&lt;template&gt; &lt;div&gt; &lt;p&gt;&#123;&#123; $route.params.color &#125;&#125;&lt;&#x2F;p&gt; &lt;button @click&#x3D;&quot;getParam&quot;&gt;getParam&lt;&#x2F;button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; methods: &#123; getParam () &#123; console.log(this.$route.params) &#125; &#125;&#125;&lt;&#x2F;script&gt; 如果在映射表的path中设置了参数，但访问路径中不写这个参数，就找不到这个路由即访问不到相应的页面。 路由嵌套vue-touter 在映射表中接着写children，这个children对应的值也是个数组，同样也包含path和component两个属性，该子组件通过插入到父组件即apple.vue中，渲染出的页面同样会显示在apple.vue页面。 12345678910111213141516171819202122232425262728// main.js中路由映射表：// 先引入RedApple组件：import RedApple from &#x27;./components/redapple&#x27;let router = new VueRouter(&#123; mode: &#x27;history&#x27;, routes: [ &#123; path: &#x27;/apple&#x27;, component: Apple, children: [ path: &#x27;red&#x27;, component: RedApple ] &#125;, &#123; path: &#x27;/banana, component: Banana &#125; ]&#125;)// 该RedApple的父组件apple.vue中：&lt;template&gt; &#123;&#123;hello&#125;&#125; &lt;router-view&gt;&lt;/router-view&gt;&lt;/template&gt;export def...// 访问地址：localhost:8080/apple/red 同样我们在App.vue中也可以通过&lt;router-link :to=&quot;&#123;path:&#39;apple/red&#39;&#125;&quot;&gt;&lt;/router-link&gt;实现相同的路由嵌套。 命名的路由视图、路由重定向 在router-link的to属性的值有以下几种： (1) &lt;router-link :to=&quot;&#39;apple&#39;&quot;&gt;&lt;/router-link&gt; (2) &lt;router-link :to=&quot;&#123;path: &#39;apple/red&#39;&#125;&quot;&gt;&lt;/router-link&gt; (3) &lt;router-link :to=&quot;&#123;path: &#39;apple&#39;, param: &#123;color: &#39;yellow&#39;&#125;&#125;&quot;&gt;&lt;/router-link&gt; (4) 具名的路由 &lt;router-link :to=&quot;&#123;name: &#39;applePage&#39;&#125;&quot;&gt;&lt;/router-link&gt; (5) 由于router-link默认生成a标签，要生成其他标签如在ul中生成li，则需加个属性tag=&quot;li&quot; (6) router-link标签被点中之后会自动添加一个class=&quot;router-link-active&quot; 在组件template中的router-link这样的导航叫做声明式的导航。 我们也可以在main.js里采用router.push()方法进行编程式导航，其中push的内容和router-link的to所能指定的格式相同。 怎么使用呢？ 比如router.beforEach()方法指每次操作时都为它设定一些操作，此时我们可以进行一些异步操作，比如检查用户信息，如果是未登录状态，可以在回调里使用router.push()把页面导航到登录页。 router.beforEach(router.push(&#39;login&#39;)或router.push(&#123;path: &#39;login&#39;&#125;)或router.push(&#123;name: &#39;loginPage&#39;&#125;)) 命名的路由视图(第五章4-8 26分钟处） 给App.vue中的多个router-view标签命不同的名字，在main.js的映射表的component中给不同的视图指定不同的组件。 12345678910111213// App.vue中：&lt;router-view name=&quot;bananaA&quot;&gt;&lt;/router-view&gt;&lt;router-view name=&quot;bananaB&quot;&gt;&lt;/router-view&gt;// main.js中：routes: [ &#123; path: &#x27;/banana&#x27;, components: &#123; bananaA: Banana, bananaB: RedBanana &#125; &#125;] 路由重定向 在映射表中加一项，采用redirect属性将地址重定向到其他页面： 1234567891011121314// main.js中：routes: [ &#123; path: &#x27;/&#x27;, redirect: &#x27;/banana&#x27; &#125;, &#123; path: &#x27;/banana&#x27;, components: &#123; bananaA: Banana, bananaB: RedBanana &#125; &#125;] 使用过渡制作路由跳转动画 123456&lt;!--在App.vue中：--&gt;&lt;transition name&#x3D;&quot;fade&quot;&gt; &lt;keep-alive&gt; &lt;router-view&gt;&lt;&#x2F;router-view&gt; &lt;&#x2F;keep-alive&gt;&lt;&#x2F;transition&gt; 总结 路由map 路由视图 路由导航 路由参数 嵌套路由 命名路由和路由视图 重定向 7丨vuex-状态管理插件 (原理) 原理：有个统一的数据中心store，它用来维护状态数据，每个组件进行更新的时候就通知数据中心，数据中心再将共享的状态触发每个调用这个组件的更新。 flux模型 用来实现vuex的流程 vue的组件通过Actions这样一个动作来操作Mutations，Mutations控制数据中心的状态state，状态更改后再反映到页面组件的一个渲染render，下图中绿框虚线标的部分是vuex做的事情。 这个模型的设计含有很多规则，比如： （1）Actions去执行异步的操作，比如去后台调用API（Backend API） （2）Mutations是同步地去更改State数据的一种方法，它可以和Devtools交互 这套模型保证了数据的单项流动： Vue Components通过Dispatch这样的动作去触发Actions，Actions通过Commit去触发Mutations，Mutations直接操作数据。 只适用于复杂项目，也可以自己建造store，然后对外提供些事件接口及更新视图的方法。 vuex状态管理（实例） 安装vuex cnpm install vuex --save 然后重启服务器cnpm run dev 使用： 第一步，在main.js中引入插件vuex import Vuex from &#39;vuex&#39; 第二步，注册使用 Vue.use(Vuex) 第三步，实例化 12345678910111213let store = new Vuex.Store(&#123; state: &#123; totalPrice: 0 &#125;, mutations: &#123; increment (state, price) &#123; state.totalPrice += price &#125;, decrement (state, price) &#123; state.totalPrice -= price &#125; &#125;&#125;) 第四步，在根实例中引入store 123new Vue(&#123; store&#125;) 第五步，在App.vue中展示totalPrice 123&lt;template&gt; &#123;&#123; totalPrice &#125;&#125;&lt;&#x2F;template&gt; 此处的totalPrice为属性或方法，所以需要在script中定义 1234567891011121314&lt;script&gt;import Apple from &#39;.&#x2F;components&#x2F;apple&#39;export default &#123; components: &#123; Apple &#125;, computed: &#123; totalPrice () &#123; return this.$store.state.totalPrice &#x2F;&#x2F; 此处的totalPrice是刚才在main.js的store实例的state中定义的，和本页面的不一样 &#125; &#125;&#125;&lt;&#x2F;script&gt; 第六步，在子组件apple.vue中添加按钮并对totalPrice进行操作 123456789101112131415161718192021&lt;template&gt; &lt;div&gt; &lt;button @click&#x3D;&quot;add&quot;&gt;add 5&lt;button&gt; &lt;button @click&#x3D;&quot;minus&quot;&gt;minus 5&lt;&#x2F;button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; data () &#123; price: 5 &#125;, methods: &#123; add () &#123; this.$store.commit(&#39;increment&#39;, this.price) &#125;, minus () &#123; this.$store.commit(&#39;decrement&#39;, this.price) &#125; &#125;&#125;&lt;&#x2F;script&gt; 子组件中用$store.commit方法感觉和子组件向父组件传递事件类似用$emit方法，可一并记忆理解。 其中第三步和第六步可改为： 第三步，实例化 123456789101112131415161718192021let store = new Vuex.Store(&#123; state: &#123; totalPrice: 0 &#125;, mutations: &#123; increment (state, price) &#123; state.totalPrice += price &#125;, decrement (state, price) &#123; state.totalPrice -= price &#125; &#125;, actions: &#123; increase (context, price) &#123; context.commit(&#x27;increment&#x27;, price) &#125;, decrease (context, price) &#123; context.commit(&#x27;decrement&#x27;, price) &#125; &#125;&#125;) 第六步，在子组件apple.vue中添加按钮并对totalPrice进行操作 123456789101112131415161718192021&lt;template&gt; &lt;div&gt; &lt;button @click&#x3D;&quot;add&quot;&gt;add 5&lt;button&gt; &lt;button @click&#x3D;&quot;minus&quot;&gt;minus 5&lt;&#x2F;button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; data () &#123; price: 5 &#125;, methods: &#123; add () &#123; this.$store.dispatch(&#39;increase&#39;, this.price) &#125;, minus () &#123; this.$store.dispatch(&#39;decrease&#39;, this.price) &#125; &#125;&#125;&lt;&#x2F;script&gt; actions只能去调用mutations，不能直接修改state； 第一个参数context指当前的store； 在子组件中就不再commit mutations了，而是dispatch actions； 第二种方式把actions作为中介达到执行increment的目的。 actions和mutations的区别： actions里可以进行异步操作，然后再去触发mutations；而mutations里必须是同步操作数据（即依次向下执行操作）。所以按照之前的图形，跟后端的api接口都必须放在actions里。 举例说明： 1234567actions: &#123; increase (context, id) &#123; api(id, function(price)&#123; context.commit(&#x27;increment&#x27;, price) &#125;) &#125;&#125; vuex除了state、mutations和actions这三个关键的数据流环节以外，还提供了getters用来获取状态集state里的数据。 因此main.js的store实例可改为： 1234567891011121314151617181920212223242526let store = new Vuex.Store(&#123; state: &#123; totalPrice: 0 &#125;, getters: &#123; getTotal (state) &#123; return state.totalPrice &#125; &#125;, mutations: &#123; increment (state, price) &#123; state.totalPrice += price &#125;, decrement (state, price) &#123; state.totalPrice -= price &#125; &#125;, actions: &#123; increase (context, price) &#123; context.commit(&#x27;increment&#x27;, price) &#125;, decrease (context, price) &#123; context.commit(&#x27;decrement&#x27;, price) &#125; &#125;&#125;) 相应地，App.vue中的计算属性computed里可改为： 12345computed: &#123; totalPrice () &#123; return this.$store.getters.getTotal &#125;&#125; modules 可以把状态集分成不同的模型，每一个module都维护一套自己的state、mutations、actions和getters，这些状态集module最后合成一个总的对外store接口，我们可以根据不同的参数取不同模型里的状态。 1234567891011121314151617181920const moduleA = &#123; state: &#123;...&#125;, mutations: &#123;...&#125;, actions: &#123;...&#125;, getters: &#123;...&#125;&#125;const moduleB = &#123; state: &#123;...&#125;, mutations: &#123;...&#125;, actions: &#123;...&#125;, getters: &#123;...&#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; moduleA’s statestore.state.b // -&gt; moduleB’s state 补充：vuex模块化在实际项目中的应用 实际项目结构 根据以上结构： （1）数据中心为store文件夹，包括公用的actions.js和getters.js以及index.js、mutations.js，公用的actions.js和getters.js对mutations的动作进行映射 （2）数据放在modules的对应模块里如cart.js和products.js，每个数据模型里（即js里）也包含actions和mutations （3）最终的输出是在store&gt;index.js里，将vuex.store进行实例化并将所有的actions、getters、modules等输出出来。 简单案例： Store中只包括modules文件夹和index.js 详细步骤： 安装vuex npm install vuex --save 在store&gt;index.js中引入vuex，并使用Vuex.use方法，故还需引入vue 1234// index.js:import Vuex from &#x27;vuex&#x27;import Vue from &#x27;vue&#x27;Vue.use(Vuex) 引入对应的数据模型，并导出实例化的vuex.store: 123456import OrderList from &#x27;./modules/orderList&#x27;export default new Vuex.Store(&#123; modules: &#123; OrderList &#125;&#125;) 在入口文件main.js中引入store，并配置到全局 main.js： 使用router配置orderlist的访问地址http://localhost:8080/orderList/ router&gt;index.js： 并渲染到父组件中，此处为app.vue： 在每个数据模型中进行设置 orderList.js： state中存放数据 由于页面无法直接调用state中的数据，所以采用getters调用state的值 actions中进行异步操作 此处通过es6的解构赋值，把参数可以写成{commit, state}，commit用来调用mutations，state获取状态集里的数据 mutations同步地对状态state进行更改 此处有两个参数state和另一个参数，该参数是我们要赋值的state中的某个数据，是在actions或页面要传进去的 严格来讲，只允许mutations对state进行更改，不允许actions 在相应的页面组件中调用store的方法，采用this.$store 动态获取页面初始化数据tableData orderList.vue： mounted时主动调用actions，对orderList进行赋值 此时状态集中的orderList被更新，当然上面computed中依赖于orderList的tableDate也相应更新，template中的渲染层也会相应更新 另一个功能：参数更改，页面同步刷新 在orderList.js的mutations中增加方法updateParams 在orderList.vue中调用mutations的方法 采用types方式，把各模块方法或变量都放在同一个js中定义 在modules同级建立types文件夹并新建相应的js types&gt;orderList.js****： modules&gt;orderList.js****： (1) 引入所有相关的types: ​ (2) 使用该变量 ​ 补充知识点 安装 12npm install vue-resource --savenpm install json-server --save 配置与使用vue-resource 123456789// main.jsimport VueResource from &#x27;vue-resource&#x27;Vue.use(VueResource)this.$http.get(&#x27;api/getNewsList&#x27;) .then(function (data) &#123; console.log(data)&#125;, function (err) &#123; console.log(err)&#125;) 配置 json-server 12345678910111213141516171819// dev-server.jsvar jsonServer = require(&#x27;json-server&#x27;)var apiServer = jsonServer.create()var apiRouter = jsonServer.router(&#x27;db.json&#x27;)var middlewares = jsonServer.defaults()apiServer.use(middlewares)apiServer.use(&#x27;/api&#x27;, apiRouter)apiServer.listen(port + 1, function () &#123; console.log(&#x27;JSON Server is running&#x27;)&#125;)// config/index.jsdev:&#123; ... proxyTable: &#123; &#x27;/api/&#x27;: &#x27;http://localhost:8081/&#x27; &#125;, ...&#125;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://scarlett9354.github.io/categories/Vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://scarlett9354.github.io/tags/vue/"},{"name":"vue-router","slug":"vue-router","permalink":"https://scarlett9354.github.io/tags/vue-router/"},{"name":"vuex","slug":"vuex","permalink":"https://scarlett9354.github.io/tags/vuex/"}]},{"title":"前端全链路性能优化实战","slug":"前端全链路性能优化实战","date":"2021-04-29T08:09:09.000Z","updated":"2021-05-10T08:12:30.730Z","comments":true,"path":"2021/04/29/前端全链路性能优化实战/","link":"","permalink":"https://scarlett9354.github.io/2021/04/29/%E5%89%8D%E7%AB%AF%E5%85%A8%E9%93%BE%E8%B7%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/","excerpt":"","text":"第一章 课程背景介绍 1 课程介绍 1-1 什么是前端性能优化? 1-2 学习前端性能优化的难点在哪里? 2 内容综述 2-1 六大部分 第二章 静态资源优化 3 图片优化: 如何为不同格式的图片选择合适的应用场景 3-1 图片格式和应用场景介绍 4 图片优化: 怎样让图片加载得更快? 4-1 用工具进行图片压缩 4-1-1压缩png 4-1-2 压缩jpg 4-1-3 压缩gif 4-2 图片尺寸随网络环境变化 4-3 响应式图片 4-4 逐步加载图像 4-4-1 使用统一占位符 4-4-2 使用lqip (low quality image placeholders, 低质量图像占位符) 4-4-3 使用sqip (svg quality image placeholders, 基于svg的图像占位符) 4-5 真的需要图片吗? 5 图片优化: 在服务器端进行图片自动优化的原理是什么? 5-1 图片服务器自动优化解密 6 html: 怎么精简优化html的代码结构? 6-1 精简html代码 6-2 文件放在合适的位置 6-3 增强用户体验 7 css: css的优化应该遵循哪些原则? 7-1 提升css渲染性能 7-2 合适使用css选择器 7-3 提升css文件加载性能 7-4 精简css代码 7-5 合理使用web fonts 7-6 css动画优化 8 javascript: 如何提升js的执行效率? 8-1 js优化的总体原则 8-2 提升js文件的加载性能 8-3 js变量和函数的优化 8-4 js动画优化 8-5 合理使用缓存 9 javascript: 如何对js的缓存进行优化? 9-1 cookie 9-2 session storage 9-3 indexed db 9-4 local storage 10 javascript: 如何选择合适的模块化加载方案? 10-1 js模块化加载方案和选型 10-1-1 commonjs 10-1-2 amd (asynchronous module definition) 10-1-3 cmd (common module definition) 10-1-4 es6 import 11 怎样才能减少浏览器的回流和重绘? 11-1 css方面 11-2 js方面 12 dom编程优化: 怎样控制dom大小并简化dom操作? 12-1 控制dom的大小 12-2 简化dom的操作 13 静态文件: 有哪些常用的压缩工具? 13-1 html压缩工具 13-2 css压缩工具 13-3 js压缩工具 14 静态文件: 怎样打包才更合理? 14-1 静态文件打包方案 15 静态文件: 版本号更新, 你应该遵循哪些策略? 15-1 缓存更新 15-2 静态文件版本号更新策略 16 构建工具: 常用的前端构建工具有哪些? 如何选型? 16-1 grunt 16-2 gulp 16-3 webpack 16-4 百度的fis 16-5 京东的jdf 17 打包优化: 提升webpack打包效率的6个小技巧 17-1 定位体积大的模块 17-2 删除没有使用的依赖 17-3 生产模式进行公共依赖包抽离 17-4 在开发模式进行dll和dllreference方式优化 第三章 页面渲染架构设计与性能优化 18 浏览器渲染: 你是否清楚浏览器的渲染过程? 19 页面渲染: 主流的页面渲染技术架构和方案有哪些? 19-1 服务端渲染 19-2 客户端渲染 20 后端同步渲染: jsp是如何同步渲染出页面的? 20-1 同步渲染步骤 (以jsp为例) 20-2 技术优点 20-3 技术不足 20-4 协作方式 20-5 选型建议 20-6 协作力器 21 页面静态化: 动态页面静态化要如何实施? 21-1 静态化定义 第一章 课程背景介绍1 课程介绍1-1 什么是前端性能优化?通常来讲，我们说的前端性能优化是指从用户开始访问我们的网站到整个页面完整地展现出来的过程中，通过各种优化策略和优化方法，让页面加载得更快，让用户的操作相应更及时，给用户更好的使用体验。 1-2 学习前端性能优化的难点在哪里?2 内容综述2-1 六大部分第二章 静态资源优化3 图片优化: 如何为不同格式的图片选择合适的应用场景3-1 图片格式和应用场景介绍 JPEG（Joint Photographic Experts Group） PNG（Portable Network Graphics） GIF（Graphics Interchange Format） Webp 4 图片优化: 怎样让图片加载得更快?4-1 用工具进行图片压缩4-1-1压缩png node-pngquant-native 跨平台，压缩比高，压缩png24非常好 说明文档https://www.npmjs.com/package/node-pngquant-native 安装方法：$ npm install node-pngquant-native 新建index.js如下，运行$ node index.js执行压缩，基本上能从300k压缩到50k： 123456789101112// var pngquant = require(&#x27;node-pngquant-native&#x27;)var pngquant = require(&#x27;jdf-png-native&#x27;)var fs = require(&#x27;fs&#x27;)fs.readFile(&#x27;./in.png&#x27;, (err, buffer) =&gt; &#123; // if(err) &#123; // throw err // &#125; var resBuffer = pngquant.option(&#123;&#125;).compress(buffer) fs.writeFile(&#x27;./out.png&#x27;, resBuffer, &#123; flags: &#x27;wb&#x27; &#125;, function(err) &#123;&#125;)&#125;) 4-1-2 压缩jpg jpegtran 跨平台，有Linux、Mac、Windows的解决方案 官网 安装方法：$ npm install -g jpegtran 使用方法：$ jpegtran -copy none -optimize -outfile out.jpg in.jpg 4-1-3 压缩gif Gifsicle：通过改变每帧比例，减小gif文件大小，同时可以使用透明来达到更小的文件大小，目前公认的解决方案。 安装：官网 使用方式： 优化级别设置为不小于2，1的话基本不压缩 $ gifsicle --optimize=3 -o out.gif in.gif 将透明部分截去$ gifsicle --optimize=3 --crop-transparency -o out.gif in.gif 4-2 图片尺寸随网络环境变化不同网络环境（Wifi/4G/3G）下，加载不同尺寸和像素的图片，通过在图片URL后缀加不同参数改变。 4-3 响应式图片​ 有以下三种方式实现： JavaScript绑定事件检测窗口大小，以设置图片大小 CSS媒体查询 12345@media screen and (max-width: 640px) &#123; my_image &#123; width: 640px; &#125;&#125; h5中img标签属性srcset 12&lt;img srcset=&quot;img-320w.jpg, img-640w.jpg 2x, img-960w.jpg 3x&quot; src=&quot;img-960w.jpg&quot; alt=&quot;img&quot;&gt; x描述符：表示图像的设备像素比 4-4 逐步加载图像​ 共三种方式，来提高用户体验： 4-4-1 使用统一占位符比如在每个图片后加个公司logo，使用户在图片加载前可以看到这个占位符的图像 4-4-2 使用lqip (low quality image placeholders, 低质量图像占位符) 使图片加载前让用户看到这个低质量图片的占位 安装：$ npm install lqip 源码：https://github.com/zouhir/lqip-loader index.js中编码如下： 12345678910const lqip = require(&#x27;lqip&#x27;)const file = &#x27;./in.png&#x27;// imagelqip.base64(file).then(res =&gt; &#123; console.log(res)&#125;)// colorlqip.palette(file).then(res =&gt; &#123; console.log(res)&#125;) 打印结果为： 这样使用： 效果图对比如下： 4-4-3 使用sqip (svg quality image placeholders, 基于svg的图像占位符) 安装：$ npm install sqip 源码：https://github.com/axe312ger/sqip index.js编码如下： 123456const sqip = require(&#x27;sqip&#x27;)const result = sqip(&#123; filename: &#x27;./in.png&#x27;, numberOfPrimitives: 10&#125;)console.log(result.final_svg) 打印结果为： 这样使用： 效果图对比如下： 比LQIP的效果能稍微好一点；而且SVG可以设置不同的大小。 4-5 真的需要图片吗? 可以使用Web Font代替图片，比如小图标或切出来的业务图片，Web Font可以在不同的分辨率和不同的大小下进行特殊设置 可以使用Data URI代替图片，即base64图片，这样我们可以把base64代码用css文件的方式缓存到本地，就不用再请求图片内容了，直接走缓存即可 也可以采用Image Spriting（雪碧图）把多个小图片合成一张大图，这样用户在加载网页时，小图片的请求就被压成一个 5 图片优化: 在服务器端进行图片自动优化的原理是什么?5-1 图片服务器自动优化解密 名词解释： 图片服务器自动化优化是可以在图片URL链接上增加不同特殊参数，服务器自动化生成不同格式、大小、质量的图片。 处理方式： 图片裁剪：按长边、短边、填充、拉伸等缩放 图片格式转换：支持JPG、GIF、PNG、WebP等，支持不同的图片压缩率 图片处理：添加图片水印、高斯模糊、重心处理、裁剪边框等 AI能力：鉴黄以及只能抠图、智能排版、智能配色、智能合成等AI功能 请看下图： 这四种图片格式主要通过s参数展示，最后质量压缩比如我们可以添加!q10 6 html: 怎么精简优化html的代码结构?6-1 精简html代码 减少HTML的嵌套 减少DOM节点数 减少无语义代码（比如：&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;消除浮动） 删除http或者https，如果URL的协议头和当前页面的协议头一致的，或者此URL在多个协议头都是可用的，则可以考虑删除协议头 删除多余的空格、换行符、缩进和不必要的注释，当然可以用压缩工具来处理 省略冗余标签和属性 使用相对路径的URL 6-2 文件放在合适的位置 CSS样式文件链接尽量放在页面头部 CSS加载不会阻塞DOM Tree解析，但是会阻塞DOM Tree渲染，也会阻塞后面JS执行。任何body元素之前，可以确保在文档部分中解析了所有CSS样式（内联和外联），从而减少了浏览器必须重排文档的次数。如果放在页面底部，就要等待最后一个CSS文件下载完成，此时会出现“白屏”，影响用户体验。 JS引用放在HTML底部 防止JS的加载、解析、执行对阻塞页面后续元素的正常渲染 6-3 增强用户体验 设置favicon.ico 网站如果不设置favicon.icon，控制台会报错； 另外页面加载过程中地址栏左上角也没有图标loading过程； 同时也不利于记忆网站品牌，建议统一添加。 增加首屏必要的CSS和JS 页面如果需要等待所依赖的JS和CSS加载完成才显示，则在渲染过程中页面会一直显示空白，影响用户体验，建议增加首屏必要的CSS和JS，比如页面框架背景图片或者loading图标，内联在HTML页面中。这样做，首屏能快速显示出来，相对减少用户对页面加载等待过程。 比如新浪微博M站页面框架： 7 css: css的优化应该遵循哪些原则?7-1 提升css渲染性能 谨慎使用expensive属性 如nth-child伪类，position:fixed定位 尽量减少样式层级数，减少浏览器对CSS的查询 如div ul li span i &#123;color:blue;&#125; 尽量避免使用占用过多CPU和内存的属性 如text-indent:-99999px 尽量避免使用耗电量大的属性 如CSS3 3D transforms、CSS3 transitions、Opacity 7-2 合适使用css选择器 尽量避免使用CSS表达式 background-color: expression(new Date().getHours()%2 ? &quot;#fff&quot; : &quot;#000&quot;) 尽量避免使用通配选择器 body &gt; a &#123;font-weight:bold;&#125; 尽量避免类正则的属性选择器 *=, |=, ^=, $= 7-3 提升css文件加载性能 使用外链的CSS 因为可以把这个CSS放到CDN上，用户每次使用都会有缓存的，这样就减小整个页面体积的大小 尽量避免使用@import 因为只有所有import文件都加载完成才能往下走，会阻塞CSS文件甚至JS文件的加载 7-4 精简css代码 使用缩写语句 如margin-top:10px;margin-bottom:10px;尽量写成margin:10px 0; 删除不必要的零 比如0.2em直接写成.2em即可 删除不必要的单位，如px 比如0px直接写成0即可 删除过多的分号 删除空格和注释 以提升代码的可读性 总之，要尽量减少样式表的大小。 7-5 合理使用web fonts 将字体部署在CDN上 可以加快加载字体文件的速度 将字体以base64形式保存在CSS中并通过localStorage进行缓存 假如使用国外的字体库，如Google字体库，因为网络异常等某些不可抗原因不能正常加载，应该使用国内托管服务 7-6 css动画优化 尽量避免同时动画 延迟动画初始化 可以保证其他CSS样式正常渲染 结合SVG 8 javascript: 如何提升js的执行效率?8-1 js优化的总体原则 当需要时才优化 比如项目大的改版或代码无法维护时考虑整体优化 考虑可维护性 结合团队整体水平来优化 8-2 提升js文件的加载性能 加载元素的顺序：CSS文件放在里，JS文件放在底部 8-3 js变量和函数的优化 尽量使用id选择器 这样在查询方面速度非常快 尽量避免使用eval 因为eval()方法非常好性能 JS函数尽可能保持简洁 使用事件节流函数 如100ms后才响应scroll和resize事件一次，就能大大提升函数的加载效率 使用事件委托 比如ul &gt; li元素，可以把事件直接绑定到父元素ul上，这样在事件响应时，就不会查询到每个li上，直接到它父级即可，这样能提升查询效率和事件的响应速度 8-4 js动画优化 避免添加大量JS动画 尽量使用CSS3动画 因为CSS可以直接访问浏览器的GPU，比JS的性能好 尽量使用Canvas动画 合理使用requestAnimationFrame动画代替setTimeout、setInterval 因为requestAnimationFrame可以在正确的时间进行渲染，setTimeout(callback)和setInterval(callback)无法保证callback回调函数的执行时机 动画和事件尽量分离，不要耦合在一起 8-5 合理使用缓存 合理缓存DOM对象 比如存到一个变量里 缓存列表长度 也是把多个相同的元素如li的长度取出来放到一个变量里 使用可缓存的Ajax 把Ajax的catch打开，提升调用接口的时间 9 javascript: 如何对js的缓存进行优化?9-1 cookie Cookie通常由浏览器存储，然后将Cookie与每个后续请求一起发送到同一服务器。收到HTTP请求时，服务器可以发送带有Cookie的header头。可以给Cookie设置有效时间。 应用于： 会话管理：登录名，购物车商品（如数量、id等），游戏得分或服务器应该要记录的其他任何内容 个性化：用户首选项，主题或其他设置（比如首页排版布局、其他个性化专栏） 跟踪：记录和分析用户行为，比如埋点（比如在每个页面用Cookie埋一个值即标识，每访问一个页面，这个标识都会带到下个页面，就可以加以利用了，如给用户定向推送广告） 9-2 session storage 它是创建一个本地存储的键/值对 应用于：页面之间传值 有效期：用户关闭浏览器，值就会被清空掉 9-3 indexed db 索引数据库 应用于： 客户端存储大量结构化数据 在没有网络连接的情况下也可以使用（比如在线文档如Google Doc、石墨文档） 将冗余、很小修改、但经常访问的数据存储下来，以避免随时从服务器获取数据，减少请求数 9-4 local storage 本地存储 有效期：浏览器关闭后存储其中的数据也还存在，除非手动或用程序清空 应用于： 缓存静态文件内容JS/CSS（比如百度M站首页） 用户访问这个页面后，我们会把第一次访问时的JS/CSS文件放在localStorage，存储到本地，如果没有更新的话，用户下次访问时就不要再请求JS/CSS文件了，只要从localStorage中取，并塞进对应的style标签。 怎么更新呢？ 每个文件后都有个@值，可以在每次上线更新完后给每个key值加个特殊参数，比如以文件的内容做md5值来进行添加，这样本地就存储了本次变更的JS/CSS文件信息，再把这个值放到页面上，就可以正常加载了。 缓存不常变更的API接口数据 比如一些固化的数据或者每天或每半天要更新的数据，都是可以存储到localStorage中去的，更新的话和上面类似，可以把接口数据的内容做个md5值，有变更后，它内容的md5也会有变更，那么我们就会重新请求变更后的数据，同时会存到localStorage中去，这样页面就可以加载得更快。 储存地理位置信息 浏览在页面的具体位置 比如一些阅读类的网站，可以存储当前用户阅读的屏数，下次再访问时就可以直接定位到上次浏览的终点位置。 10 javascript: 如何选择合适的模块化加载方案?10-1 js模块化加载方案和选型10-1-1 commonjs 旨在Web浏览器之外为JavaScript建立模块生态系统，它都是同步加载的 1234567// CommonJS// 引入依赖var store = require(&#x27;store&#x27;)// exportsexports = function() &#123; return store.get(&#x27;customers&#x27;)&#125; Node.js模块化方案受到CommonJS的影响 12345678// NodeJS module// 引入依赖var store = require(&#x27;store&#x27;)function customerStore() &#123; return store.get(&#x27;customers&#x27;)&#125;// exportsmodule.exports = customerStore 它与CommonJS的差异是，只能对外输出一个对象 10-1-2 amd (asynchronous module definition) 它是异步模块定义规范，主要应用在浏览器上 比如RequireJS模块化加载器，就是基于AMD API实现的 1&lt;script data-main=&quot;scripts/main&quot; src=&quot;scripts/require.js&quot;&gt;&lt;/script&gt; 需要把它基础依赖的JS文件引入到项目中，这样才能异步调用其他模块JS的信息 10-1-3 cmd (common module definition) 它是通用模块定义规范 比如SeaJS模块化加载器，遵循CMD API编写 12345678// 方式一define(function(require, exports, module) &#123; // 模块代码&#125;)// 方式二define(&#x27;module&#x27;, [&#x27;module1&#x27;, &#x27;module2&#x27;], function(require, exports, module) &#123; // 模块代码&#125;) 10-1-4 es6 import语法如下： 1234567// square.jsexport function square(x) &#123; return x * x&#125;// main.jsimport &#123; square &#125; from &#x27;square&#x27;console.log(square(10)) // 100 11 怎样才能减少浏览器的回流和重绘?11-1 css方面 避免过多样式嵌套 避免使用CSS表达式 因为CSS表达式每次都会在CSS重绘的过程中执行 使用绝对定位，可以让动画元素脱离文档流 避免使用table布局 因为table布局会引起浏览器的多次重绘 尽量不使用float布局 建议用flex布局 图片最好设置好width和height 否则等图片完全加载后，整个页面就会重新设置它的width和height值，而用户看到的就是一片空白区域逐渐增大的画面，体验不好。所以最好在html设置好 尽量简化浏览器不必要的任务，减少页面重新布局 使用Viewport设置屏幕缩放级别 这样浏览器在渲染过程中就可以直接缩放了 避免频繁设置样式，最好把新的style属性设置完成后，进行一次性更改 避免使用引起回流/重绘的属性，最好把相应的变量缓存起来 11-2 js方面 最小化回流和重排 为了减少回流发生的次数，避免频繁操作DOM，可以合并多次对DOM修改，然后一次性批量处理。 控制绘制过程和绘制区域 绘制过程开销比较大的属性设置应该尽量避免减少使用 减少绘制区域范围 12 dom编程优化: 怎样控制dom大小并简化dom操作?12-1 控制dom的大小 众所周知，页面交互卡顿和流畅度很大一部分原因就是页面有大量DOM元素。另外元素绑定事件，事件冒泡和事件捕获的执行也会相对耗时。 通常控制DOM大小的技巧包括： 合理的业务逻辑 把业务逻辑进行合理得拆分，每实现一个业务逻辑尽量减少DOM树的数量 延迟加载即将呈现的内容（懒加载） 12-2 简化dom的操作 对DOM节点的操作统一处理后，再统一插入到DOM Tree中。 可以使用fragment，尽量不在页面DOM Tree里直接操作。 把DOM节点的样式、内容统一设置好，最后再放到页面中。 现在流行的框架Angular、React、Vue都在使用虚拟DOM技术，通过diff算法简化和减少DOM操作。 13 静态文件: 有哪些常用的压缩工具?13-1 html压缩工具html-minifier [https://www.npmjs.com/package/html-minifier](https://www.npmjs.com/package/html-minifier) 它可以删除一些html的换行、注释等其他不必要的字符，压缩后，html源代码由很多行变成一行，体积变小了。 13-2 css压缩工具clean-css [https://www.npmjs.com/package/clean-css](https://www.npmjs.com/package/clean-css) 13-3 js压缩工具 uglify-js https://www.npmjs.com/package/uglify-js 使用方法：uglifyjs in.js -o out.js 14 静态文件: 怎样打包才更合理?14-1 静态文件打包方案 公共组件拆分 把公用的js文件抽离成组件，其他页面直接调用它即可，这样当用户访问时，js文件的大小比较少，而且公用的这部分在其他页面也不需要再加载了，直接走CDN的缓存即可。 压缩：JS/CSS/图片 合并：JS/CSS文件合并，CSS Sprite图 Combo：JS/CSS文件 Combo http://cdn.com/??a.js,b.js 内容（建议√） 它是服务端处理的方式，比如在url后加个?a.js,b.js，这样用户在请求这个url时，服务端会把a.js和b.js自动合成，所以在请求页面时，无论有多个js文件，只发一次请求就可以了，大大减少了整个页面的请求数，并且是在服务器端重载处理，减少了前端开发成本。 15 静态文件: 版本号更新, 你应该遵循哪些策略?15-1 缓存更新CDN或ng后台刷新文件路径，这样后台通过shell脚本，就会更新文件header头，等这次缓存时间过期后，用户就会请求到最新的文件内容。 15-2 静态文件版本号更新策略​ 但是上面那样存在一个问题：比如项目已经上线或者发现一个bug，但用户看到的还是旧文件，所以需要下面的几种方式来解决： 文件name.v1-v100.js，即在文件name后加个版本号 为了区分每次的功能不一样，我们可以在大功能迭代上每次增加一个大版本，比如由v1到v2; 而小功能迭代新增加0.0.1或者0.1.0，比如从v1.0.0至v1.0.1，更新完后，把新的url路径更新到线上，这样用户打开页面就能立马取到最新的文件内容。 隔一段时间后，线上会有n多个版本的文件，怎么处理呢？可以在年末时，ng统一配置所有版本302至最新版。 时间戳.文件name.js 以每次上线时间点做差异 我们在实际研发中，为了省事，可能也会把一个项目的目录定义成这样进行区分 文件hash.文件name.js（这是最好的方式） 以文件内容hash值做key，放到url后。当内容变更，这个hash值也会改变，而内容不变，hash值也不会变，这样就保证了用户只对更新的文件更新缓存 每次上线，文件路径不一致 16 构建工具: 常用的前端构建工具有哪些? 如何选型?16-1 grunt 出现得最早，一个项目需要定制多个小任务和引用多个插件（质量参差不齐） 它给前端以通过JavaScript写shell脚本的方式进行处理开发过程中的一些代码压缩、合并等事情 16-2 gulp 通过流（stream）来简化多个任务间的配置和输出 配置代码相对较少 16-3 webpack 采用预编译，我们需要编译的文件在整个任务的过程中已经处理好了 中间文件（如缓存文件）都放在内存里处理，比另外放在一个缓存目录有很大的优势 支持多种模块化，比如CommonJS、AMD、ES6 Import 配置相对简单 综合对比，它是最流行的。 16-4 百度的fis16-5 京东的jdf以此为例，详细介绍构建工具具体怎么研发，它的内核是什么样的，以及它具体怎么来使用：待续…… 17 打包优化: 提升webpack打包效率的6个小技巧17-1 定位体积大的模块定位后，把这个大模块进行一一拆解或删除 17-2 删除没有使用的依赖之前在使用的依赖，后来经过迭代后依赖不存在了，就可以把它删除掉 17-3 生产模式进行公共依赖包抽离比如我们依赖的vue或react框架，可以把这些框架的文件通过打包的形式拿出来，放到页面上。这有什么好处呢？ 比如我们有n个业务线，同时都依赖于vue2.0的某个包，我们抽离完放在页面上，其他用户访问到A业务后再访问其他业务，这样vue的包文件不会重新加载，只需要加载业务文件即可。这样就能加速整个页面的访问，并且能够实现各个业务线的公共文件的抽离。 17-4 在开发模式进行dll和dllreference方式优化 我们在开发中可能依赖一些react或react router或者其他的公共的react组件，在开发中这些组件甚至react本身都要编译到内存中，我们采用这种方式，就不用每次在有代码变更时再次对react或它的框架进行编译了。这种方式能提升开发时间和效率。 接下来看下在实际生产和开发环境中，webpack怎么配置才能进行优化？ webpack.dev.dll.js： 123456789101112131415161718192021222324252627282930313233343536373839404142434445import webpack from &#x27;webpack&#x27;const appRoot = path.join(__dirname, &#x27;../&#x27;)export default &#123; mode: &#x27;development&#x27;, entry: &#123; vendor: [ &#x27;react&#x27;, &#x27;react-dom&#x27;, &#x27;react-redux&#x27;, &#x27;react-router-dom&#x27;, &#x27;react-transition-group&#x27;, &#x27;redux&#x27;, &#x27;redux-logger&#x27;, &#x27;redux-saga&#x27;, &#x27;history&#x27;, &#x27;immutable&#x27; ] &#125;, output: &#123; path: path.join(appRoot, &#x27;public&#x27;, &#x27;dll&#x27;), filename: &#x27;[name].dll.js&#x27;, /** * output.library * 将会定义为 window.$&#123;output.library&#125; * 在这次的例子中，将会定义为`window.vendorLibrary` */ library: &#x27;[name]Library&#x27; &#125;, plugins: [ new webpack.DllPlugin(&#123; /** * path * 定义manifest文件生成的位置 * [name]的部分由entry的名字替换 */ path: path.join(appRoot, &#x27;public&#x27;, &#x27;dll&#x27;, &#x27;[name]-manifest.json&#x27;), /** * name * dll bundle 输出到那个全局变量上 * 和 output.library 一样即可 */ name: &#x27;[name]Library&#x27; &#125;) ]&#125; 在入口entry里面，像react、react-dom、redux、history、immutable这样的组件在开发阶段最终会生成一个dll.js文件（output.filename），以及中间会产生一个配置的文件path: path.join(appRoot, 'public', 'dll', '[name]-manifest.json')（在plugins中），在开发阶段webpack就不会每次都重新编译这些依赖的库文件了，只要在manifest里面或者上面的入口里面写完后，就可以直接在内存里读取它的内容，同时它会把打成的包文件挂到window下面的vendorLibrary这个变量上面，页面就可以直接使用了。 webpack.dev.js： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202const path = require(&#x27;path&#x27;)const fs = require(&#x27;fs&#x27;)const webpack = require(&#x27;webpack&#x27;)const cssnano = require(&#x27;cssnano&#x27;) // 优化css，对于长格式优化成短格式等const autoprefixer = require(&#x27;autoprefixer&#x27;)// 修复flexbox已知的bugconst flexbugs = require(&#x27;postcss-flexbugs-fixes&#x27;)// 根目录上下文const &#123; URL_CONTEXT &#125; = require(&#x27;../common/constants&#x27;)const hotMiddlewareScript = &#x27;webpack-hot-middleware/client?path=/__webpack_hmr&amp;timeout=20000&amp;reload=true&#x27;const appRoot = path.resolve(__dirname, &#x27;../&#x27;)const appPath = path.resolve(appRoot, &#x27;public&#x27;)// webpack configconst webpackConfig = &#123; /** * 生产下默认设置以下插件，webpack 4中，一些插件放在optimization中设置 * https://webpack.js.org/concepts/mode * - plugins: [ * - new webpack.NamedModulesPlugin(), * - new webpack.DefinePlugin(&#123; &quot;process.env.NODE_ENV&quot;: JSON.stringify(&quot;development&quot;) &#125;) * - ] */ mode: &#x27;development&#x27;, cache: true, // 开启缓存，增量编译 bail: false, // 设为true时如果发生错误，则不继续尝试 devtool: &#x27;eval-source-map&#x27;, // 生成source map文件 /** * Specify what bundle information gets displayed * https://webpack.js.org/configuration/stats/ */ stats: &#123; cached: true, // 显示缓存信息 cachedAssets: true, // 显示缓存的资源（将其设置为`false`则仅显示输出的文件） chunks: true, // 显示chunk信息（设置为`false`仅显示较少的输出） chunkModules: true, // 将构建模块信息添加到chunk信息 colors: true, hash: true, // 显示编译后的hash值 modules: true, // 显示构建模块信息 reasons: true, // 显示被导入的模块信息 timings: true, // 显示构建时间信息 version: true // 显示webpack版本信息 &#125;, /** * https://webpack.js.org/configuration/target/#target * webpack能够为多种环境构建编译，默认是&#x27;web&#x27;，可省略 */ target: &#x27;web&#x27;, resolve: &#123; // 自动扩展文件后缀名 extensions: [&#x27;.js&#x27;, &#x27;.scss&#x27;, &#x27;.css&#x27;, &#x27;.png&#x27;, &#x27;.jpg&#x27;, &#x27;.gif&#x27;], // 模块别名定义，方便直接引用别名 alias: &#123;&#125;, // 参与编译的文件 modules: [&#x27;client&#x27;, &#x27;node_modules&#x27;] &#125;, /** * 入口文件，让webpack用哪个文件作为项目的入口 * 如果用到了新的es6 api，需要引入babel-polyfill，比如String.prototype中的方法includes * 所以根据实际需要是否引入babel-polyfill */ entry: &#123; index: [&#x27;./client/pages/index.js&#x27;, hotMiddlewareScript] &#125;, // 出口，让webpack把处理完成的文件放在那里 output: &#123;&#125;, // module处理 module: &#123; /** * Make missing exports an error instead of warning * 缺少exports时报错，而不是警告 */ strictExportPresence: true, rules: [ // https://github.com/MoOx/eslint-loader &#123; enforce: &#x27;pre&#x27;, test: /\\.js$/, exclude: /node_modules/, use: &#123; loader: &#x27;eslint-loader&#x27;, options: &#123; configFile: &#x27;.eslintrc.js&#x27;, // 验证失败，终止 emitError: true &#125; &#125; &#125;, &#123; test: /\\.js$/, exclude: /node_modules/, use: &#123; loader: &#x27;babel-loader&#x27;, options: &#123; cacheDirectory: true, babelrc: false, presets: [], plugins: [] &#125; &#125; &#125;, &#123; test: /\\.css/, use: [ &#x27;style-loader&#x27;, &#123; loader: &#x27;css-loader&#x27;, options: &#123; sourceMap: true, localIdentName: &#x27;[name]_[local]_[hash:base64:5]&#x27; &#125; &#125;, &#123; loader: &#x27;postcss-loader&#x27;, options: &#123; sourceMap: true, plugins: [ cssnano(&#123; autoprefixer: false &#125;), flexbugs(), autoprefixer(&#123; flexbox: &#x27;no-2009&#x27; &#125;) ] &#125; &#125; ], // publicPath: &#x27;/public/dist/&#x27; 这里如设置会覆盖output中的publicPath &#125;, /** * Rules for images * https://webpack.js.org/configuration/module/#rule-oneof */ &#123; test: /\\.(bmp|gif|jpe?g|png|svg)$/, oneOf: [ // 在css中的图片处理 &#123; issuer: /\\.(css|less|scss)$/, // issuer表示在这些文件中处理 oneOf: [ // svg 单独使用svg-url-loaderInline处理，编码默认为utf-8 &#123; test: /\\.svg$/, loader: &#x27;svg-url-loader&#x27;, exclude: path.resolve( appRoot, &#x27;./client/scss/common/_iconfont.scss&#x27; ), // 除去字体文件 options: &#123; name: &#x27;[path][name].[ext]?[hash:8]&#x27;, limit: 4096 // 4kb &#125; &#125;, /** * 其他图片使用Base64 * https://github.com/webpack/url-loader */ &#123; loader: &#x27;url-loader&#x27;, options: &#123; name: &#x27;[path][name].[ext]?[hash:8]&#x27;, limit: 4096 // 4kb &#125; &#125; ] &#125;, // 在其他地方引入的图片文件使用file-loader即可 &#123; loader: &#x27;file-loader&#x27;, options: &#123; name: &#x27;[path][name].[ext]?[hash:8]&#x27; &#125; &#125; ] &#125; ] &#125;, // https://webpack.js.org/configuration/mode/#mode-development plugins: [ new webpack.HotModuleReplacementPlugin() // 热部署替换模块 ]&#125;// 判断dll文件是否已生成let dllExist = falsetry &#123; fs.statSync(path.resolve(appPath, &#x27;dll&#x27;, &#x27;webdor.dll.js&#x27;)) dllExist = true&#125; catch(e) &#123; dllExist = false&#125;if(dllExist) &#123; webpackConfig.plugins.push( new webpack.DllReferencePlugin(&#123; context: appPath, /** * 在这里引入manifest文件 */ manifest: require(&#x27;../public/dll/vendor-manifest.json&#x27;) &#125;) )&#125;module.exports = webpackConfig 可以把入口文件写在了最上面，在module里对它的eslint进行检查，当然也包括像babel对es6语法的编译，以及css-loader的相关配置，还会有postcss的编译的处理，还可以对字体文件的大小进行处理（limit:4096），也可以对base64编码的图片进行体积的控制。 在dev.dll.js文件生成完后，也要在dev开发模式的阶段进行一些引入，把刚才生成的vendor-manifest文件进行引入，这样我们那些包文件就不会进行编译了。 第三章 页面渲染架构设计与性能优化18 浏览器渲染: 你是否清楚浏览器的渲染过程? step1 浏览器解析HTML，生成DOM Tree（Parse HTML） step2 浏览器解析CSS，生成CSSOM（CSS Object Model）Tree step3 JavaScript会通过DOM API和CSSOM API来操作DOM Tree和CSS Rule Tree，浏览器将DOM Tree和CSSOM Tree合成渲染树（Render Tree） step4 布局（Layout）：根据生成的Render Tree，进行回流，以计算每个节点的几何信息（位置、大小、字体样式等） step5 绘制（Painting）：根据渲染树和回流得到的几何信息，得到每个节点的绝对像素 step6 展示（Display）：将像素发送给图形处理器（GPU），展示在页面上 19 页面渲染: 主流的页面渲染技术架构和方案有哪些?19-1 服务端渲染​ 即在服务器渲染，然后在客户端进行展示，比如： 后端同步渲染，指的是JSP、PHP等后端语言渲染，也可以用Node.js的Node Server进行渲染 同构直出 BigPipe 19-2 客户端渲染 JavaScript渲染：静态化、前后端分离、单页面应用，即我们的NSPA Web App：它与JS不一样的地方是，它是单页面的，比如Angular、React、Vue等三大框架渲染的页面，另外还有PWA这种新技术 原生App：IOS、Android Hybrid App（混合式开发app）：PhoneGap、AppCan等框架，当然我们的大型app里也会有自己的hybrid设置 跨平台开发：React Native、Flutter、小程序等，采用这些语言用桥接的方式获取原生渲染的方式 20 后端同步渲染: jsp是如何同步渲染出页面的?20-1 同步渲染步骤 (以jsp为例) step1 JSP Servlet映射以.jsp结尾的URL，当.jsp文件请求时，servlet容器知道要调用哪个Servlet step2 Servlet容器检查Servlet是否已被编译 step3 如果未在步骤2中进行编译，则Servlet容器会将JSP转换为Servlet代码，并进行编译 step4 Servlet容器将JSP请求转发到编译JSP Servlet类 step5 JSP Servlet类返回并发送给客户端浏览器HTML，浏览器进行同步渲染 特别提出一点：我们整个包括取得后端业务的逻辑、数据库的信息和业务的处理，都是在JSP Servlet里处理完了，这时候给用户的才是正常看到的内容。 20-2 技术优点快速实现业务开发并上线，因为： 市场上JSP和PHP技术人员较多 JSP和PHP发展了这么多年了，他的整个技术栈和编译的工具都是比较现成的，整个技术框架也是比较现成的，只要找到这样的人，拿到现成的技术栈，就能快速实现我们的业务 20-3 技术不足 需要先实现业务逻辑和功能，再输出HTML内容给浏览器，用户需等待HTML页面完全加载之后才能看到页面内容。 因为取数据和展示的过程都是比较耗时的，因为需要把过程中所有的业务全部实现、取到数据库的数据，然后展示到页面上，用户等待JSP Servlet编译的时间比较长，包括一些白页的情况也可能出现。 代码耦合严重，不太好区分业务逻辑和页面模板。 需求变更上线周期相对较长。 一般情况下，前端工程师写的静态html，JSP工程师用它把页面进行嵌套，嵌套完成后再进行Servlet编译，再给浏览器进行渲染。所以来了新需求后，前端必须重新写模板、切页面，再给JSP工程师把页面套进去，然后再上线。 20-4 协作方式前端出静态页面，后端套页面 20-5 选型建议如果是创业初期验证阶段，或者20个研发人员以内的项目，为了满足业务快速验证并一天内多次上线，技术选型上使用服务端同步渲染没有任何问题，一人字就是“快”。 20-6 协作力器 jSmart Velocity.js 这两种都是前端写模板，给后端直接上线即可。 21 页面静态化: 动态页面静态化要如何实施?21-1 静态化定义 静态化是使动态化的网站生成静态HTML页面以供用户 未完待续……","categories":[{"name":"性能优化","slug":"性能优化","permalink":"https://scarlett9354.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://scarlett9354.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"Node.js开发实战","slug":"Node-js开发实战","date":"2021-04-29T07:33:16.000Z","updated":"2021-05-11T03:40:18.884Z","comments":true,"path":"2021/04/29/Node-js开发实战/","link":"","permalink":"https://scarlett9354.github.io/2021/04/29/Node-js%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/","excerpt":"","text":"第一章 1 课程介绍 1-1 使用nodejs过程中遇到的问题 1-2 nodejs为什么值得学习? 1-3 使用nodejs的难点在哪里? 3 nodejs是什么? 4 nodejs可以用来做什么? 4-1 由什么需求决定的? 以腾讯视频网页版为例 4-2 构建工作流 (automate and enhance your workflow)-nodejs现在被广泛运用的另一个场景 4-3 开发工具visual studio code-nodejs的第三个应用场景 4-4 游戏-wayward 4-4 客户端应用-twitch-tv 5 课程实战项目介绍 第二章 技术预研篇 6 什么是技术预研? 7 nodejs开发环境安装 8 第一个nodejs程序-石头剪刀布游戏 8-1 前言 8-2 利用process-argv正式编写石头剪刀布游戏 9 模块-commonjs规范 9-1 commonjs规范的使用过程 10 模块-使用模块规范改造石头剪刀布游戏 10-1 改造石头剪刀布游戏 11 模块-npm 11-1 npm介绍 11-2 怎么使用npm包呢? 12 模块-nodejs内置模块 12-1 nodejs内置模块 12-2 剖析nodejs内置模块 12-3 event-emitter 12-4 总结 13 异步-非阻塞i /o 13-1 非阻塞i /o的定义 13-2 非阻塞i /o代码演示 13-3 nodejs架构图讲解 14 异步-异步编程之callback 14-1 回调函数 第一章1 课程介绍1-1 使用nodejs过程中遇到的问题 Node.js程序运行不稳定，经常出现服务不可用的情况 Node.js程序运行效率低 前端同学对服务端技术不熟悉，培训困难，推广受阻 1-2 nodejs为什么值得学习? Node.js拥有广大的JavaScript程序员基础，并且完全开源，所以它拥有一个强大的开发者社区，依靠繁荣的社区力量，现在已经发展出成熟的技术体系以及庞大的生态。 它被广泛应用在Web服务、开发工作流、客户端应用等领域，其中在Web服务开发领域，业界对它的接受程度是最高的。 通常它会被用来做一个BFF层，即Backend For Frontend（服务于前端的后端），通俗地说，就是一个专门为前端业务提供数据的后端程序。这类程序的特点是，不需要太强的服务器运算能力，但对程序的灵活性有较高的要求。这两个特点正好与Node.js的优势相吻合。 在Web服务开发领域搭建一个Node.js BFF层是有很大好处的： 对于Web业务本身来说，Node.js现在是最适合用来做BFF层的一门技术。 有一个Node.js BFF层，能让前端有能力自由组装后台数据，这样可以减少大量的业务沟通成本，加快业务的迭代速度；同时，前端工程师能自主决定前端与后台通讯的方式，也让前端工程师有了更多能力着手于Web应用的性能优化。 对于后端和运维工程师来说，Node.js BFF层的搭建，绝对不是一个光靠前端工程师就能完成的事情，在搭建过程中涉及到的RPC调用、系统运维等场景，都需要后端和运维的紧密配合。 通过搭建BFF层，除了后续能大幅减少自己在繁重业务中的工作量之外，还可以大大提升自己在架构领域的知识经验。 对于前端工程师自身来说，Node.js虽然是一门非浏览器端的技术，但是它基于JavaScript的环境，能让前端工程师快速上手。 我们可以经由Node.js涉足数据库、操作系统、人工智能等领域，让前端工程师不再因为技术的壁垒将眼光局限在浏览器这一个环境内。 1-3 使用nodejs的难点在哪里? Node.js这门技术除了JavaScript之外，其他地方和浏览器技术几乎毫无交集，即使是数据结构、设计模式等等程序员通用技巧，也都有侧重点不一样的部分。 比如，在使用Node.js的过程中，前端工程师需要了解诸如RPC调用、进程管理等非浏览器端的知识。 除此之外，在推广Node.js的过程中，可能还会遇到产品、后台、运维甚至老板等不同角色的质疑，导致前端使用Node.js开展业务会碰上各种各样的阻力。 因此，除了补充必要的后端开发知识和系统运维知识外，我们还需要对Node.js的优缺点、它能给业务带来的价值都有非常深入的理解，才能说服他人配合你，完成从前端到后台的一整套项目开发。 3 nodejs是什么? 根据官网的话： Node.js是一个基于Chrome V8引擎的JavaScript运行环境。 Node.js使用了一个事件驱动、非阻塞式I/O的模型，使其轻量又高效。 其实没必要知道这些！！！ 在Node.js里运行JavaScript跟在Chrome里运行JavaScript有什么不同？Chrome浏览器用的是同样的JavaScript引擎和模型。 其实，在Node.js里写JS和在Chrome里写JS，几乎没有不一样。 那么不一样在哪里呢？ Node.js没有浏览器API，即document、window等。 加了许多Node.js API，比如文件系统、进程等等。 对于开发者来说，Node.js： 你在Chrome里写JavaScript控制的是浏览器 Node.js让你用类似的方式，控制整个计算机。 Node.js的真谛（即官网的定义），需要你在Node.js的学习过程中慢慢理解。 4 nodejs可以用来做什么?4-1 由什么需求决定的? 以腾讯视频网页版为例 搜索引擎的优化 + 首屏速度优化 = 服务端渲染 需要实现搜索引擎的优化； 要实现网页首屏的加速。 这两个需求就决定了，需要做个服务端的渲染，就决定采用了Node.js。 服务端渲染 + 前后端同构 = Node.js 同一模板要考虑前后端复用问题，即前后端可以采用同一套代码，所以为了达到服务端渲染和前后端同构，最后决定采用Node.js。 4-2 构建工作流 (automate and enhance your workflow)-nodejs现在被广泛运用的另一个场景 这里有两个典型的工具：gulp官网和webpack官网 gulp官网上的一个简单例子： 这个例子具体做了什么？ 它可以给html、css、js文件各做一些预处理，比如html任务，网页对模板做了个预编译；css任务表示样式是用less语言编写，可以通过gulp编译成css，再放到它们的生产目录上；js任务表示有很多js，通过gulp打包拼在了一起，并且做了个压缩混淆，再放到生产目录。 webpack是用来打包所有的样式、js、图片等的工具。 众所周知，前端优化的一个重要原则，就是把这些资源打包得尽可能少，建立尽可能少的HTTP连接，这样就能够加速网页的加载。 因为构建工具不会永远不出问题，也不会永远满足需求，所以使用Node.js做JS构建工具，是最保险的选择。 4-3 开发工具visual studio code-nodejs的第三个应用场景4-4 游戏-wayward 它是一个沙盒类生存游戏，自由度非常高，即玩家想干嘛就干嘛，想使哪里就使哪里。 它也是基于Node.js的，为什么？ 像这种大型应用，都需要给使用者自定义模块的能力。 使用Node.js做复杂本地应用： 可以利用JS的灵活性提供外部扩展； JS庞大的开发者技术让他们的灵活性得到利用。 4-4 客户端应用-twitch-tv 它是个游戏直播网站，它也是用Node.js开发的，这是因为他们的网页和客户端应用是一模一样的。 他们需要在已有网站的情况下，新开发客户端应用，这就可以使用Node.js客户端技术（electron）实现，最大限度复用现有工程。 5 课程实战项目介绍​ 这个项目是个Node.js版极客时间网站，包括一些典型的页面： 列表页 打通前后台通信包括把浏览器地址栏传的参数都一一解析出来，然后传到后台的微服务去，等到后台的数据返回之后，我们再渲染成页面，返回到前端 服务端渲染 这个页面涉及比如下拉加载、过滤条件的变化等服务端渲染的功能 详情页 网页路由 HTTP服务器需要支持url路由，或者让Node.js前面加一项反向代理做路由，最终使Node.js能够支持列表页和详情页 异步加载 涉及功能点还有课程介绍和课程目录在Node.js服务上实现无刷新切换。 播放页 API服务器 评论系统点赞需要API服务器，实现小量的json数据的交换。 涉及的功能点还有章节的选择等。 第二章 技术预研篇6 什么是技术预研? 在程序开发前，把需要用到的技术和工具全都调试的没问题了再开发，这样使得开发技术变得更加顺利，这就是技术预研的作用。 具体怎样进行技术预研？ 分析要做的需求，找出技术难点。 针对每个技术难点进行攻克和测试。 我们这个项目属于一个BFF层，通俗点讲，它属于浏览器跟后台服务中间的一个中间渲染层，这个中间渲染层则组装后台返回的各个微服务里面返回的数据，并且组装成前端所需要的数据，再返回到？ 这样的BFF层的主要职责有两个： 对用户侧提供HTTP服务 使用后端RPC服务 7 nodejs开发环境安装 Chrome的安装 VSCode的安装 Node.js的安装 直接去官网下载安装 包管理工具npm的安装 8 第一个nodejs程序-石头剪刀布游戏8-1 前言 在这个游戏中，我们会看到： Node.js的运行方式是怎样的 Node.js的全局变量是怎样使用的，以及它有哪些全局变量 新建node_js文件夹，新建node_js/index.js文件，里面编写代码console.log(&#39;hello world&#39;)，并在终端打开项目，执行$ node index.js，就能看到hello world被打印出来。 这个node命令会读取index.js中的内容，并运行它里面的js代码。 Node.js的某些全局变量与Chrome里的有些差别，如： 12345console.log(Date)console.log(Math)console.log(setTimeout)console.log(setInterval)console.log(requestAnimationFrame) // 它的含义是浏览器渲染的下一帧，由于我们不是处于浏览器环境，所以它是不存在的，会报错 运行$ node index.js后的打印结果如下： Node.js为了弥补requestAnimationFrame的确实，额外提供了一个： 1console.log(setImmediate) 打印结果为： Node.js特有的环境变量： 121. console.log(__filename) // 表示当前运行的脚本所在的位置2. console.log(__dirname) // 表示当前运行的脚本所在的目录位置 打印结果为： 13. console.log(process) // 记载了我们运行这个Node.js程序的进程信息 打印结果为： 1234567891011121314151617PS C:\\studyFiles\\node_js&gt; node index.jsprocess &#123; version: &#x27;v10.16.3&#x27;, // 表示Node.js的版本号 platform: &#x27;win32&#x27;, // 表示运行环境的操作系统 hrtime: &#123; [Function: hrtime] bigint: [Function] &#125;, // 是用来统计时间的，它的时间精度可以到微秒级，我们需要做时间统计时可以用这个函数 cpuUsage: [Function: cpuUsage], // 打印cpu占用率 memoryUsage: [Function: memoryUsage], // 打印内存占用率，与cpuUsage在性能分析时经常用到 exit: [Function], kill: [Function], // 与exit是用来管理和杀进程的操作 argv: [ // 表示用户在启动这个进程时，敲击的命令是怎样的，这个会在我们做命令行程序时用到 &#x27;C:\\\\dev\\\\nodejs\\\\node.exe&#x27;, &#x27;C:\\\\studyFiles\\\\node_js\\\\index.js&#x27; ], env: &#123; // 打印Node目前所运行环境的环境变量，可以让我们在快速启动Node.js时做一些配置，让我们的程序可以根据环境变量做一些分析 Path: ... &#125;&#125; 8-2 利用process-argv正式编写石头剪刀布游戏123456789101112131415161718192021var playerAction = process.argv[process.argv.length - 1]console.log(playerAction) // 打印出node index.js rock的最后一项，即rockvar random = Math.random() * 3if(random &lt; 1) &#123; var computerAction = &#x27;rock&#x27; &#125;else if(random &gt; 2) &#123; var computerAction = &#x27;scissor&#x27; &#125;else &#123; var computerAction = &#x27;paper&#x27; &#125;if(computerAction === playerAction) &#123; console.log(&#x27;平局&#x27;)&#125;else if( (computerAction === &#x27;rock&#x27; &amp;&amp; playerAction === &#x27;paper&#x27;) || (computerAction === &#x27;scissor&#x27; &amp;&amp; playerAction === &#x27;rock&#x27;) || (computerAction === &#x27;papar&#x27; &amp;&amp; playerAction === &#x27;scissor&#x27;)) &#123; console.log(&#x27;你赢了&#x27;)&#125;else &#123; console.log(&#x27;你输了&#x27;)&#125; 9 模块-commonjs规范 JS中采用&lt;script /&gt;加载js文件，它存在以下问题： 脚本变多时，需要手动管理加载顺序。 不同脚本之间逻辑调用，需要通过全局变量的方式。 全局变量多了，程序就很难管理；而且全局变量还存在被别人覆盖的风险。 当JS运行环境没有html怎么办？ 9-1 commonjs规范的使用过程 创建node_js/commonjs文件夹，并在它里面创建两个文件index.js和lib.js 编写index.js： 123console.log(&#x27;start require&#x27;)require(&#x27;./lib.js&#x27;) // 会根据CommonJS规范引入lib.jsconsole.log(&#x27;end require&#x27;) 编写lib.js： 1console.log(&#x27;hello gc&#x27;) 打印结果为： 当一个初始状态模块被别人引用后，它默认是一个空对象。比如，我们可以将index.js中的require的结果赋值到一个变量上，并打印出来看一下： 12var lib = require(&#x27;./lib.js&#x27;)console.log(&#x27;end require&#x27;, lib) 打印结果为： 我们可以在lib.js模块的exports上挂一个属性，再次打印看下结果： 123456// lib.js：console.log(&#x27;hello gc&#x27;)exports.hello = &#x27;world&#x27;// index.js：var lib = require(&#x27;./lib.js&#x27;)console.log(lib) 打印结果为： exports上也可以挂函数、对象等： 12345exports.hello = &#x27;world&#x27;exports.add = function(a, b) &#123; return a + b&#125;exports.geekbang = &#123; hello: &#x27;world&#x27; &#125; 打印结果为： 验证lib.js模块中exports出的对象与index.js中require的变量是同一个引用： 12345678910111213index.js：var lib = require(&#x27;./lib.js&#x27;)lib.additional = &#x27;test&#x27;lib.js：exports.hello = &#x27;world&#x27;exports.add = function(a, b) &#123; return a + b&#125;exports.geekbang = &#123; hello: &#x27;world&#x27; &#125;setTimeout(() =&gt; &#123; console.log(exports)&#125;, 2000) 2s后打印结果显示为： 假如希望exports不是一个对象，它可以是一个函数或其他基础数据类型 12345678910111213// lib.js：exports.hello = &#x27;world&#x27;exports.add = function(a, b) &#123; return a + b&#125;exports.geekbang = &#123; hello: &#x27;world&#x27; &#125;module.exports = function minus(a, b) &#123; return a - b&#125;// index.js：var lib = require(&#x27;./lib.js&#x27;)console.log(lib) 打印结果为： PS：无论lib.js中有没有exports其他的，打印结果都以module.exports为准，也可以理解为module.exports会把exports出的变量覆盖掉 使用webpack打包会发现每个模块都被打包到一个函数里，这是因为每个模块都是一个独立的作用域，而js中创建独立作用域的方式就是采用函数（老师将的例子不懂！！！） 10 模块-使用模块规范改造石头剪刀布游戏10-1 改造石头剪刀布游戏 改造后的代码如下： 1234567891011121314151617181920212223242526// lib.js：module.exports = function(playerAction) &#123; var random = Math.random() * 3 if(random &lt; 1) &#123; var computerAction = &#x27;rock&#x27; &#125;else if(random &gt; 2) &#123; var computerAction = &#x27;scissor&#x27; &#125;else &#123; var computerAction = &#x27;paper&#x27; &#125; if(computerAction === playerAction) &#123; console.log(&#x27;平局&#x27;) return 0 &#125;else if( (computerAction === &#x27;rock&#x27; &amp;&amp; playerAction === &#x27;paper&#x27;) || (computerAction === &#x27;scissor&#x27; &amp;&amp; playerAction === &#x27;rock&#x27;) || (computerAction === &#x27;papar&#x27; &amp;&amp; playerAction === &#x27;scissor&#x27;) ) &#123; console.log(&#x27;你赢了&#x27;) return -1 &#125;else &#123; console.log(&#x27;你输了&#x27;) return 1 &#125;&#125; 1234567891011// index.js： // var playerAction = process.argv[process.argv.length - 1]const game = require(&#x27;./lib&#x27;)// const result = game(playerAction)// console.log(result)process.stdin.on(&#x27;data&#x27;, e =&gt; &#123; // 获取进程的标准输入 const playerAction = e.toString().trim() // 并把这个标准输入转化成字符串输出出来 // console.log(playerAction) const result = game(playerAction) console.log(result)&#125;) 运行命令$ node index.js后它会持续运行，输入命令后打印结果如下： 我们希望实现的需求是：电脑输三次就会自杀，代码紧接上面，改造index.js： 12345678910111213let count = 0process.stdin.on(&#x27;data&#x27;, e =&gt; &#123; // 获取进程的标准输入 const playerAction = e.toString().trim() // 并把这个标准输入转化成字符串输出出来 const result = game(playerAction) console.log(result) if(result === -1) &#123; count ++ &#125; if(count === 3) &#123; console.log(&#x27;你太厉害了，我不玩了！&#x27;) process.exit() &#125;&#125;) 打印结果如下： 11 模块-npm11-1 npm介绍 npm是什么？ Node.js的包管理工具 包是什么？ 别人写的Node.js模块 npm上的著名大神： TJ Holowaychunk - 贡献express包 Mafintosh Dominictarr - npm event-stream事件 没有npm，也不会有现在这么繁荣的JS社区 11-2 怎么使用npm包呢? 新建npm文件夹，并在其中运行命令$ npm init，问题一律选择默认，然后就会生成一个package.json，它是用来说明这个目录表达的是一个npm包，只要是npm包，就能装其他npm包 运行$ npm install glob安装glob包，就会生成node_modules目录，在package.json中多出dependencies依赖： 1234567891011121314&#123; &quot;name&quot;: &quot;npm&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;glob&quot;: &quot;^7.1.6&quot; &#125;&#125; 直接在国外网站下载npm包太慢，可以使用淘宝npm镜像http://npm.taobao.org/，它把国外的所有npm包复制映射过来，并放到国内的服务器中了。怎么使用呢？ $ npm install -g cnpm --registry=https://registry.npm.taobao.org $ cnpm install gulp --save 关于npm的相关问题，可以登录查看官方文档 12 模块-nodejs内置模块 重申Node.js的官方定义： 1. Node.js是一个基于Chrome V8引擎的JavaScript运行环境（如图中左半部分） Application是我们所写的Node.js代码，它通过V8引擎运行，里面会涉及一些关于操作系统的调用，这部分就由V8引擎帮助转发到操作系统层面，从操作系统层面得到返回结果后，再通过V8引擎返回到JS中去。 从JS到V8再到操作系统的能力，有很大部分是由内置的模块提供的。 2. Node.js使用事件驱动，非阻塞式I/O的模型，使其轻量又高效（如图中右半部分） 12-1 nodejs内置模块 官网列出所有的内置模块，举例说明： File System - 用来操作文件的关于操作系统的api Net - 让我们可以使用操作系统的网络能力 Process - 记载着Node.js进程的一些信息 OS - 表示跟操作系统相关的模块 os.arch() 表明了操作系统的架构，如32位、64位 os.cpus() 得到node.js所运行的电脑里有多少cpu，以及cpu里有多少个内核，这些核的参数是怎样的 os.freemem() 表示当前的操作系统还有多少空余内存 12-2 剖析nodejs内置模块 在github上查看源码，所有的内置模块都在lib文件夹中，查看os.js Node.js内置模块做的事情基本上是负责Node.js的应用层面到操作系统层面的通信，包括Node.js调用os的能力或者os通知Node.js的能力。 有了内置模块，Node.js就拥有了强大的和操作系统交互的能力，也就能顺利地做成服务端的应用。 12-3 event-emitter 观察者模式，即事件收发的模式，用来解决两个对象之间通信的问题，如addEventListener和removeEventListener 123456789101112131415161718192021// lib.js:const EventEmitter = require(&#x27;events&#x27;).EventEmitterclass Geektime extends EventEmitter &#123; constructor() &#123; super() setInterval(() =&gt; &#123; this.emit(&#x27;newLession&#x27;, &#123; price: Math.random() * 100 &#125;) &#125;, 3000) &#125;&#125;const geektime = new Geektimemodule.exports = geektime// index.js：const geektime = require(&#x27;./lib&#x27;)geektime.addListener(&#x27;newLession&#x27;, (res) =&gt; &#123; // 业务代码 if(res.price &lt; 80) &#123; console.log(&#x27;buy it&#x27;, res) &#125;&#125;) EverntEmitter的实例可以抛任意的事件出来，并且带着它想要的参数。我们可以把底层的逻辑封装起来，放在某个模块里如lib.js，外面的业务代码拿到这个模块，通过事件的监听器就能方便地知道子模块里面发生的变化，这种变化并不需要geektime调用里面的函数，只需要它往自己身上抛一个事件即可。这就是设计模式想要达到的目的，即扩展一些逻辑，完全不需要改动底层，就能提高程序的可维护性。 调用vs抛事件 比如老板通知秘书做某事，做好的方式还是调用，因为观察者模式抛事件的方式最适用的场景在于“不知道被通知者存在”以及“没有人监听还能继续下去”。 12-4 总结​ 经过模块这部分的研究，我们明确了Node.js的其中一个特点，就是它是一门具备可扩展性的全面的能在服务端运行的js技术。 13 异步-非阻塞i /o13-1 非阻塞i /o的定义 I/O即Input/Output，它指代一个系统的输入和输出 阻塞I/O和非阻塞I/O的区别就在于系统接收输入再到输出期间，能不能接收其他输入 【例1】排队打饭vs餐厅点菜 对于点菜人员来说，排队打饭是阻塞I/O，餐厅点菜是非阻塞I/O 系统=食堂阿姨/服务生，输入=点菜，输出=端菜 饭堂阿姨只能一份一份饭地打-&gt;阻塞I/O 服务生点完菜之后可以服务其他客人-&gt;非阻塞I/O 【例2】在Node.js论坛提问题：“这个Node.js问题怎么解决？在线等，急” 这也是个阻塞I/O的例子，因为在提问后到得到答案前什么都做不了，只能f5； 但是如果你提问后就去忙其他的了，待会再回来看是否有人回答，就是非阻塞I/O了。 综上说明，为什么非阻塞I/O能得到性能的提升，是因为它能把不必要的等待省略掉。 理解非阻塞I/O的要点在于： 确定一个进行Input/Output的系统。 思考在I/O过程中，能不能进行其他I/O。 13-2 非阻塞i /o代码演示 新建目录nonblocking，在里面新建index.js，并运行$ npm init，安装glob包$ npm install glob。 glob包的作用是能把目录下的所有文件和文件名递归地获取到。 index.js中阻塞I/O代码如下： 123456const glob = require(&#x27;glob&#x27;)let result = nullconsole.time(&#x27;glob&#x27;)result = glob.sync(__dirname + &#x27;/**/*&#x27;)console.timeEnd(&#x27;glob&#x27;)console.log(result) 打印结果及操作耗时如下： index.js中非阻塞I/O代码如下： 12345678910const glob = require(&#x27;glob&#x27;)let result = nullconsole.time(&#x27;glob&#x27;)glob(__dirname + &#x27;/**/*&#x27;, function(err, res) &#123; result = res // console.log(result) console.log(&#x27;got result&#x27;)&#125;)console.timeEnd(&#x27;glob&#x27;)console.log(1 + 1) 打印结果及操作耗时如下： 通过以上的代码演示，我们发现： 非阻塞I/O比阻塞I/O的耗时缩短了许多，减少了node.js的等待时间； 非阻塞I/O在glob方法回调前，就先执行了1+1计算，等glob方法有了结果，才打印出相应的结果。 13-3 nodejs架构图讲解 图中是按照线程重新划分，蓝框左半部分都是Node.js线程，它的所有I/O操作都是非阻塞的，它会把大量的计算能力分发到其他的C++线程去计算，等到其他C++线程把计算都执行完毕后，再把结果回调到Node.js线程，Node.js线程再把这个结果返回给应用程序。 LIBUV是实现Node.js非阻塞I/O的核心模块 14 异步-异步编程之callback14-1 回调函数 Node.js中的回调函数有一定的格式规范，叫做error-first callback或Node-style callback。含义是所有的callback函数都要遵循这个参数格式，即第一个参数是error，剩余的参数才是这个回调函数的执行结果。 未完待续……","categories":[{"name":"Node.js","slug":"Node-js","permalink":"https://scarlett9354.github.io/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://scarlett9354.github.io/tags/Node-js/"}]},{"title":"TypeScript开发实战","slug":"TypeScript开发实战","date":"2021-04-29T03:30:28.000Z","updated":"2021-05-11T02:59:08.507Z","comments":true,"path":"2021/04/29/TypeScript开发实战/","link":"","permalink":"https://scarlett9354.github.io/2021/04/29/TypeScript%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/","excerpt":"","text":"一 重塑类型思维 1 什么是typescript? 2 为什么要使用typescript? 二 类型基础 1 动态类型与静态类型 1-1 概念 1-2 从内存分配的角度对比js与c++ 1-3 总结 2 强类型语言和弱类型语言 3 语言类型象限 三 编写hello world ts程序 1 准备工作 2 配置构建工具, 使用webpack 2-1 安装 2-2 创建build目录, 用来存放所有的配置文件 3 修改npm脚本 4 ts的基本类型 4-1 类型对比 4-2 类型注解 4-3 新建src /datatype .ts, 里面定义各种类型的数据 5 ts的枚举类型 5-1 概念 5-2 分类 5-3 枚举成员 5-4 常量枚举 5-5 枚举类型 6 接口 (1): 对象类型接口 6-1 定义接口 6-2 绕过类型检查的方法 6-3 可选属性 (属性+? 格式) 6-4 只读属性 (readonly+ 属性 格式) 6-5 可索引类型的接口 7 接口 (2): 函数类型接口 7-1 定义接口 7-2 混合类型的接口 8 函数相关知识点梳理 8-1 定义函数的四种方式 8-2 函数参数 8-3 函数重载 9 类 (1): 继承和成员修饰符 9-1 类的基本实现 9-2 类的继承 (用extends关键字) 9-3 类的成员修饰符 (这是ts对es的扩展) 10 类 (2): 抽象类与多态 10-1 抽象类 10-2 多态 10-3 特殊的ts类型: this类型 11 类与接口的关系 11-1 类类型接口 11-2 接口的继承 11-3 接口继承类 11-4 接口和类的关系图 12 泛型 (1): 泛型函数与泛型接口 12-1 类类型接口 一 重塑类型思维JavaScript是一门动态弱类型语言。 1 什么是typescript? 根据官方定义，它是拥有类型系统的JavaScript的超集，可以编译成纯JavaScript。 需要注意三个要点：（1）类型检查 - TS会在编译代码时进行严格的静态类型检查，这意味着可以在编码阶段发现可能存在的隐患，而不是带到线上去。（2）语言扩展 - TS会包括来自ES6和未来提案中的特性，如异步操作和装饰器，也会从其他语言借助某些特性，如接口和抽象类。（3）工具属性 - TS可以编译成标准的JS，可以在任何浏览器和操作系统上运行，从这个角度讲，它更像是个工具，而不是一门独立的语言。 2 为什么要使用typescript?​ 其他好处，比如： VSCode具有强大的自动补全、导航和重构功能，这使得接口定义可以直接代替文档，同时也可以提高开发效率，降低维护成本。 TS可以帮团队重塑“类型思维”，接口的提供方将被迫去思考API的边界，他们将从代码的编写者蜕变为代码的设计者。 二 类型基础1 动态类型与静态类型1-1 概念 静态类型语言：在编译阶段确定所有变量的类型，如C++语言： 12345678class C &#123; public: int x int y&#125;int add(C a, C b) &#123; return a.x + a.y + b.x + b.y&#125; 动态类型语言：在执行阶段确定所有变量的类型，如JavaScript语言： 123456789class C &#123; constructor(x, y) &#123; this.x = x this.y = y &#125;&#125;function add(a, b) &#123; return a.x + a.y + b.x + b.y&#125; 1-2 从内存分配的角度对比js与c++ 1-3 总结 静态类型语言 动态类型语言 对类型极度严格 对类型非常宽松 立即发现错误 bug可能隐藏数月甚至数年 运行时性能好 运行时性能差 自文档化 可读性差 2 强类型语言和弱类型语言强类型语言：不允许程序在发生错误后继续执行 3 语言类型象限 三 编写hello world ts程序1 准备工作 预装软件NodeJs和VSCode 新建文件夹ts_in_action npm命令初始化工程：$ npm init -y，生成package.json文件 全局安装TypeScript：$ npm i typescript -g，这样我们可以在任何地方使用ts的编译器tsc，查看编译器的帮助信息$ tsc -h 创建配置项：$ tsc --init，生成tsconfig.json文件 新建src/index.ts文件：let hello: string = &#39;hello typescript&#39;，对其进行编译：$ tsc ./src/index.ts，会生成一个src/index.js文件：var hello = &#39;hello typescript&#39; 2 配置构建工具, 使用webpack2-1 安装$ npm i webpack webpack-cli webpack-dev-server -D，此属于开发环境配置 2-2 创建build目录, 用来存放所有的配置文件 webpack.base.config.js - 是公共环境的配置 指定入口文件： 1entry: &#x27;./src/index.ts&#x27; 配置输出文件： 123output: &#123; filename: &#x27;app.js&#x27;&#125; 输入的目录使用默认的dist目录，指定三个扩展名： 123resolve: &#123; extensions: [&#x27;.js&#x27;, &#x27;.ts&#x27;, &#x27;.tsx&#x27;]&#125; 安装ts相应的loader，并再次本地安装ts：$ npm i ts-loader typescript -D 1234567891011module: &#123; rules: [ &#123; test: /\\.tsx?$/i, use: [&#123; loader: &#x27;ts-loader&#x27; &#125;], exclude: /node_modules/ &#125; ]&#125; 安装使用插件html-webpack-plugin：$ npm i html-webpack-plugin -D，通过一个模板帮助我们生成一个网站的首页，并把输出文件自动嵌入到这个html文件中： 123456789const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)module.exports = &#123; ......, plugins: [ new HtmlWebpackPlugin(&#123; template: &#x27;./src/tpl/index.html&#x27; &#125;) ]&#125; 新建并编写这个模板文件src/tpl/index.html（输入html:5），修改title，在body中插入div： 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;TypeScript&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;app&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; webpack.dev.config.js - 是开发环境的配置 使用sourceMap，采用官方推荐的： 123module.exports = &#123; devtools: &#x27;cheap-module-eval-source-map&#x27;&#125; cheap表示sourceMap会忽略文件的列信息； module会定位到ts源码，而不是经过loader转义后的js源码； eval-source-map指会将sourceMap以dataUrl的形式打包到文件中，它的重编译速度很快，所以不必担心性能问题。 webpack.pro.config.js - 是生产环境的配置 安装插件$ npm i clean-webpack-plugin -D，它的作用是每次成功构建时，清空dist目录： 123456const &#123; CleanWebpackPlugin &#125; = require(&#x27;clean-webpack-plugin&#x27;)module.exports = &#123; plugins: [ new CleanWebpackPlugin() ]&#125; webpack.config.js - 是所有配置文件的入口 安装插件$ npm i webpack-merge -D，它的作用是把两个配置文件合并： 123456const merge = require(&#x27;webpack-merge&#x27;)const baseConfig = require(&#x27;./webpack.base.config&#x27;)const devConfig = require(&#x27;./webpack.dev.config&#x27;)const proConfig = require(&#x27;./webpack.pro.config&#x27;)let config = process.NODE_ENV === &#x27;development&#x27; ? devConfig : proConfigmodule.exports = merge(baseConfig, config) 3 修改npm脚本package.json文件 更改入口： 1&quot;main&quot;: &quot;./src/index.ts&quot;, 编写启动开发环境的命令并运行$ npm start，其中mode参数的作用是设置当前的环境变量，config是用来指定配置文件的： 123&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack-dev-server --mode=development --config ./build/webpack.config.js&quot;,&#125;, 编写生产环境的命令并运行$ npm run build，可以看到生成一个dist目录： 1&quot;build&quot;: &quot;webpack --mode=production --config ./build/webpack.config.js&quot;, 4 ts的基本类型4-1 类型对比 ES6的数据类型 6种基本数据类型：Boolean、Number、String、Symbol、undefined、null 3种引用类型：Array、Function、Object TS的数据类型 在ES6的基础上新增了多种类型：void、any、never、元组、枚举、高级类型 4-2 类型注解 作用：相当于强类型语言中的类型声明 语法：(变量/函数): type 4-3 新建src /datatype .ts, 里面定义各种类型的数据 原始类型： 123let bool: boolean = truelet num: number = 123let str: string = &#x27;abc&#x27; 数组： 12let arr1: number[] = [1, 2, 3]let arr2: Array&lt;number&gt; = [1, 2, 3] 以上的含义是该数组只能是number； 但如果我们需要添加其他类型，就要采用联合类型方式： 1let arr2: Array&lt;number | string&gt; = [1, 2, 3, &#x27;4&#x27;] 元组 - 是特殊的数组，它限定了数组元素的类型和个数： 1let tuple: [number, string] = [0, &#x27;1&#x27;] 我们可以通过push方法为元组添加新元素，但是不能越界访问，因此实际工作中不建议这样使用： 123tuple.push(2)console.log(tuple) // [0, &#x27;1&#x27;, 2]tuple[2] // 报错 函数： 1let add = (x: number, y: number): number =&gt; x + y 以上包括参数和返回值类型注解，通常返回值类型注解可以省略，这就利用了ts的类型推断功能。 也可以这样定义： 12let compute: (x: number, y: number) =&gt; numbercompute = (a, b) =&gt; a + b 对象： 12345let obj: object = &#123;x: 1, y: 2&#125;obj.x // 提示错误，因为不确定里面是否包含x属性// 改成这样就可以了：let obj: &#123;x: number, y: number&#125; = &#123;x: 1, y: 2&#125;obj.x symbol - 含义是具有唯一的值： 123let s1: symbol = Symbol()let s2 = Symbol()console.log(s1 === s2) // false undefined/null: 1234let un: undefined = undefinedlet nu: null = nullnum = undefined // 提示错误num = null // 提示错误 把一个变量赋值成undefined/null时，只能取undefined/null值，不能取其他类型的值；反之，其他类型却可以赋值给undefined/null，只不过需要对tsconfig.json做如下设置： 1&quot;strictNullChecks&quot;: false, 但是这种方式一般不推荐，如果非要对其他类型赋值undefined/null，最好使用联合类型，上面就不会报错了： 1let num: number | undefined | null = 123 void是js中的一种操作符，它可以让任何表达式返回undefined，如： 1void 0 // undefined 在ts中，void类型表示没有任何返回值的类型，比如一个没有任何返回值的函数： 1let noReturn = () =&gt; &#123;&#125; any类型 - 不定义类型时默认为any类型，可以任意赋值，不建议使用 never表示永远不会有返回值的类型，有两种情况：抛出异常函数和死循环函数 123456let error = () =&gt; &#123; throw new Error(&#x27;error&#x27;)&#125;let endless = () =&gt; &#123; while(true) &#123;&#125;&#125; 5 ts的枚举类型5-1 概念枚举是指一组有名字的常量集合，可以理解成手机里的通讯录，我们只需要记住人名即可，不需要记号码 5-2 分类 数字枚举 - 枚举值会递增，并采用反向映射的原理 1234567891011121314151617181920enum Role &#123; Reporter = 2, Developer, Maintainer, Owner, Guest&#125;console.log(Role.Reporter) // 2console.log(Role[4]) // Maintainerconsole.log(Role) // =&gt;// [2: &quot;Reporter&quot;// 3: &quot;Developer&quot;// 4: &quot;Maintainer&quot;// 5: &quot;Owner&quot;// 6: &quot;Guest&quot;// Developer: 3// Guest: 6// Maintainer: 4// Owner: 5// Reporter: 2] 字符串枚举 - 编译结果显示只有成员名称作为key，所以它是不能进行反向映射的 1234enum Message &#123; Success = &#x27;成功&#x27;, Fail = &#x27;失败&#x27;&#125; 异构枚举 - 数字枚举和字符串枚举混用的结果，容易引起混淆，不建议使用 1234enum Answer &#123; N, Y = &#x27;yes&#x27;&#125; 5-3 枚举成员 性质 - 枚举成员的值是只读类型，定义后不能修改 分类 const member（常量枚举），包括三种情况：没有初始值的情况、对已有枚举成员的引用、常量的表达式，常量枚举成员会在编译的时候计算结果，然后以常量的形式出现在运行时环境。 12345enum Char &#123; a, b = Char.a, c = 1 + 4&#125; computed member，指需要被计算的枚举成员，是一些非常量的表达式，这些枚举成员的值不会在编译阶段计算，而是在程序执行阶段计算。 12345enum Char &#123; d = Math.random(), e = &#x27;123&#x27;.length, f // 提示错误&#125; 特别注意：在computed member后的成员一定要赋给初始值，否则会提示错误 5-4 常量枚举 特性：会在编译阶段被移除 作用：当我们不需要一个对象，而需要这个对象的值时，就需要使用常量枚举，这样能减少在编译环境的代码，比如： 123456const enum Month &#123; Jan, Feb, Mar&#125;let month = [Month.Jan, Month.Feb, Month.Mar] 会被编译成： 1var month = [0 /* Jan */, 1 /* Feb */, 2 /* Mar */]; 5-5 枚举类型 在某些情况下，枚举和枚举成员都可以作为一种单独类型存在。 第一种情况，枚举成员没有任何初始值； 第二种情况，所有成员都是数字枚举； 第三种情况，所有成员都是字符串枚举。 123enum E &#123; a, b &#125;enum F &#123; a = 0, b = 1 &#125;enum G &#123; a = &#x27;apple&#x27;, b = &#x27;banana&#x27; &#125; 对于第一种和第二种情况，可以把任意的number类型赋值给枚举类型，它的取值也可以超出枚举成员的定义，但是两种不同类型的枚举不能进行比较： 123let e: E = 3let f: F = 3// console.log(e === f) // 提示错误 12345let e1: E.a = 1let e2: E.b// console.log(e1 === e2) // 提示错误let e3: E.a = 1console.log(e1 === e3) // true 而第三种情况字符串枚举的取值只能是枚举成员的类型： 12let g1: G = G.alet g2: G.a = G.a 6 接口 (1): 对象类型接口6-1 定义接口1234567891011121314151617181920interface List &#123; id: number; name: string;&#125;interface Result &#123; data: List[]&#125;function render(result: Result) &#123; result.data.forEach((value) =&gt; &#123; console.log(value.id, value.name) &#125;)&#125;let result = &#123; data: [ &#123;id: 1, name: &#x27;A&#x27;&#125;, &#123;id: 2, name: &#x27;B&#x27;&#125; ]&#125;render(result) // 1 &quot;A&quot; // 2 &quot;B&quot; 后端有时候会传来约定之外的字段，ts并不报错。所以只要传入的对象是必要条件就是被允许的： 123456let result = &#123; data: [ &#123;id: 1, name: &#x27;A&#x27;, sex: &#x27;male&#x27;&#125;, &#123;id: 2, name: &#x27;B&#x27;&#125; ]&#125; 但是我们直接传入对象字面量，ts就会对额外的字段进行类型检查： 123456render(&#123; data: [ &#123;id: 1, name: &#x27;A&#x27;, sex: &#x27;male&#x27;&#125;, // 提示错误 &#123;id: 2, name: &#x27;B&#x27;&#125; ]&#125;) 6-2 绕过类型检查的方法 第一种方式，是像我们上面那样，将对象赋值给一个变量 第二种方式是类型断言：as + 对象的类型，我们明确地告诉编译器，对象的类型就是Result，编译器就会绕过类型检查 123456render(&#123; data: [ &#123;id: 1, name: &#x27;A&#x27;, sex: &#x27;male&#x27;&#125;, // 提示错误 &#123;id: 2, name: &#x27;B&#x27;&#125; ]&#125; as Result) 类型断言的另一种不建议用的方法，就是在对象前面加上，但是在React种容易产生歧义。 第三种方法是使用字符串索引签名，格式如下： 12345interface List &#123; id: number; name: string; [x: string]: any;&#125; 该签名的含义是用任意的字符串去索引List，会得到任意的结果，这样List就支持多个属性了。 6-3 可选属性 (属性+? 格式) 假设有个新需求，需要判断value中是否有个新字段，如果有，就把它打印出来： 1234567891011121314151617181920212223interface List &#123; id: number; name: string; age?: number;&#125;interface Result &#123; data: List[]&#125;function render(result: Result) &#123; result.data.forEach((value) =&gt; &#123; console.log(value.id, value.name) if(value.age) &#123; console.log(value.age) &#125; &#125;)&#125;let result = &#123; data: [ &#123;id: 1, name: &#x27;A&#x27;, sex: &#x27;male&#x27;&#125;, &#123;id: 2, name: &#x27;B&#x27;&#125; ]&#125;render(result) 在render函数中进行判断，会提示错误，这时我们在List中添加属性age，result会报错，这就需要我们使用可选属性了。 6-4 只读属性 (readonly+ 属性 格式) 只读属性不允许修改： 12345678interface List &#123; readonly id: number;&#125;function render(result: Result) &#123; result.data.forEach((value) =&gt; &#123; value.id ++ // 提示错误 &#125;)&#125; 6-5 可索引类型的接口 以上属性的个数是固定的，当我们不确定属性个数时，就要用到可索引类型的接口，常用的有两种： 用数字索引的接口： 123interface StringArray &#123; [index: number]: string&#125; 含义是用任意的数字去索引StringArray，会得到一个string，这就相当于声明了一个字符串类型的数组。比如： 1let chars: StringArray = [&#x27;A&#x27;, &#x27;B&#x27;] 用字符串索引的接口： 123interface Names &#123; [x: string]: string&#125; 含义是用任意的字符串索引Names，得到的结果都是string，这样我们就不能并列声明number类型的成员了： 12345interface Names &#123; [x: string]: string y: number // 提示错误 z: string&#125; 这两种索引签名是可以混用的： 1234interface Names &#123; [x: string]: string [z: number]: string&#125; 需要注意的是，数字索引签名的返回值一定要是字符串索引签名返回值的子类型，这是因为js会进行类型转换，将number转成string，这样就能保证类型的兼容性。比如下面这样就会报错： 1234interface Names &#123; [x: string]: string [z: number]: number // 提示错误&#125; 但这样就可以： 1234interface Names &#123; [x: string]: any [z: number]: number&#125; 7 接口 (2): 函数类型接口7-1 定义接口 用变量定义函数类型： 1let add: (x: number, y: number) =&gt; number 用接口定义函数类型： 123interface Add &#123; (x: number, y: number): number&#125; 用类型别名定义函数类型（更简洁）： 12type Add = (x: number, y: number) =&gt; numberlet add: Add = (a, b) =&gt; a + b 7-2 混合类型的接口 这种接口既可以定义一个函数，也可以像对象一样拥有属性和方法： 12345678interface Lib &#123; (): void version: string doSomething(): void&#125;let lib: Lib = (() =&gt; &#123;&#125;) as Liblib.version = &#x27;1.0&#x27;lib.doSomething = () =&gt; &#123;&#125; 改造一下上例，我们可以创造多个lib实例： 12345678910function getLib() &#123; let lib: Lib = (() =&gt; &#123;&#125;) as Lib lib.version = &#x27;1.0&#x27; lib.doSomething = () =&gt; &#123;&#125; return lib&#125;let lib1 = getLib()lib1()lib1.doSomething()let lib2 = getLib() 8 函数相关知识点梳理8-1 定义函数的四种方式 第一种，用function定义，需要明确地指出参数的类型，而函数的返回值可以通过ts的类型推断省去： 123function add1(x: number, y: number) &#123; return x + y&#125; 第二种，通过一个变量定义函数类型 1let add2: (x: number, y: number) =&gt; number 第三种，通过类型别名定义函数类型 1type add3 = (x: number, y: number) =&gt; number 第四种，通过接口定义函数类型 123interface add4 &#123; (x: number, y: number): number&#125; 注意：后三种只是定义函数类型，而没有具体的实现。 8-2 函数参数 在ts中形参和实参必须一一对应，多一个少一个都不行。 可选参数（格式：参数名 + ?），即可传可不传，需要注意的是可选参数必须位于必选参数之后： 1234function add5(x: number, y?: number) &#123; return y ? x + y : x&#125;console.log(add5(2)) // 2 为参数提供默认值： 1234function add6(x: number, y = 1, z: number, q = 4) &#123; return x + y + z + q&#125;console.log(add6(1, undefined, 3)) // 9 需要注意的是，在必选参数前，默认参数不可省略，必须明确传入undefined来获取默认值。 以上参数的个数都是固定的，当参数不确定时，就可以使用剩余参数（格式：…参数集合: 类型）： 1234function add7(x: number, ...rest: number[]) &#123; return x + rest.reduce((pre, cur) =&gt; pre + cur)&#125;console.log(add7(2, 3, 2, 13, 4)) // 24 8-3 函数重载 其他语言的函数重载： 含义：如果两个函数名称相同，但是参数类型和个数不同，就实现了函数重载。 好处：不需要为了相似功能的函数选用不同的函数名称，这样增强了函数的可读性。 ts的函数重载要求我们先定义一系列名称相同的函数声明，然后再定义一个更宽泛的函数： 12345678910111213function add8(...rest: number[]): numberfunction add8(...rest: string[]): stringfunction add8(...rest: any[]): any &#123; let first = rest[0] if(typeof first === &#x27;string&#x27;) &#123; return rest.join(&#x27;-&#x27;) &#125; if(typeof first === &#x27;number&#x27;) &#123; return rest.reduce((pre, cur) =&gt; pre + cur) &#125;&#125;console.log(add8(1, 2, 3)) // 6console.log(add8(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;)) // a-b-c ts编译器在处理重载时，会去查询一个重载的列表，也就是我们前面定义的这个列表，并且会尝试第一个定义，如果匹配，就使用这个函数定义，如果不匹配，就接着往下查找，所以我们要把最容易匹配的函数定义写到最前面。 9 类 (1): 继承和成员修饰符9-1 类的基本实现 定义一个Dog类，与ES不同的是，我们为成员属性添加了类型注解，也为构造函数的参数增加了类型注解。 1234567class Dog &#123; constructor(name: string) &#123; this.name = name &#125; name: string run() &#123;&#125;&#125; 需要注意的是： 无论是在ES还是ts中，类成员的属性都是实例属性，而不是原型属性；类成员的方法也都是实例方法。对比可见： 123console.log(Dog.prototype) // &#123;run: ƒ, constructor: ƒ&#125;let dog = new Dog(&#x27;wangwang&#x27;)console.log(dog) // Dog &#123;name: &quot;wangwang&quot;&#125; 与ES不同的是，实例的属性必须具有初始值，或者在构造函数中被初始化。 以下√的三种方式均是可以的： 12345678class Dog &#123; constructor(name: string) &#123; // this.name = name √ &#125; // name: string = &#x27;dog&#x27; √ // name?: string = &#x27;dog&#x27; √ run() &#123;&#125;&#125; 9-2 类的继承 (用extends关键字)1234567class Husky extends Dog &#123; constructor(name: string, color: string) &#123; super(name) this.color = color &#125; color: string&#125; 需要注意的是： 派生类的构造函数必须包含‘super’调用，而且参数必须包含父类的参数。 新添加的属性要初始化，一般在constructor中，而且用到的this必须在super调用后才能调用。 9-3 类的成员修饰符 (这是ts对es的扩展) 公有成员：对所有人都是可见的，格式public+属性/函数名 私有成员，也能在类的本身被调用，而不能被类的实例调用，也不能被子类调用，格式private+属性/函数名 12345678910111213141516class Dog &#123; constructor(name: string) &#123; this.name = name &#125; name: string run() &#123;&#125; private pri() &#123;&#125;&#125;let dog = new Dog(&#x27;wangwang&#x27;)dog.pri() ❌class Husky extends Dog &#123; constructor(name: string) &#123; super(name) this.pri() ❌ &#125;&#125; 也可以给构造函数加上私有成员属性，作用是类既不能被实例化，也不能被继承，都会提示错误。 12345678class Dog &#123; private constructor(name: string) &#123; this.name = name &#125; name: string&#125;let dog = new Dog(&#x27;wangwang&#x27;) ❌class Husky extends Dog &#123; &#125; ❌ 受保护成员，只能在类或子类中访问，而不能在类的实例中访问，格式protected+属性/函数名。 123456789101112131415class Dog &#123; constructor(name: string) &#123; this.name = name &#125; name: string protected pro() &#123;&#125;&#125;let dog = new Dog(&#x27;wangwang&#x27;)dog.pro() ❌class Husky extends Dog &#123; constructor(name: string) &#123; super(name) this.pro() ✔ &#125;&#125; 构造函数也能被声明为protected，作用是这个类不能被实例化，只能被继承，就相当于声明了一个基类。 12345678910class Dog &#123; protected constructor(name: string) &#123; this.name = name &#125; name: string&#125;let dog = new Dog(&#x27;wangwang&#x27;) // ❌class Husky extends Dog &#123; ......&#125; 只读属性：不可以被更改，切记它跟实例属性一样，一定要被初始化。 1234567class Dog &#123; constructor(name: string) &#123; this.name = name &#125; name: string readonly legs: number = 4&#125; 构造函数的参数也可以添加修饰符，它的作用是将参数自动变成了实例的属性，这样就能省略在类中的定义了。 1234567class Husky extends Dog &#123; constructor(name: string, public color: string) &#123; super(name) this.color = color &#125; // color: string&#125; 静态成员：只能通过类名来调用，而不能通过子类调用，它是可以被继承的，格式static修饰符+属性名。 1234567891011121314151617class Dog &#123; constructor(name: string) &#123; this.name = name &#125; name: string static food: string = &#x27;bones&#x27;&#125;let dog = new Dog(&#x27;wangwang&#x27;)console.log(Dog.food) // ✔// console.log(dog.food) ❌ class Husky extends Dog &#123; constructor(name: string, public color: string) &#123; super(name) this.color = color &#125;&#125;console.log(Husky.food) // ✔ 10 类 (2): 抽象类与多态10-1 抽象类 es中并没有引用抽象类的概念，这是ts对es又一次扩展，所谓抽象类就是只能被继承而不能被实例化的类。举例说明： 123456789101112131415161718192021222324// 定义抽象类Animalabstract class Animal &#123; // 定义方法，子类可以复用 eat() &#123; console.log(&#x27;eat&#x27;) &#125; // 也可以不指定方法的具体实现，这就构成了抽象方法 abstract sleep(): void // 好处是，明确知道子类可以有其他的实现，就没必要在父类中实现了&#125;// 实例化// let animal = new Animal() // ❌提示无法创建抽象类的实例，说明它只能被继承class Dog extends Animal &#123; constructor(name: string) &#123; super() this.name = name &#125; name: string run() &#123;&#125; sleep() &#123; console.log(&#x27;dog sleep&#x27;) &#125;&#125;let dog = new Dog(&#x27;wangwang&#x27;)dog.eat() 抽象类的好处是可以抽离出一些事物的共性，有利于代码的复用和扩展。 抽象类也可以实现多态，所谓多态就是在父类中定义一个抽象方法，在多个子类中对这个方法有不同的实现，在程序运行时会根据不同的对象执行不同的操作，这样就实现了运行时的绑定。 10-2 多态 紧接上例： 12345678910class Cat extends Animal &#123; sleep() &#123; console.log(&#x27;Cat sleep&#x27;) &#125;&#125;let cat = new Cat()let animals: Animal[] = [dog, cat]animals.forEach(i =&gt; &#123; i.sleep()&#125;) 10-3 特殊的ts类型: this类型 类的成员方法可以直接返回一个this，可以很方便地实现链式调用。 123456789class WorkFlow &#123; step1() &#123; return this &#125; step2() &#123; return this &#125;&#125;new WorkFlow().step1().step2() 在继承的时候，this类型也可以表现出多态，这里的多态是指this既可以是父类型也可以是子类型。 123456class MyFlow extends WorkFlow &#123; next() &#123; return this &#125;&#125;new MyFlow().next().step1().next().step2() 以上调用先返回子类的类型再返回父类的类型然后再返回子类的类型，这样就保持了父类和子类之间接口调用的连贯性。 11 类与接口的关系11-1 类类型接口 即一个接口可以约束类成员有哪些属性以及它们的类型。 123456789101112131415interface Human &#123; // new (name: string): void ❌ 会提示类Asian错误地实现Human name: string eat(): void&#125;// 用Asian实现了这个接口，采用implements关键字class Asian implements Human &#123; constructor(name: string) &#123; this.name = name &#125; // private name: string // ❌ name: string eat() &#123;&#125; sleep() &#123;&#125;&#125; 类实现接口时，必须实现接口中声明的所有属性 接口只能约束类的公有成员 接口也不能约束类的构造函数 11-2 接口的继承 接口的继承可以抽离出可重用的接口，也可以将多个接口合并成一个接口。紧接上例： 12345678910111213interface Man extends Human &#123; run(): void&#125;interface Child &#123; cry(): void&#125;interface Boy extends Man, Child &#123;&#125;let boy: Boy = &#123; name: &#x27;&#x27;, run() &#123;&#125;, eat() &#123;&#125;, cry() &#123;&#125;&#125; 11-3 接口继承类 接口除了可以继承接口之外，还可以继承类，这就相当于接口把类的成员都抽象出来，也就是只有类的成员结构，而没有具体的实现。 123456789101112131415class Auto &#123; state = 1 // private state2 = 0 ❌ 下面会提示类C错误实现接口AutoInterface&#125;interface AutoInterface extends Auto &#123; // 这个接口中隐含了state属性&#125;// 要想实现AutoInterface接口，只需要定义一个类的成员有state属性即可class C implements AutoInterface &#123; state = 1&#125;// 此外Auto的子类也可以实现AutoInterface这个接口class Bus extends Auto implements AutoInterface &#123; // 这里我们就不必实现state属性了，因为Bus是Auto的子类，自然就继承state属性&#125; 注意：接口在抽离类的成员的时候，不仅抽离了公共成员，而且抽离了私有成员和受保护成员 11-4 接口和类的关系图 12 泛型 (1): 泛型函数与泛型接口很多时候，我们希望一个函数或者一个类可以支持多种数据类型，有很大的灵活性 12-1 类类型接口未完待续……","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://scarlett9354.github.io/categories/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://scarlett9354.github.io/tags/TypeScript/"}]},{"title":"从基础到实战-手把手带你掌握新版Webpack4","slug":"从基础到实战-手把手带你掌握新版Webpack4","date":"2021-04-28T09:39:13.000Z","updated":"2021-05-06T09:56:40.537Z","comments":true,"path":"2021/04/28/从基础到实战-手把手带你掌握新版Webpack4/","link":"","permalink":"https://scarlett9354.github.io/2021/04/28/%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E5%AE%9E%E6%88%98-%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E6%8E%8C%E6%8F%A1%E6%96%B0%E7%89%88Webpack4/","excerpt":"","text":"第1章 前言 第2章 初识webpack 2-1 webpack究竟是什么 2-1-1 采用面对过程的方式写页面 2-1-2 采用面对对象的方式写页面 2-1-3 安装webpack 2-1-4 其他引入和导出方式 2-1-5 课后作业 2-2 webpack的正确安装方式 2-2-1 先安装node js 2-2-2 项目初始化 2-2-3 安装webpack 2-3 webpack的配置文件 2-3-1 配置 2-3-2 整理项目结构 2-3-3 如何用npm scripts简化打包代码 2-3-4 课后作业 2-4 浅析webpack打包的知识点 2-4-1 解读打包输出信息 第3章 webpack核心概念 3-1 loader是什么 3-1-1 打包图片等静态资源 3-1-2 loader是什么 3-2 使用loader打包静态资源 (图片篇) 3-2-1 关于打包后的图片名称 3-2-2 打包多种格式的图片 3-2-3 打包到哪个文件夹 3-2-4 url-loader 3-2-5 课后作业 3-3 使用loader打包静态资源 (样式篇-上) 3-3-1 准备工作 3-3-2 配置与安装 3-3-3 两个loader的作用 3-3-4 scss的打包和使用 3-3-5 自动添加css3厂商前缀 (自己的demo中没成功) 3-4 使用loader打包静态资源 (样式篇-下) 3-4-1 css-loader的配置项 3-4-2 css打包的模块化 3-4-3 使用webpack打包第三方字体文件 3-4-4 课后作业 3-5 使用plugins让打包更便捷 3-5-1 html-webpack-plugin 3-5-2 clean-webpack-plugin 3-5-3 总结plugin的作用 3-6 entry与output的基础配置 3-6-1 实现新需求-把src下的index js打包两次生成不同的js 3-6-2 实现新需求-后台用index html作为入口 其他静态资源如js放到cdn上 3-6-3 课后作业 3-7 sourcemap的配置 3-7-1 关闭sourcemap 3-7-2 sourcemap的适用场景 3-8 使用webpack-dev-server提升开发效率 3-8-1 实现开发需求-边改东西边自动打包 不再手动打包了 3-8-2 参考以下文档 3-8-3 课后作业 3-9 hot module replacement (hmr) 热模块更新 (1) 3-9-1 针对css文件的使用 3-9-2 针对js文件的使用 3-10 hot module replacement (hmr) 热模块更新 (2) 3-10-1 针对js文件的使用 3-10-2 课后作业 3-11 使用babel处理es6语法 (1) 3-11-1 在webpack中使用babel 3-12 使用babel处理es6语法 (2) 3-12-1 配置项targets 3-12-2 babel plugin-transform-runtime 3-13 webpack实现对react框架代码的打包 3-13-1 准备工作 3-13-2 安装与使用 第4章 webpack进阶 (高级概念) 4-1 tree shaking概念详解 4-1-1 tree shaking是什么 4-1-2 使用tree shaking 4-2 development和production模式的区分打包 4-2-1 development模式 4-2-2 production模式 4-2-3 两种模式的差异 4-2-4 两种模式下的配置文件 4-2-5 解决多个配置文件的重复问题 4-2-6 整理以上几个配置文件 4-3 webpack和code splitting 4-3-1 准备工作 4-3-2 code splitting代码分割 4-3-3 总结 4-5 split-chunks-plugin配置参数详解 (1) 4-5-1 magic-comment魔法注释 4-5-2 详解split-chunks-plugin的配置参数 4-7 lazy loading懒加载和chunk是什么 4-7-1 懒加载 4-7-2 chunk的概念 4-8 打包分析-preloading和prefetching 4-8-1 打包分析 4-8-2 prefetching和preloading 4-9 css文件的代码分割 4-9-1 css in js 4-9-2 借助mini-css-extract-plugin将css打包到dist下 而不是放到js中 4-9-3 压缩css代码 4-9-4 将所有入口的css文件打包分割成一个css文件 4-9-5 根据入口不同将css文件打包到不同的css文件中 4-10 webpack与浏览器缓存 (caching) 4-10-1 浏览器缓存 4-10-2 contentHash 4-11 shimming (垫片) 的作用 4-11-1 全局配置jquery 4-11-2 imports-loader 4-11-3 课后阅读 4-12 环境变量的使用方法 4-12-1 调整配置文件 第5章 webpack实战配置案例 5-1 library的打包 5-1-1 实现打包一个函数库的准备工作 5-1-2 真正实现打包一个函数库 5-1-3 打包库时引入其他库 第6章 webpack底层原理及脚手架工具分析 第1章 前言 webpack4与之前版本比较的优势： 速度更快，大型项目节约90%的构建时间 内置了更多默认配置，变更了许多API 主要涵盖以下内容： Loader、HMR、Create React App、Caching、Plugin、SourceMap、Vue Cli 3.0、Shimming、WebpackDevServer、TreeShaking、CodeSplitting、Babel、React、Library、Eslint、PWA、Vue、Mode、性能优化、多页应用、原理、PreLoading、PreFetching、环境变量、TypeScript 第2章 初识webpack2-1 webpack究竟是什么2-1-1 采用面对过程的方式写页面 index.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;这是一个原始页面&lt;/p&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; index.js 12345678910var dom = document.getElementById(&#x27;root&#x27;)var header = document.createElement(&#x27;div&#x27;)header.innerText = &#x27;header&#x27;dom.append(header)var sidebar = document.createElement(&#x27;div&#x27;)sidebar.innerText = &#x27;sidebar&#x27;dom.append(sidebar)var content = document.createElement(&#x27;div&#x27;)content.innerText = &#x27;content&#x27;dom.append(content) 所有的代码都堆在index.js文件中，代码长而冗余 2-1-2 采用面对对象的方式写页面 index.html 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;这是一个原始页面&lt;/p&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script src=&quot;./header.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./content.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./sidebar.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; header.js 12345function Header() &#123; var header = document.createElement(&#x27;div&#x27;) header.innerText = &#x27;header&#x27; dom.append(header)&#125; sidebar.js 12345function Sidebar() &#123; var sidebar = document.createElement(&#x27;div&#x27;) sidebar.innerText = &#x27;sidebar&#x27; dom.append(sidebar)&#125; content.js 12345function Content() &#123; var content = document.createElement(&#x27;div&#x27;) content.innerText = &#x27;content&#x27; dom.append(content)&#125; index.js 1234var dom = document.getElementById(&#x27;root&#x27;)new Header()new Sidebar()new Content() 这样在一个页面引入多个js，就会带来新的问题： （1）多出三个http请求，页面加载速度会变慢 （2）在index.js中只能看出创建header、sidebar和content，无法看出这三个对象的位置 （3）很难查错，比如其中的sidebar.js在index.js后引入，就会出现报错，但是很难排查出报错原因针对以上三个问题，采用import…from…方法 123456import Header from &#x27;./header&#x27;import Sidebar from &#x27;./sidebar&#x27;import Content from &#x27;./content&#x27;new Header()new Sidebar()new Content() 2-1-3 安装webpack 在项目目录下运行$ npm init 命令，一路回车 运行$ npm install webpack-cli --save-dev，通常情况下，这个命令会将webpack一起安装了，如果不放心，重新安装下webpack也行$ npm install webpack --save 用webpack来翻译index.js$ npx webpack index.js，这时候会生成一个dist目录，下面有个main.js便是翻译好的js文件，因此在index.html中修改引入：&lt;script src=&quot;./dist/main.js&quot;&gt;&lt;/script&gt; 此时运行页面会报一个错：Uncaught TypeError: o.a is not a constructor，这是因为要import的模块未export导出，修正后的header.js如下： 1234567function Header() &#123; var dom = document.getElementById(&#x27;root&#x27;) var header = document.createElement(&#x27;div&#x27;) header.innerText = &#x27;header&#x27; dom.append(header)&#125;export default Header 2-1-4 其他引入和导出方式 CommonJs - Node里最常用的模块引入规范 header.js： 1module.exports = Header index.js： 123456var Header = require(&#x27;./header.js&#x27;)var Sidebar = require(&#x27;./sidebar.js&#x27;)var Content = require(&#x27;./content.js&#x27;)new Header()new Sidebar()new Content() CMD AMD 综上，Webpack是个模块打包工具！ 2-1-5 课后作业 阅读webpack模块化，中文文档 阅读api中MODULES，中文文档 2-2 webpack的正确安装方式2-2-1 先安装node js 尽量安装新版本的稳定版，因为能很大程度上提高webpack的打包速度，此外也要保持webpack版本尽量新，高版本webpack会利用node新版本中一些特性提高打包速度 去NodeJs官网直接下载安装 在控制台运行$ node -v查看版本号，再运行$ npm -v，能输出对应的版本号，说明node安装的没有任何问题 2-2-2 项目初始化 创建项目文件夹$ mkdir webpack-demo 进入项目文件夹 $ cd webpack-demo 以node规范的形式创建一个项目或node的包文件 $ npm init，然后一路回车，或者直接运行$ npm init -y 就会直接自动生成一个默认的配置项 以上操作最终生成package.json文件，它描述了项目的一些信息： 1234567891011&#123; &quot;name&quot;: &quot;webpack-demo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; 对其做如下调整：（1）添加&quot;private&quot;: true 是指这个项目是个私有项目，不会被发布到npm仓库中去（2）去掉&quot;main&quot;: &quot;index.js&quot;，因为项目不会被外部引用，就没有必要向外暴露一个js文件（3）script 标签中的东西也可以先去掉（4）author 写上自己的名字（5）如果想开源，就把license 改为MIT 2-2-3 安装webpack （不推荐）全局安装 $ npm install webpack webpack-cli -g，安装完成后运行$ webpack -v 和webpack-cli -v 查看版本 卸载全局安装的webpacknpm uninstall webpack webpack-cli -g 直接在项目webpack-demo里安装npm install webpack webpack-cli -D 等同于npm install webpack webpack-cli --save-dev，目录下多了node_modules包。 此时运行$ webpack -v 不成功，因为node会尝试去全局找，所以找不到，但是我们能用node提供的npx运行webpack npx webpack -v，因为npx会在当前目录的node_modules寻找。 对比以上两种方式，后者的优点在于：比如此时又创建了一个项目叫做webpack-demo2，运行$ npm info webpack 先查看它所有的版本号，假如选个老版本安装$ npm install webpack@4.16.5 webpack-cli -D，这样就实现了在不同项目中安装不同版本的webpack。 webpack-cli的作用是使我们可以在命令行里正确运行webpack命令。 如果想把项目上传到git仓库，可以删掉node_modules，别人down下来代码后直接运行$ npm install 即可。 2-3 webpack的配置文件2-3-1 配置 新建文件webpack.config.js： 1module.exports = &#123; &#125; 配置入口entry，它的意思是从哪个文件开始打包 123module.exports = &#123; entry: &#x27;./index.js&#x27;&#125; 配置output，意思是放到哪里：（1）里面的filename是指给打包好的文件取的名字（2）里面的path是指打包好的文件放到哪个文件夹下，具体使用时要先引入node的核心模块path，然后调用模块的resolve方法，把__dirname这个变量（指当前的配置文件所在的当前目录路径）和bundle做个结合，这样生成的路径就是bundle这个文件夹的绝对路径了。 12345678const path = require(&#x27;path&#x27;)module.exports = &#123; entry: &#x27;./index.js&#x27;, output: &#123; filename: &#x27;bundle.js&#x27;, path: path.resolve(__dirname, &#x27;bundle&#x27;) &#125;&#125; （3）其实它还有个配置项叫chunkFilename，是打包并进行代码分割后对引入的需要分割的模块的命名（具体要学完codeSplitting才能理解）： 12345output: &#123; filename: &#x27;[name].js&#x27;, chunkFilename: &#x27;[name].chunk.js&#x27;, path: path.resolve(__dirname, &#x27;bundle&#x27;)&#125; 以上配置完成后，直接运行npx webpack 就能在主目录下生成bundle文件夹和文件。 假如我们新建的这个文件不叫webpack.config.js，而叫别的如webconfig.js，怎么才能正确打包呢？直接运行$ npx webpack --config webconfig.js 2-3-2 整理项目结构​ 以lession为例： 先删掉bundle文件夹 由于index.js是不能直接放到浏览器中运行的，它是我们的源代码，所以一般放在src目录里，其他现有的js也一样 修改配置文件webpack.config.js中相应的路径，然后再npx webpack打包： 12345678const path = require(&#x27;path&#x27;)module.exports = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123; filename: &#x27;bundle.js&#x27;, path: path.resolve(__dirname, &#x27;dist&#x27;) &#125;&#125; 注：如果不写path，webpack也会自动打包到dist目录 2-3-3 如何用npm scripts简化打包代码在package.json中的scripts下添加bundle命令，以下代码意思是当执行bundle命令时会自动执行webpack命令，这样就不需要运行npx webpack命令了，直接运行$ npm run bundle 即可 1234567&#123; ...... &quot;scripts&quot;: &#123; &quot;bundle&quot;: &quot;webpack&quot; &#125;, ......&#125; 综上，整理成的简单项目目录如下： 2-3-4 课后作业 阅读文档Getting Started，中文文档，巩固今天所讲的知识点 2-4 浅析webpack打包的知识点2-4-1 解读打包输出信息 Hash: 61ec62c5c1d570273ace，代表本次打包的唯一一个哈希值 Version: webpack 4.35.3，代表本次打包使用的webpack4.35.3版本 Time: 112ms，代表当前这个包整体打包耗时是112ms 以下分别代表： Asset打包出一个bundle.js文件； Size指这个文件的大小是1.36KB； Chunks：复杂打包时会打包出很多文件，每个文件都有一个自己的id值，chunks里不仅放着自己文件bundle.js的id值，还会放其他打包出来的文件的id； Chunk Names则是指每个打包出来的js文件对应的名字，这里名字之所以叫main，是因为配置文件中的entry实际上：entry: &#39;./src/index.js&#39;, 等同于 entry: &#123; main: &#39;./src/index.js&#39; &#125; Entrypoint main = bundle.js代表入口文件 然后以此打包以下文件： 以下警告是因为我们在webpack配置时，没有指定打包的环境/模式mode： 在不写的情况下，默认模式为’production’，代码会被压缩；如果把mode改为’development’，打包后代码不会被压缩。 webpack.config.js： 1234module.exports = &#123; mode: &#x27;development&#x27;, ......&#125; 第3章 webpack核心概念3-1 loader是什么3-1-1 打包图片等静态资源 直接打包会报错，需要去配置文件webpack.config.js中添加module-&gt;rules： 123456789101112module.exports = &#123; ...... module: &#123; rules: [&#123; test: /\\.jpg$/, // 写法基本固定 use: &#123; loader: &#x27;file-loader&#x27; &#125; &#125;] &#125;, ......&#125; 这里打包jpg，用到file-loader工具，所以需要安装$ npm install file-loader -D 以上可以解读为：遇到模块module时，看它符合哪个规则rules，然后求助于use对应的loader进行打包。 file-loader在底层帮我们做了几件事情：（1）会把引入的图片打包移动到dist目录下，该图片会得到一个相对dist的名称（2）然后该名称/地址会作为一个返回值返回引入该模块的变量之中 理论上，file-loader可以处理任何形式的静态资源 同理，打包.vue文件时，只需要在rules数组里添加一项即可： 123456&#123; test: /\\.vue$/, use: &#123; loader: &#x27;vue-loader&#x27; &#125;&#125; 3-1-2 loader是什么 其实loader就是一个打包的方案，因为webpack不能识别非js结尾的文件，但是loader知道对于某个特定文件webpack应该如何进行打包 改写index.js： 12345import Avatar from &#x27;./timg.jpg&#x27;var img = new Image()img.src = Avatarvar root = document.getElementById(&#x27;root&#x27;)root.append(img) 3-2 使用loader打包静态资源 (图片篇)3-2-1 关于打包后的图片名称需要使用placeholders占位符语法，在module-&gt;rules-&gt;use下添加options： 123456use: &#123; loader: &#x27;file-loader&#x27;, options: &#123; name: &#x27;[name]_[hash].[ext]&#x27; &#125;&#125; 详见占位符： [ext] 表示文件后缀 [hash] 表示打包出的文件的哈希值 3-2-2 打包多种格式的图片在module-&gt;rules-&gt;test的正则中补充： 1test: /\\.(jpg|png|gif)$/, 3-2-3 打包到哪个文件夹假如想打包到dist下的images文件夹中，在module-&gt;rules-&gt;use-&gt;options下添加outputPath。 3-2-4 url-loader 它能实现file-loader所能实现的所有功能： 123456789101112module: &#123; rules: [&#123; test: /\\.(jpg|png|gif)$/, use: &#123; loader: &#x27;url-loader&#x27;, options: &#123; name: &#x27;[name]_[hash].[ext]&#x27;, outputPath: &#x27;images/&#x27; &#125; &#125; &#125;]&#125;, 使用前也要先安装$ npm install url-loader -D，然后运行$ npm run bundle，发现图片并没有被打包到dist目录下，但是却以base64格式出现在bundle.js中 url-loader带来的好处与问题：图片被打包到js中，那么加载好js，图片也就加载好了，不用额外请求图片地址了，省了一次http请求，但是带来了新问题：如果这张图片特别大，那么打包生成的js文件也会特别大，那么加载js的时间就会很长，所以一开始很长时间里页面什么东西都显示不出来，所以url-loader的最佳使用方式是什么呢？特别小的图片直接打包到js中，大图还是像file-loader那样打包到dist下。 以上具体怎么做呢？在module-&gt;rules-&gt;use-&gt;options下添加limit，它的意思是如果图片超过limit范围（单位：字节Kb）就会被打包到dist目录下，未超出，就直接打包到js中。 1234options: &#123; ...... limit: 20480&#125; 3-2-5 课后作业 阅读file-loader文档 阅读url-loader文档 3-3 使用loader打包静态资源 (样式篇-上)3-3-1 准备工作 新建src/index.css： 1234.avatar &#123; width: 100px; height: 100px;&#125; 在src/index.js中引入，并给img添加class： 1234567import Avatar from &#x27;./timg.jpg&#x27;import &#x27;./index.css&#x27;var img = new Image()img.src = Avatarimg.classList.add(&#x27;avatar&#x27;)var root = document.getElementById(&#x27;root&#x27;)root.append(img) 3-3-2 配置与安装 module-&gt;rules下添加配置项： 1234&#123; test: /\\.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;]&#125; 安装以上两个loader$ npm install style-loader css-loader -D 3-3-3 两个loader的作用 新建src/avatar.css： 1234.avatar &#123; width: 200px; height: 200px;&#125; 在src/index.css中引入avatar.css： 1@import &#x27;./avatar.css&#x27; css-loader会帮助分析出几个css之间的关系，最终把这些css文件合并成一个css；style-loader会把css-loader生成的css文件内容挂载到页面head中，因此二者要配合使用。 3-3-4 scss的打包和使用 修改index.css为index.scss并采用sass语法编写，然后在index.js引入： 123456body &#123; .avatar &#123; width: 200px; height: 200px; &#125;&#125; 1import &#x27;./index.scss&#x27; 修改配置项： 1234&#123; test: /\\.scss$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;sass-loader&#x27;]&#125; 因为此处用到sass-loader，根据官网，需要安装$ npm install sass-loader node-sass -D，然后重新run即可 在webpack的配置中，loader是有先后顺序的，按照从下向上、从右到左的顺序执行，所以以上可以解读为： 当我们打包一个sass文件时，首先会执行sass-loader，对sass代码进行翻译成css代码，给到css-loader，然后都处理好后再给到style-loader，由它挂载到页面上。 3-3-5 自动添加css3厂商前缀 (自己的demo中没成功) 采用postcss-loader，照样是先安装$ npm i postcss-loader -D，再配置： 123456789&#123; test: /\\.scss$/, use: [ &#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;sass-loader&#x27;, &#x27;postcss-loader&#x27; ]&#125; 创建一个postcss.config.js文件，并配置相应的插件，这个插件需要先进行安装$ npm install autoprefixer -D： 12345module.exports = &#123; plugins: [ require(&#x27;autoprefixer&#x27;) ]&#125; 3-4 使用loader打包静态资源 (样式篇-下)3-4-1 css-loader的配置项 不用字符串形式，采用对象形式： 1234567891011121314&#123; test: /\\.scss$/, use: [ &#x27;style-loader&#x27;, &#123; loader: &#x27;css-loader&#x27;, options: &#123; importLoaders: 2 &#125; &#125;, &#x27;sass-loader&#x27;, &#x27;postcss-loader&#x27; ]&#125; 上面的情况主要解决index.scss文件中再引入@import其他的sass文件如avatar.scss，原本它只使用css-loader，不会从postcss到sass再到css…，采用importLoaders使得avatar.scss也要先运行前面的2个loader才到css-loader。 3-4-2 css打包的模块化 CSS Modules即模块化的css，为了防止样式引入后影响全局，需要先添加配置module:true，即开启css模块化打包功能： 1234567&#123; loader: &#x27;css-loader&#x27;, options: &#123; importLoaders: 2, module: true &#125;&#125;, 然后采用以下方式在当前文件src/index.js中引入使用样式： 123import style from &#x27;./index.scss&#x27;......img.classList.add(style.avatar) 3-4-3 使用webpack打包第三方字体文件 以iconfont为例，下载字体包，并把.eot、.svg、.ttf、.woff文件复制到src/font目录下 复制iconfont.css内容到src/index.scss中，并修改路径： 在webpack.config.js中对以上四种格式的文件.eot、.svg、.ttf、.woff进行配置： 1234567module: &#123; rules: [&#123; test: /\\.(eot|woff|ttf|svg)$/, use: &#123; loader: &#x27;file-loader&#x27; &#125; &#125;, 在src/index.js中引入并使用： 123import &#x27;./index.scss&#x27;var root = document.getElementById(&#x27;root&#x27;)root.innerHTML = &#x27;&lt;div class=&quot;iconfont icon-icon_bangzhuwendang&quot;&gt;&lt;/div&gt;&#x27; 3-4-4 课后作业 阅读Asset Management文档，详细讲解了CSS、Images和Fonts文件的打包形式，还额外介绍了Data数据文件（如.csv文件）的打包方法，还讲解了Webpack打包带来的好处和使用技巧。 仔细阅读loaders文档如sass-loader、css-loader、style-loader、postcss-loader 3-5 使用plugins让打包更便捷3-5-1 html-webpack-plugin 作用：它会在打包结束后，自动生成一个html文件，并把打包生成的js自动引入到这个html文件中。 先进行安装$ npm i -D html-webpack-plugin，再向webpack.config.js中添加配置项： 12345678const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)module.exports = &#123; mode: &#x27;development&#x27;, entry: &#123; ...... &#125;, module: &#123; ...... &#125;, output: &#123; ...... &#125;, plugins: [new HtmlWebpackPlugin()]&#125; 重新打包后生成的html模板中只引入了相应的js，并没有对应的dom元素，这就需要创造html模板，并将其配置进来再打包。 在src下新建index.html模板： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;html模板&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 对其进行配置： 123plugins: [new HtmlWebpackPlugin(&#123; template: &#x27;src/index.html&#x27;&#125;)] 3-5-2 clean-webpack-plugin 它是个第三方webpack插件，适用于当重新打包时能自动把dist目录先删除，然后再去执行打包 同样是先安装$ npm i -D clean-webpack-plugin，再配置： 1234567891011const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)const &#123; CleanWebpackPlugin &#125; = require(&#x27;clean-webpack-plugin&#x27;) // 注：此处跟视频讲的用法发生了变 module.exports = &#123; ...... plugins: [ new HtmlWebpackPlugin(&#123; template: &#x27;src/index.html&#x27; &#125;), new CleanWebpackPlugin() // 注：此处跟视频讲的用法发生了变化 ]&#125; 以上表示当我们在打包前会使用CleanWebpackPlugin删除dist目录下的所有内容 3-5-3 总结plugin的作用 plugin可以在webpack运行到某个时刻时，帮你做一些事情，它很类似vue或react的生命周期函数 以上的HtmlWebpackPlugin就是帮我们在打包过程结束后生成一个html文件，然后把打包生成的结果注入到html文件中 3-6 entry与output的基础配置3-6-1 实现新需求-把src下的index js打包两次生成不同的js 在output中使用占位符[name]，对应上面的main和sub，这时打包生成的index.html中会同时引入main.js和sub.js： 1234567891011121314151617module.exports = &#123; entry: &#123; main: &#x27;./src/index.js&#x27;, sub: &#x27;./src/index.js&#x27; &#125;, ...... plugins: [ new HtmlWebpackPlugin(&#123; template: &#x27;src/index.html&#x27; &#125;), new CleanWebpackPlugin() ], output: &#123; filename: &#x27;[name].js&#x27;, path: path.resolve(__dirname, &#x27;dist&#x27;) &#125;,&#125; 3-6-2 实现新需求-后台用index html作为入口 其他静态资源如js放到cdn上 在output中配置cdn的地址： 12345output: &#123; publicPath: &#x27;http://cdn.com.cn&#x27;, filename: &#x27;[name].js&#x27;, path: path.resolve(__dirname, &#x27;dist&#x27;)&#125;, 这样打包生成的index.html就这样引入js： 12&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.com.cn/main.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.com.cn/sub.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; 3-6-3 课后作业 简单阅读output文档，重点理解已讲过的publicPath、filename和path 阅读Entry and Context文档 仔细阅读Output Management文档，这里重点讲解了HtmlWebpackPlugin和CleanWebpackPlugin以及plugin的概念 仔细阅读HtmlWebpackPlugin文档，从下面的‘plugin documentation’进入查看详情 3-7 sourcemap的配置3-7-1 关闭sourcemap简化项目后，由于配置中mode为’development’说明是开发者模式，默认SourceMap已经被配进去了，如何关闭呢？ 1234module.exports = &#123; mode: &#x27;development&#x27;, devtool: &#x27;none&#x27;, ...... 3-7-2 sourcemap的适用场景 比如说我们把src/index.js中故意写错一行代码，打包仍然正常进行，但是页面console中会报错，我们点开后只能追溯到被打包的文件中（如dist/main.js第96行），怎样才能追溯到原文件中呢？这就需要SourceMap的帮助了！ SourceMap本质上是一个映射关系，它知道dist/main.js文件第96行对应的是src/index.js的第一行，所以就能知道具体哪段代码出错了。 怎么使用它呢？其实很简单，只要设置devtool: &#39;source-map&#39; 即可。 简单解读SourceMap文档： 当我们配置devtool: &#39;source-map&#39; 时，表格中build和rebuild的速度都是–，说明打包的过程都会变慢，因为它需要构建这种映射关系。这时dist目录下会多出一个main.js.map文件，这里面就是一个映射的对应关系。 带inline-前缀，那个.map文件就会变成一个base64字符串被放到dist/main.js中的底部： //# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJ...... 带cheap-前缀，就只把报错精确到行，能提升打包性能，而不是像上面两种精确到列； 另外，带cheap-前缀，它就只映射我们的业务代码，而不会管如loader这样的第三方模块如何映射。 但若想让cheap-前缀的sourceMap也映射第三方模块，就需要设置成devtool: &#39;cheap-module-source-map&#39;。 devtool: eval 的打包速度最快、性能最好，它不会产生.map文件也不会生成很长的base64字符串，只在main.js里多出一行代码： eval(&quot;consoele.log(&#39;hello world&#39;)\\n\\n//# sourceURL=webpack:///./src/index.js?&quot;); 但是针对比较复杂的代码，它提示出来的内容可能并不全面。 最佳实践：（1）开发环境mode:’development’采用devtool: cheap-module-eval-source-map，这种方式提示出的错误比较全，打包速度比较快。（2）生产环境mode:’production’采用devtool: cheap-module-source-map，这样它的提示效果会更好一些。 注意：面试中常会问到SourceMap的原理，有时间看看！！！ 3-8 使用webpack-dev-server提升开发效率3-8-1 实现开发需求-边改东西边自动打包 不再手动打包了 方法1：为package.json中的打包指令添加参数–watch，意思是webpack会帮我们监听它打包的文件，只要要打包的发生变化，就会重新打包（此方法还不够好）： 123&quot;scripts&quot;: &#123; &quot;watch&quot;: &quot;webpack --watch&quot;&#125;, 方法2：如果我们第一次运行时，既可以自动打包，又能帮我自动打开浏览器，还能模拟服务器上的特性，这就要借助WebpackDevServer来实现。 先进行安装$ npm i -D webpack-dev-server 在webpack.config.js中进行配置： 12345678module.exports = &#123; ...... entry: &#123; ...... &#125;, devServer: &#123; contentBase: &#x27;./dist&#x27; &#125;, module: &#123; ...... &#125;, ...... 以上配置的意思是服务器要启在哪个文件夹下，此处配置成当前目录下的dist下。 再去package.json中写个运行指令： 123&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack-dev-server&quot;&#125;, 运行成功后会提示Project is running at http://localhost:8080/，表示项目启动在8080端口，我们直接在浏览器中访问即可。 这种方法与方法1相比，不但会监听到文件发生了改变重新打包，还会自动刷新浏览器，因此用它能更方便地提升我们代码开发的效率。 若想实现devServer启动时自动打开浏览器并访问服务器地址，还需要下面的配置： 1234devServer: &#123; contentBase: &#x27;./dist&#x27;, open: true&#125;, 综上，我们为什么要开启这样的一个web服务器呢？因为如果还是按照原来的方式打开页面（地址为file:///C:/studyFiles/lession/dist/index.html），就不能在开发时发送ajax请求，因为ajax请求要求页面必须在一个服务器上，通过http协议的方式打开。而使用devServer后，页面地址为http://localhost:8080/是http的一个网址，所以能顺利发ajax请求。 我们常用的vue-cli3和react新版的脚手架底层也都使用了WebpackDevServer，所以能支持如proxy配置，它是帮助我们做跨域时要使用的接口代理： 1234567devServer: &#123; contentBase: &#x27;./dist&#x27;, open: true, proxy: &#123; &#x27;/api&#x27;: &#x27;http://localhost:3000&#x27; &#125;&#125;, 以上表示当访问http://localhost:8080/api/开头的接口时会自动转到http://localhost:3000 devServer还有好多其他的配置项，如端口port: 8080(默认)等 方法3 扩充眼界，非重点 在package.json中创建指令&quot;server&quot;: &quot;node server.js&quot;，意思是当运行middleware时，我想自己写个服务器，这个服务器如果监听到src下的内容有改变，它会像webpackDevServer一样帮助我们重启服务器、更新网页上的内容，那么怎么写server.js呢？ 在package.json同级创建server.js文件，因为在node环境下，我们选择使用express帮助快速搭建一个http服务器，因为这个服务器要监听webpack文件的变化，然后帮助自动重新打包，所以还要借助webpack的开发中间件webpack-dev-middleware，按照命令为$ npm i -D express webpack-dev-middleware 去webpack.config.js中的output下修改publicPath: ‘/‘，它表示所有的打包文件的引用前面都加个根路径： 12output: &#123; publicPath: &#x27;/&#x27;, // 可以不用配置 开始编写server.js 1234567const express = require(&#x27;express&#x27;)const webpack = require(&#x27;webpack&#x27;)// 创建一个服务器实例const app = express()app.listen(3000, () =&gt; &#123; console.log(&#x27;server is running&#x27;)&#125;) 其实写成这样就可以启动服务器了，运行’$ npm run server’ 试试看！ 继续编写server.js： 12345678910111213const express = require(&#x27;express&#x27;)const webpack = require(&#x27;webpack&#x27;)const webpackDevMiddleware = require(&#x27;webpack-dev-middleware&#x27;)const config = require(&#x27;./webpack.config&#x27;)const complier = webpack(config) // 用webpack结合配置文件可以随时进行代码的编译，让这个编译器执行一次就会重新打包一次代码// 创建一个服务器实例const app = express()app.use(webpackDevMiddleware(complier, &#123; publicPath: config.output.publicPath // 可以去掉&#125;)) // 只要文件改变了，complier就会重新运行，生成的文件对应的打包输出内容的publicPath就是config.output.publicPathapp.listen(3000, () =&gt; &#123; console.log(&#x27;server is running&#x27;)&#125;) 重新运行指令后，在http://localhost:3000/即可访问到页面 综上，我们学会了两种使用webpack的方式：在node中使用和在命令行使用。 3-8-2 参考以下文档 CLI文档 Node Api文档 3-8-3 课后作业 阅读Development文档 阅读Devtool文档 阅读DevServer文档 3-9 hot module replacement (hmr) 热模块更新 (1)3-9-1 针对css文件的使用 修改或添加配置： 12345678&#123; test: /\\.css$/, use: [ &#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;postcss-loader&#x27; ]&#125; 在package.json中配置运行命令，然后运行$ npm run start 启动服务： 123&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack-dev-server&quot;&#125;, 这种启动打包方式不会生成dist目录，因为webpackDevServer把打包生成的文件放到了电脑的内存中，这样可以有效提升打包的速度，让开发变得更快。 在src/index.js编写简单的功能，然后希望在偶数行添加一个背景，结合src/style.css使用如下： 123456789import &#x27;./style.css&#x27;var btn = document.createElement(&#x27;button&#x27;)btn.innerHTML = &#x27;新增&#x27;document.body.appendChild(btn)btn.onclick = function() &#123; var div = document.createElement(&#x27;div&#x27;) div.innerHTML = &#x27;item&#x27; document.body.appendChild(div)&#125; 123div:nth-of-type(odd) &#123; background: yellow;&#125; 针对以上的功能，希望在改变样式代码时webpack不会自动刷新页面，只是把样式代码给替换掉，页面上之前渲染出的内容不要动，这时就可以借助HMR了，其配置如下： 123456789101112131415const webpack = require(&#x27;webpack&#x27;)module.exports = &#123; ...... devServer: &#123; ...... hot: true, hotOnly: true &#125;, ...... plugins: [ ...... new webpack.HotModuleReplacementPlugin() ], ......&#125; 这里的hotOnly可以理解为即便hot: true没有使热更新生效，也可以不让浏览器刷新。 综上，使用HMR的好处之一是，它可以在我们写CSS时，方便我们调试CSS 3-9-2 针对js文件的使用​ 举例说明： 将配置文件中的HMR相关代码先注掉，并重启服务： 123// hot: true,// hotOnly: true// new webpack.HotModuleReplacementPlugin() 新建src/counter.js： 12345678910function counter() &#123; var div = document.createElement(&#x27;div&#x27;) div.setAttribute(&#x27;id&#x27;, &#x27;counter&#x27;) div.innerHTML = 1 div.onclick = function() &#123; div.innerHTML = parseInt(div.innerHTML, 10) + 1 &#125; document.body.appendChild(div)&#125;export default counter 在src/index.js中引入调用，在页面立即就能看到效果： 12import counter from &#x27;./counter&#x27;counter() 3-10 hot module replacement (hmr) 热模块更新 (2) 紧接以上： 3-10-1 针对js文件的使用 新建src/number.js： 1234567function number() &#123; var div = document.createElement(&#x27;div&#x27;) div.setAttribute(&#x27;id&#x27;, &#x27;number&#x27;) div.innerHTML = 1000 document.body.appendChild(div)&#125;export default number 同样在src/index.js中引入并调用： 12import number from &#x27;./number&#x27;number() 在以上准备完成后，进行如下操作：点击上行数字1累加到10，下面仍是1000，假如我手动将src/number.js中的div.innerHTML设为2000，保存后页面就会刷新，从而使上一行数字又重置为1。但是我们需要修改number.js文件，只更新下行数字，上行仍保留之前的操作，怎么实现呢？当然还是借助HMR咯~ 先解开配置项中关于HMR的注释并重启，在index.js中添加如下代码： 123456if(module.hot) &#123; module.hot.accept(&#x27;./number&#x27;, () =&gt; &#123; document.body.removeChild(document.getElementById(&#x27;number&#x27;)) number() // 先清除再挂载 &#125;)&#125; 以上代码表示如果开启了热更新功能，如果它所依赖的模块发生了变化，就会执行第二个参数的业务逻辑。在使用Vue和React时，我们都不需要写这样的代码就能实现HMR，那是因为前者使用的vue-loader和后者使用的babel-preset都内置了HMR代码。 3-10-2 课后作业 阅读模块热替换https://www.webpackjs.com/guides/hot-module-replacement/ 阅读模块热替换APIhttps://www.webpackjs.com/api/hot-module-replacement/ 简单了解HMR底层原理https://www.webpackjs.com/concepts/hot-module-replacement/ 3-11 使用babel处理es6语法 (1)3-11-1 在webpack中使用babel 比如我们在src/index.js中编写ES6代码后，运行$ npx webpack后查看main.js相应的代码仍是ES6语法，在低版本或一些国产的浏览器中无法识别，所以我们需要借助babel。 1234567const arr = [ new Promise(() =&gt; &#123;&#125;), new Promise(() =&gt; &#123;&#125;)]arr.map(item =&gt; &#123; console.log(item)&#125;) 进入babel的官网的Setup模块选中Webpackhttps://babeljs.io/setup#installation，根据文档一步步安装和使用。 安装运行指令$ npm install --save-dev babel-loader @babel/core，其中babel/core是babel的核心库。 在webpack.config.js配置相应的rules： 123456module: &#123; rules: [&#123; test: /\\.js$/, exclude: /node_modules/, // 排除该文件夹的第三方模块，因为这些模块都已经打包好了，排除它能提升打包速度和编译性能 loader: &#x27;babel-loader&#x27; &#125;, 以上只是将babel和webpack做了通信，而babel/preset-env是将ES6语法翻译成ES5，运行安装$ npm install @babel/preset-env --save-dev后再进行配置即可： 12345678rules: [&#123; test: /\\.js$/, exclude: /node_modules/, loader: &#x27;babel-loader&#x27;, options: &#123; presets: [&#x27;@babel/preset-env&#x27;] &#125;&#125;, 虽然ES6被翻译成了ES5，但以下仍有些代码如Promise在低版本浏览器中难以识别，所以需要借助polyfill，运行指令$ npm install --save @babel/polyfill进行安装。 1eval(&quot;var arr = [new Promise(function () &#123;&#125;), new Promise(function () &#123;&#125;)];\\narr.map(function (item) &#123;\\n console.log(item);\\n&#125;); 以上安装完成，只需要在相应的js文件中引入即可： 12import &#x27;@babel/polyfill&#x27;;const arr = [] 以上使用polyfill后打包出来的main.js大小由30k左右变成900k，因为要做map方法的实现然后加到main.js中，而且还把babel/polyfill一并打包到其中，导致它变得特别大。如果避免polyfill全部被打包进来，只需要进行如下配置即可： 1234567options: &#123; presets: [ [&#x27;@babel/preset-env&#x27;, &#123; useBuiltIns: &#x27;usage&#x27; &#125;] ]&#125; 这样就只会打包polyfill中跟业务代码中的ES6语法相关的代码，能达到精简main.js的目的。 3-12 使用babel处理es6语法 (2)3-12-1 配置项targets 针对某个浏览器打包，假如该浏览器支持ES6语法，打包后的代码就不会被翻译，反之则会： 123456789presets: [ [&#x27;@babel/preset-env&#x27;, &#123; &#x27;targets&#x27;: &#123; &#x27;chrome&#x27;: &#x27;58&#x27;, &#x27;ie&#x27;: &#x27;11&#x27; &#125;, useBuiltIns: &#x27;usage&#x27; &#125;]] 3-12-2 babel plugin-transform-runtime​ 在开发组件库或类库或第三方模块时，以上引入polyfill的方法会生成全局变量，污染到全局环境，所以需要换一种配置的方式： 在index.js中取消引入polyfill，进入transform-runtime官网https://babeljs.io/docs/en/babel-plugin-transform-runtime 安装$ npm install --save-dev @babel/plugin-transform-runtime和$ npm install --save @babel/runtime 修改配置： 123456789101112131415rules: [&#123; test: /\\.js$/, exclude: /node_modules/, loader: &#x27;babel-loader&#x27;, options: &#123; &#x27;plugins&#x27;: [ [&#x27;@babel/plugin-transform-runtime&#x27;, &#123; &#x27;corejs&#x27;: 2, // 此处跟官网不一样，值改成了2 &#x27;helpers&#x27;: true, &#x27;regenerator&#x27;: true, &#x27;useESModules&#x27;: false &#125;] ] &#125;&#125;, 以上配置会报错，所以需要安装$ npm install --save @babel/runtime-corejs2 综上，如果写的是业务代码，只需要采取引入polyfill的方式即可；如果写的库代码，就要使用transform-runtime插件方式，防止污染全局环境。 以上配置的options可以放到.babelrc文件中，打包结果是一样的： 12345678910&#123; &quot;plugins&quot;: [ [&quot;@babel/plugin-transform-runtime&quot;, &#123; &quot;corejs&quot;: 2, &quot;helpers&quot;: true, &quot;regenerator&quot;: true, &quot;useESModules&quot;: false &#125;] ]&#125; 3-13 webpack实现对react框架代码的打包3-13-1 准备工作​ 由于是开发业务代码，进行如下配置即可： webpack.config.js配置： 123456module: &#123; rules: [&#123; test: /\\.js$/, exclude: /node_modules/, loader: &#x27;babel-loader&#x27; &#125;, .babelrc中的配置： 12345678910&#123; &quot;presets&quot;: [ [&quot;@babel/preset-env&quot;, &#123; &quot;targets&quot;: &#123; &quot;chrome&quot;: &quot;67&quot; &#125;, &quot;useBuiltIns&quot;: &quot;usage&quot; &#125;] ]&#125; 在src/index.js引入polyfill： 1import &#x27;@babel/polyfill&#x27;; 3-13-2 安装与使用 官网https://babeljs.io/docs/en/babel-preset-react 安装运行$ npm install --save-dev @babel/preset-react，并在.babelrc中添加配置： 12345678&#123; &quot;presets&quot;: [ [&quot;@babel/preset-env&quot;, &#123; ...... &#125;], &quot;@babel/preset-react&quot; ]&#125; 注：由于自下而上执行的原则，此处一定要把preset-react写到preset-env下面。 使用react$ npm install react react-dom --save react编写的页面js如下： 123456789import &#x27;@babel/polyfill&#x27;;import React, &#123; Component &#125; from &#x27;react&#x27;import ReactDom from &#x27;react-dom&#x27;class App extends Component &#123; render() &#123; return &lt;div&gt;Hello World&lt;/div&gt; &#125;&#125;ReactDom.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;)) 第4章 webpack进阶 (高级概念)4-1 tree shaking概念详解4-1-1 tree shaking是什么 运行$ npx webpack时会报一个警告： 12When setting `useBuiltIns: &#x27;usage&#x27;`, polyfills are automatically imported when needed.Please remove the `import &#x27;@babel/polyfill&#x27;` call or use `useBuiltIns: &#x27;entry&#x27;` instead. 以上的含义是如果使用了useBuiltIns: ‘usage’，那么polyfill会自动被引入，所以我们无需再引。 编写以下代码，然后运行$ npx webpack打包： 12345678910// 新建src/math.js：export const add = (a, b) =&gt; &#123; console.log(a + b)&#125;export const minus = (a, b) =&gt; &#123; console.log(a - b)&#125;// 在src/index.js中引入并调用执行：import &#123; add &#125; from &#x27;./math&#x27;add(1, 2) 打包完成发现dist/main.js中exports provided: add, minus，即minus方法也被打包进来了，但是我们不想打包跟业务代码无关的代码，就要引入Tree Shaking概念了。 Tree Shaking翻译过来是摇树，实际上可以把一个模块里没用的东西都摇晃掉。需要注意Tree Shaking只支持ES Module方式的引入，即只支持import模块的引入。 4-1-2 使用tree shaking 如果webpack.config.js中添加一个配置项： 12345plugins: [ ...... ],optimization: &#123; usedExports: true&#125;,output: &#123; ...... &#125;, 然后在package.json中添加： 123&#123; &quot;sideEffects&quot;: false,&#125; 配置它的原因是在打包时Tree Shaking会看模块引入了什么和打包了什么，假如我们引入css文件import &#39;./style.css&#39;，它并没有导出文件，Tree Shaking就会把它当作无用的模块过滤掉，所以需要针对css文件进行设置，这样Tree Shaking就不会作用于该格式的文件了： 12345&#123; &quot;sideEffects&quot;: [ &quot;*.css&quot; ],&#125; 以上配置完成后，发现dist/main.js中minus方法依然被打包了进来，但是注释却多了一行exports used: add，这种情况之所以会存在，这是因为开发时我们需要对代码进行调试，如果Tree Shaking把多余的方法删除掉，那么行数就错位了。 4-2 development和production模式的区分打包4-2-1 development模式 开发时用 使用了devServer，可以帮我们启一个服务器，这个服务器中还集成了HMR这样的特性，只要更改了代码就会重新打包，然后代码内容会实时展示在服务器对应的网页上 4-2-2 production模式 开发完成，上线时使用 4-2-3 两种模式的差异 在dev环境中sourceMap是非常全的，可以快速定位代码的问题；在prod环境中sourceMap就没那么重要了，设为更加简洁的即可 在dev环境中代码打包生成后不需要做压缩，能比较明显地看到代码中具体的说明项内容；在prod环境中代码可以被压缩 之前我们对两个模式进行切换，需要手动修改webpack.config.js配置文件，其实有更好的办法： 4-2-4 两种模式下的配置文件 重命名配置文件为webpack.dev.js. 复制配置文件为webpack.prod.js，修改后如下： 123456789101112131415161718192021222324const path = require(&#x27;path&#x27;)const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)const &#123;CleanWebpackPlugin&#125; = require(&#x27;clean-webpack-plugin&#x27;)const webpack = require(&#x27;webpack&#x27;)module.exports = &#123; mode: &#x27;production&#x27;, devtool: &#x27;cheap-module-source-map&#x27;, entry: &#123; main: &#x27;./src/index.js&#x27; &#125;, module: &#123; rules: [ ...... ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: &#x27;src/index.html&#x27; &#125;), new CleanWebpackPlugin() ], output: &#123; filename: &#x27;[name].js&#x27;, path: path.resolve(__dirname, &#x27;dist&#x27;) &#125;,&#125; 跟dev文件不同的是mode、devtool、去掉devServer、去掉HMR插件、去掉optimization. 修改package.json配置： 123456&#123; &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --config webpack.dev.js&quot;, // 开发环境打包开发命令 &quot;build&quot;: &quot;webpack --config webpack.prod.js&quot; // 生产环境打包命令 &#125;,&#125; 运行$ npm run dev进行开发，运行$ npm run build进行打包，会生成dist目录，直接把这个文件夹放到线上给后端使用即可 4-2-5 解决多个配置文件的重复问题 新建webpack.common.js文件，把webpack.dev.js和webpack.prod.js中共有的代码都拆分到其中，三个文件具体如下： webpack.common.js： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768const path = require(&#x27;path&#x27;)const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)const &#123;CleanWebpackPlugin&#125; = require(&#x27;clean-webpack-plugin&#x27;)module.exports = &#123; entry: &#123; main: &#x27;./src/index.js&#x27; &#125;, module: &#123; rules: [&#123; test: /\\.js$/, exclude: /node_modules/, loader: &#x27;babel-loader&#x27; &#125;, &#123; test: /\\.(jpg|png|gif)$/, use: &#123; loader: &#x27;url-loader&#x27;, options: &#123; name: &#x27;[name]_[hash].[ext]&#x27;, outputPath: &#x27;images/&#x27;, limit: 20480 &#125; &#125; &#125;, &#123; test: /\\.(eot|woff|ttf|svg)$/, use: &#123; loader: &#x27;file-loader&#x27; &#125; &#125;, &#123; test: /\\.vue$/, use: &#123; loader: &#x27;vue-loader&#x27; &#125; &#125;, &#123; test: /\\.scss$/, use: [ &#x27;style-loader&#x27;, &#123; loader: &#x27;css-loader&#x27;, options: &#123; importLoaders: 2 &#125; &#125;, &#x27;sass-loader&#x27;, &#x27;postcss-loader&#x27; ] &#125;, &#123; test: /\\.css$/, use: [ &#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;postcss-loader&#x27; ] &#125;] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: &#x27;src/index.html&#x27; &#125;), new CleanWebpackPlugin() ], optimization: &#123; usedExports: true &#125;， output: &#123; filename: &#x27;[name].js&#x27;, path: path.resolve(__dirname, &#x27;dist&#x27;) &#125;&#125; webpack.dev.js： 1234567891011121314151617const webpack = require(&#x27;webpack&#x27;)module.exports = &#123; mode: &#x27;development&#x27;, devtool: &#x27;cheap-module-eval-source-map&#x27;, devServer: &#123; contentBase: &#x27;./dist&#x27;, open: true, proxy: &#123; &#x27;/api&#x27;: &#x27;http://localhost:3000&#x27; &#125;, hot: true, hotOnly: true &#125;, plugins: [ new webpack.HotModuleReplacementPlugin() ]&#125; webpack.prod.js： 1234module.exports = &#123; mode: &#x27;production&#x27;, devtool: &#x27;cheap-module-source-map&#x27;&#125; 拆完之后需要将dev、prod分别与common做一个合并后再输出，借助一个第三方模块，先安装$ npm install webpack-merge -D，然后分别在dev和prod中使用，以webpack.prod.js为例： 1234567const merge = require(&#x27;webpack-merge&#x27;)const commonConfig = require(&#x27;./webpack.common.js&#x27;)const prodConfig = &#123; mode: &#x27;production&#x27;, devtool: &#x27;cheap-module-source-map&#x27;&#125;module.exports = merge(commonConfig, prodConfig) 4-2-6 整理以上几个配置文件 在项目根目录新建build文件夹，将这三个配置文件移入其中 然后修改package.json打包命令中的文件目录： 1234&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --config ./build/webpack.dev.js&quot;, &quot;build&quot;: &quot;webpack --config ./build/webpack.prod.js&quot;&#125;, 记得修改配置中打包后的dist文件位置，否则打包后的dist文件夹就会出现在build目录下： 1234output: &#123; filename: &#x27;[name].js&#x27;, path: path.resolve(__dirname, &#x27;../dist&#x27;)&#125; 4-3 webpack和code splitting4-3-1 准备工作 在package.json中添加新的指令，为了在开发环境中看到打包生成的文件： 12&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack --config ./build/webpack.dev.js&quot;, 安装$ npm install lodash --save，举个简单例子，在src/index.js中使用： 12import _ from &#x27;lodash&#x27;console.log(_.join([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], &#x27;***&#x27;)) 假如我们的业务代码为1Mb，lodash本身也有1Mb，那么打包生成的dist/main.js不被压缩情况下就有2Mb，这就带来两个问题：（1）打包生成的文件会很大，加载时间会很长。（2）假设此时我们修改了业务代码，就会重新打包生成2Mb的main.js，假设用户重新访问我们的页面，就又要加载那么大的文件。 针对以上我们应该怎么做呢？（1）新建src/lodash.js： 12import _ from &#x27;lodash&#x27;window._ = _ 相当于把_暴露到全局，在其他地方就可以尽情使用了。（2）新建入口： 1234entry: &#123; lodash: &#x27;./src/lodash.js&#x27;, main: &#x27;./src/index.js&#x27;&#125;, 这样就会把原来的dist/main.js(2Mb)拆分成dist/main.js(1Mb)和dist/lodash.js(1Mb)，由于浏览器可以并行加载，所以加载两个小文件比加载一个大文件可能更快，而且当页面业务逻辑发生变化时，用户只要重新加载main.js(1Mb)即可。 4-3-2 code splitting代码分割 综上，在实际项目中我们会对代码公用部分进行拆分来提升项目运行的速度，这种拆分代码的方式就叫做Code Splitting。 Code Splitting和Webpack其实没啥关系，但现在通常把二者进行绑定，是因为webpack中有些插件（如：SplitChunksPlugin）可以非常容易实现code splitting这种功能. 方法一：实现同步代码的分割 对webpack进行简单的配置，就不再需要我们手动进行代码分割了，它会自动将类库和业务代码进行分割，common中添加配置如下： 12345optimization: &#123; splitChunks: &#123; chunks: &#x27;all&#x27; &#125;&#125;, 方法二：实现异步代码的分割，不需要进行以上的配置了，因为默认就是异步，后面有讲： 在src/index.js中编写以下异步代码： 12345678910function getComponent() &#123; return import(&#x27;lodash&#x27;).then((&#123; default: _ &#125;) =&gt; &#123; let element = document.createElement(&#x27;div&#x27;) element.innerHTML = _.join([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], &#x27;-&#x27;) return element &#125;)&#125;getComponent().then((element) =&gt; &#123; document.body.appendChild(element)&#125;) 这样就打包生成一个dist/0.js文件，里面实际上就是lodash库代码。 4-3-3 总结 代码分割和webpack无关，它是一个独立的概念，来提升整个项目的性能 webpack中实现代码分割有两种方式：（1）同步代码：只需要在webpack.common.js中做optimization的配置即可（2）异步代码（import）：无需做任何配置，会自动做代码分割放到新的文件中 4-5 split-chunks-plugin配置参数详解 (1)4-5-1 magic-comment魔法注释 用来修改打包后的文件名，用法如下： 12345function getComponent() &#123; return import(/*webpackChunkName:&quot;lodash&quot;*/ &#x27;lodash&#x27;).then((&#123; default: _ &#125;) =&gt; &#123; ...... &#125;)&#125; 这样打包生成的文件叫做vendors~lodash.js 怎么去掉前面的vendors呢？ 参照官网https://www.webpackjs.com/plugins/split-chunks-plugin/，复制如下配置，并作出修改： 123456789optimization: &#123; splitChunks: &#123; chunks: &#x27;all&#x27;, cacheGroups: &#123; vendors: false, default: false &#125; &#125;&#125;, 以上说明了无论做同步还是异步的代码分割，都要进行splitChunks的配置，即使用SplitChunksPlugin这个插件。 4-5-2 详解split-chunks-plugin的配置参数 起初我们可以对它先不进行配置，设为空对象，打包的过程依然能正常运行，这是因为如果不配置它，它会有个默认的配置内容： 我们先把下面这两项设为false以做如下详解： 1234cacheGroups: &#123; vendors: false, default: false&#125; chunks: &#39;async&#39;指做代码分割时只对异步代码生效，对以下src/index.js中的同步代码无效： 1234import _ from &#x27;lodash&#x27;let element = document.createElement(&#x27;div&#x27;)element.innerHTML = _.join([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], &#x27;-&#x27;)document.body.appendChild(element) 但是假如想对同步异步都做分割，把chunks设为’all’或’initial’后都对同步代码依然无效，因为打包时会在splitChunks中继续向下走，走到cacheGroup这个参数（只针对同步代码），由于vendors被设为false，所以它不会被分割。 针对以上情况，我们修改配置： 1234vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, priority: -10&#125;, 这样就能分割生成vendors~main.js，里面就是lodash全部的代码，为啥叫main呢？因为是在src/index.js中引入的lodash，而index.js的入口文件名叫main，所以这里默认就叫该名称了。既然这样我们可以增加一个配置项，将其打包成vendors.js: 12345vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, priority: -10, name: &#x27;vendors&#x27;&#125;, 因此chunks参数要和vendors参数配合使用。以上的意思是如果要打包的库在node_modules文件夹中，就会被分割到vendors.js中按照视频和官网vendors.filename: ‘vendors.js’在运行$ npx webpack时会报以下错误，将它改成name就解决了：UnhandledPromiseRejectionWarning: Error: SplitChunksPlugin: You are trying to set a filename for a chunk which is (also) loaded on demand. The runtime can only handle loading of chunks which match the chunkFilename schema. Using a custom filename would fail at runtime. (cache group: vendors) minSize: 30000表示我们引入的库如果大于30000字节，才会做代码分割，小于的话就不做代码分割。 假设我们自己写个模块src/test.js并在src/index.js中使用，当大小符合minSize（先设为0做测试）时，它还是会继续走到cacheGroup中，此时由于vendors只针对node_modules中的模块，所以我们需要设置default如下，就能生成default~main.js文件，同样可以用name给它命名: 12345default: &#123; priority: -20, reuseExistingChunk: true， name: &#x27;common&#x27;&#125; minChunks: 1指当一个模块被用了至少多少次时才对其进行代码分割。 maxAsyncRequests: 5指同时加载的模块数是5个，假如有10个模块需要打包，webpack会在打包前5个时进行代码分割，后面的就不做了。 maxInitialRequests: 3指整个网站首页（或者说入口文件）进行加载的时候，入口文件中可能会引入其他的js文件或其他的库，最多只能对其中3个进行代码分割。 automaticNameDelimiter: ‘~’指生成文件的文件名中间会有连接符。 name: true是指在cacheGroups中取的name文件名有效。 cacheGroups与同步代码打包相关，这里之所以叫’缓存组’是因为当打包多个模块时，打包其一时判断符合所有配置，就先放到这个组里缓存着，打包其二时同样也先缓存着……最终当所有的模块都分析好之后，就可以把符合vendors这个组的所有模块都打包到一起，把符合default这个组的所有模块也打包到一起。 123456789101112cacheGroups: &#123; vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, priority: -10, name: &#x27;vendors&#x27; &#125;, default: &#123; priority: -20, reuseExistingChunk: true, name: &#x27;common&#x27; &#125;&#125; priority的作用：当我们打包某个模块时，如果它既符合vendors的规则，也适用default的规则，那么当priority的值越大(-10&gt;-20)优先级就越高，所以上面会将其打包到vendors.js中。 reuseExistingChunk: true表示假如我们同时引入模块a和b，其中b已经是打包过的了并在a中进行了引用，那么我们打包分割时就不会重新打包b了。 4-7 lazy loading懒加载和chunk是什么4-7-1 懒加载 实际上就是import语法，可以让我们在页面执行时需要哪些模块再去请求哪些模块，不需要一次性把所有代码都加载到页面上： 123456789101112function getComponent() &#123; return import(/*webpackChunkName:&quot;lodash&quot;*/ &#x27;lodash&#x27;).then((&#123; default: _ &#125;) =&gt; &#123; let element = document.createElement(&#x27;div&#x27;) element.innerHTML = _.join([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], &#x27;-&#x27;) return element &#125;)&#125;document.addEventListener(&#x27;click&#x27;, () =&gt; &#123; getComponent().then((element) =&gt; &#123; document.body.appendChild(element) &#125;) &#125;) 以上可以利用ES7语法进行修改： 123456async function getComponent() &#123; const &#123; default: _ &#125; = await import(/*webpackChunkName:&quot;lodash&quot;*/ &#x27;lodash&#x27;) let element = document.createElement(&#x27;div&#x27;) element.innerHTML = _.join([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], &#x27;-&#x27;) return element&#125; 4-7-2 chunk的概念 打包分割成的每个js文件都是一个chunk，如前例的dist/main.js、dist/vendors.js等。 chunk的意义：先再次理解splitChunks.minChunks:2这个概念，以lodash为例，它是指在打包生成的chunk中至少有2个使用了lodash时，才对lodash进行代码分割。 4-8 打包分析-preloading和prefetching4-8-1 打包分析 指的是当我们使用webpack进行代码的打包之后，可以借助打包分析的一些工具对打包生成的文件进行一定的分析，然后看下它打包是否合理。 webpack官方提供的分析工具的git仓库http://www.github.com/webpack/analyse，怎么使用呢？（1）先复制命令粘贴到打包命令中： 12&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack --profile --json &gt; stats.json --config ./build/webpack.dev.js&quot; 以上的含义是在打包时把打包过程的描述放置到一个叫做stats.json的文件中，运行$ npm start后会在根目录生成该json文件。（2）需要借助工具分析该文件，进入http://webpack.github.io/analyse/，并上传stats.json文件，分析结果即可出来： 以上分析结果表示：打包使用的webpack版本、耗时、哈希值、模块数量、chunk(打包生成的js文件)数量、静态文件(assets)数量、是否有警告或异常。 在官网还介绍了其他的分析工具https://webpack.js.org/guides/code-splitting/#bundle-analysis，常用的是webpack-bundle-analyzer。 4-8-2 prefetching和preloading 在webpack.common.js中我们将splitChunks.chunks设为’all’，但webpack默认是’async’，即只对异步代码进行分割，webpack为什么要这么做呢？之前讲过通过缓存可以使jquery、lodash之类的在第二次加载时比较快，但webpack是希望能在第一次访问时就很快，怎么做呢？它真正希望我们编写代码的方式是什么样的呢？ 假如我们想实现点击页面创建一个元素，并将其挂载到页面上。我们的传统做法是： 12345document.addEventListener(&#x27;click&#x27;, () =&gt; &#123; let element = document.createElement(&#x27;div&#x27;) element.innerHTML = &#x27;aaa&#x27; document.body.appendChild(element)&#125;) 运行$ npm run build后打开控制台采用快捷键ctrl+shift+p搜索打开coverage，并点击红色圆形按钮，就能看到main.js的利用率仅74.5%，进去查看详情发现以上代码并没有被利用，但加载时却被下载了下来，浪费了页面执行的性能： 所以webpack建议以上这种交互的代码放到一个异步加载的模块中： 新建src/click.js： 12345export function handleClick() &#123; let element = document.createElement(&#x27;div&#x27;) element.innerHTML = &#x27;aaa&#x27; document.body.appendChild(element)&#125; 修改src/index.js： 12345document.addEventListener(&#x27;click&#x27;, () =&gt; &#123; import(&#x27;./click&#x27;).then((&#123;default: fn&#125;) =&gt; &#123; fn() &#125;)&#125;) 这样再查看控制台，发现main.js的利用率提升到80.5%。 为什么利用率变高了？因为以下代码变少了： 以上也间接解释了为什么webpack的配置项里的splitChunks.chunks的默认值为’async’，是因为它认为只有异步的组件才能真正地提升网页的打包性能，而同步的代码只能增加一个缓存，对性能的提升实际上很有限。 我们发现上面在页面加载完成后，只有点击后，click.js中的相关代码才加载处理，这样有可能会造成延迟，用户体验不好，所以我们希望加载完页面模块后在空闲时就偷偷地将click.js相关的代码加载下来，这就需要采用prefetch或preload了： 1import(/* webpackPrefetch: true */ &#x27;./click&#x27;) prefetch和preload的区别：prefetch会等待核心代码加载完成后，页面带宽空闲时再去加载prefetch对应的js文件，而preload会和主业务文件一起加载。所以建议使用prefetch。 4-9 css文件的代码分割4-9-1 css in js 新建src/style.css 在src/index.js中引入： 1import &#x27;./style.css&#x27; 运行$ npm start后发现样式生效了，而且在dist/main.js中多引入了chunk.js文件（之前只引main.js），但是dist目录下却没有css文件，这就是我们常说的css in js： 12&lt;script type=&quot;text/javascript&quot; src=&quot;vendors~main.chunk.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;main.js&quot;&gt;&lt;/script&gt; 4-9-2 借助mini-css-extract-plugin将css打包到dist下 而不是放到js中 参照官网https://webpack.js.org/plugins/mini-css-extract-plugin/进行安装$ npm install --save-dev mini-css-extract-plugin 在webpack.common.js中进行如下使用修改： 1234567891011121314151617181920212223242526272829303132const MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;)module.exports = &#123; module: &#123; rules: [&#123; test: /\\.scss$/, use: [ MiniCssExtractPlugin.loader, // 相当于替换掉style-loader &#123; loader: &#x27;css-loader&#x27;, options: &#123; importLoaders: 2 &#125; &#125;, &#x27;sass-loader&#x27;, &#x27;postcss-loader&#x27; ] &#125;, &#123; test: /\\.css$/, use: [ MiniCssExtractPlugin.loader, // 相当于替换掉style-loader &#x27;css-loader&#x27;, &#x27;postcss-loader&#x27; ] &#125;] &#125;, plugins: [ ......, new MiniCssExtractPlugin() ],&#125; 以上配置完成后开发环境打包$ npm start会在dist下生成main.css，但生产环境却不行，所以就怀疑是TreeShaking导致的，将package.json中的”sideEffects”: false修改成[&quot;*.css&quot;]后，打包后才正常分割出main.css文件及main.css.map文件，这时候dist/index.html中重新变回只引用main.js了。 它里面还可以进行一些配置，发现打包后的文件还叫main.css，这是因为它如果可以在dist/index.html通过link直接引用，就会走filename那个属性，如果是间接引用，才走chunkFilename属性： 1234new MiniCssExtractPlugin(&#123; filename: &#x27;[name].css&#x27;, chunkFilename: &#x27;[name].chunk.css&#x27;&#125;) 假设src/index.js中同时引入两个css文件，打包分割后依然会生成一个dist/main.css，里面把打包前的两个css样式合并在一起了。 4-9-3 压缩css代码 按照官网https://github.com/NMFR/optimize-css-assets-webpack-plugin，先进行安装$ npm install --save-dev optimize-css-assets-webpack-plugin 直接引入并在plugins中使用，重新打包即可看到代码被压缩合并(以下用法与视频讲解的不一致)： 1234567const OptimizeCssAssetsPlugin = require(&#x27;optimize-css-assets-webpack-plugin&#x27;)module.exports = &#123; plugins: [ ......, new OptimizeCssAssetsPlugin() ],&#125; 4-9-4 将所有入口的css文件打包分割成一个css文件直接进入以下配置即可，打包完成后生成dist/styles.chunk.css： 1234567891011splitChunks: &#123; chunks: &#x27;all&#x27;, cacheGroups: &#123; styles: &#123; name: &#x27;styles&#x27;, test: /\\.css$/, chunks: &#x27;all&#x27;, enforce: true, &#125;, &#125;,&#125; 4-9-5 根据入口不同将css文件打包到不同的css文件中 配置如下： 4-10 webpack与浏览器缓存 (caching)4-10-1 浏览器缓存如果将以上代码打包，用户第一次访问页面时，在network中文件加载了进来，假如我们修改后重新打包，由于打包生成的文件名没变，用户即便刷新，也会受浏览器缓存影响，仍看到修改前的内容。 4-10-2 contentHash 将webpack.common.js的output中部分代码剪切到dev并作修改，然后复制到prod，也做出相应修改： webpack.dev.js： 1234output: &#123; filename: &#x27;[name].js&#x27;, chunkFilename: &#x27;[name].js&#x27;,&#125; webpack.prod.js： 1234output: &#123; filename: &#x27;[name].[contentHash].js&#x27;, chunkFilename: &#x27;[name].[contentHash].js&#x27;,&#125; 运行$ npm run build后打包生成的文件名称中就带有哈希值：main.e29c51e41919e31b788e.js和vendors~main.7282cdc21edc87472cbb.js。 如果我们代码内容不变，再重新打包，上面的两个哈希值永远不会变；如果我们对src/index.js中的业务代码做了修改，重新打包后，只有main.js的哈希值会变，而由于vendors~main.js中是lodash和jquery的代码，它的哈希值未发生变化。所以刷新页面后，vendors直接用本地缓存，main.js就需要重新去服务器上请求，加载新的变化了的文件。 在老版本的webpack4中不改变代码重新打包，哈希值可能也发生变化，这是由于manifest导致的，需要在optimization中配置runtimeChunk即可解决。 4-11 shimming (垫片) 的作用4-11-1 全局配置jquery 新建src/jquery.ui.js： 123export function ui() &#123; $(&#x27;body&#x27;).css(&#x27;background&#x27;, &#x27;#ccc&#x27;);&#125; 在src/index.js中引入并调用： 123import $ from &#x27;jquery&#x27;import &#123; ui &#125; from &#x27;./jquery.ui&#x27;ui() 发现会报错，这是因为webpack是基于模块打包的，而模块中的变量只能在当前模块使用，换一个文件使用是不可能的，为了解决这个问题，就需要借助垫片的形式。 在webpack.common.js中配置如下： 12345678const webpack = require(&#x27;webpack&#x27;)module.exports = &#123; plugins: [ new webpack.ProvidePlugin(&#123; $: &#x27;jquery&#x27; &#125;) ],&#125; 意思是如果在一个模块里使用了$这个变量，就会自动引入jquery这个模块，然后把jquery赋值给$，相当于import $ from &#39;jquery&#39; 同样可以配置lodash或lodash下的某个模块方法： 1234new webpack.ProvidePlugin(&#123; _: &#x27;lodash&#x27;, // or _join: [&#x27;lodash&#x27;, &#x27;join&#x27;]&#125;) 4-11-2 imports-loader 一个模块里的this永远指向模块自身，但是怎样才能使它指向window呢？需要借助一个插件，先安装$ npm install imports-loader -D，修改webpack.common.js： 12345678910module: &#123; rules: [&#123; test: /\\.js$/, exclude: /node_modules/, use: [&#123; loader: &#x27;babel-loader&#x27; &#125;, &#123; loader: &#x27;imports-loader?this=&gt;window&#x27; &#125;] &#125;, 以上将this指向window报语法错误，至今未找到解决办法，试验了jquery是ok的：loader: &#39;imports-loader?$=jquery 垫片的作用：用来修改webpack默认的行为或者webpack原始打包实现不了的效果 4-11-3 课后阅读 英文https://webpack.js.org/guides/，中文https://www.webpackjs.com/guides/ 4-12 环境变量的使用方法4-12-1 调整配置文件 webpack.dev.js和webpack.prod.js去掉webpack-merge和引入的webpack.common.js，直接将自己的模块导出，以dev为例： 1234// const merge = require(&#x27;webpack-merge&#x27;)// const commonConfig = require(&#x27;./webpack.common.js&#x27;)// module.exports = merge(commonConfig, devConfig)module.exports = devConfig webpack.common.js中引入merge并分别引入dev和prod的配置文件，并根据外部传递的全局变量env进行判断当前环境，并将其导出： 1234567891011const merge = require(&#x27;webpack-merge&#x27;)const devConfig = require(&#x27;./webpack.dev.js&#x27;)const prodConfig = require(&#x27;./webpack.prod.js&#x27;)const commonConfig = &#123;&#125;module.exports = (env) =&gt; &#123; if(env &amp;&amp; env.production) &#123; return merge(commonConfig, prodConfig) &#125;else &#123; return merge(commonConfig, devConfig) &#125;&#125; 将package.json指令中使用的配置文件都改成webpack.common.js，start和dev指令中不需要传全局变量env，但build指令需要传，具体如下： 12345&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack --config ./build/webpack.common.js&quot;, &quot;dev&quot;: &quot;webpack-dev-server --config ./build/webpack.common.js&quot;, &quot;build&quot;: &quot;webpack --env.production --config ./build/webpack.common.js&quot;&#125;, 以上传递全局变量的方法只是其一，我们也可以这样做： 其二： package.json: 123&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack --env production --config ./build/webpack.common.js&quot;&#125;, webpack.common.js: 123module.exports = (production) =&gt; &#123; if(production) &#123; &#125;else &#123; &#125;&#125; 其三： package.json: 123&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack --env.production=aaa --config ./build/webpack.common.js&quot;&#125;, webpack.common.js: 123module.exports = (env) =&gt; &#123; if(env &amp;&amp; env.production === &#x27;aaa&#x27;) &#123; &#125;else &#123; &#125;&#125; 注意：我们项目中一般不用环境变量的这种方法！ 第5章 webpack实战配置案例5-1 library的打包5-1-1 实现打包一个函数库的准备工作 新建library项目，并运行$ npm init -y，进入修改package.json文件，去掉scripts中内容，修改作者，将license改为’MIT’： 12345678910&#123; &quot;name&quot;: &quot;library&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123;&#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;Carol&quot;, &quot;license&quot;: &quot;MIT&quot;&#125; 新建src文件夹，并新建src/math.js： 123456789101112export function add(a, b) &#123; return a + b&#125;export function minus(a, b) &#123; return a - b&#125;export function multiply(a, b) &#123; return a * b&#125;export function division(a, b) &#123; return a / b&#125; 新建src/string.js： 123export function join(a, b) &#123; return a + &#x27; &#x27; + b&#125; 新建src/index.js： 123import * as math from &#x27;./math&#x27;import * as string from &#x27;./string&#x27;export default &#123; math, string &#125; 安装webpack$ npm install webpack webpack-cli --save，在package.json中添加指令： 123&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack&quot;&#125;, 添加webpack.config.js，运行$ npm run build进行打包即可： 123456789const path = require(&#x27;path&#x27;)module.exports = &#123; mode: &#x27;production&#x27;, entry: &#x27;./src/index.js&#x27;, output: &#123; path: path.resolve(__dirname, &#x27;dist&#x27;), filename: &#x27;library.js&#x27; &#125;&#125; 5-1-2 真正实现打包一个函数库 如果是业务代码，到上面的步骤就结束了，但我们写的是个库，需要拿给别人用，而别人可能会使用各种方法引入我们的库： 123import library from &#x27;library&#x27; // ES6语法const library = require(&#x27;library&#x27;) // CommonJs语法require([&#x27;library&#x27;], function() &#123;&#125;) // AMD语法 如果我们想让外部引用，需要在webpack.config.js中加个配置： 12345output: &#123; path: path.resolve(__dirname, &#x27;dist&#x27;), filename: &#x27;library.js&#x27;, libraryTarget: &#x27;umd&#x27;&#125; 将libraryTarget配置成’umd’的意思是不管通过任何方式引入我们的库，都能引入到。 别人也有可能不采用以上三种使用方式引入，而直接用script标签引入js，并希望通过全局变量来使用这个库，这就需要再进行配置了： 12345output: &#123; ...... library: &#x27;library&#x27;, libraryTarget: &#x27;umd&#x27;&#125; 5-1-3 打包库时引入其他库 以lodash为例，先安装$ npm install lodash --save，改写src/string.js后打包： 1234import _ from &#x27;lodash&#x27;export function join(a, b) &#123; return _.join([a, b], &#x27; &#x27;)&#125; 别人在使用我们的library库时可能还会同时使用lodash，最终在用户的代码里很容易存在两份lodash，所以我们就需要进行以下配置： 12345module.exports = &#123; ...... externals: [&#x27;lodash&#x27;], output: &#123;......&#125;&#125; 它的意思是打包过程中如果遇到lodash这个库，就忽略，不要打包到代码里去，我们在业务代码中使用这个库之前就得先引入lodash才可以。 根据官网https://webpack.js.org/configuration/externals/，externals还支持好多东西： 123456externals: &#123; lodash: &#123; root: &#x27;_&#x27;, commonjs: &#x27;lodash&#x27; &#125;&#125;, commonjs: ‘lodash’的意思是如果我们的库在commonjs环境（如const library = require(&#39;library&#39;)）下被使用，要求lodash被加载时必须叫做lodash，如const lodash = require(&#39;lodash&#39;) root: ‘_’的意思是lodash是通过全局的script标签引入进来，那么这个script标签 第6章 webpack底层原理及脚手架工具分析未完待续……","categories":[{"name":"webpack","slug":"webpack","permalink":"https://scarlett9354.github.io/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://scarlett9354.github.io/tags/webpack/"}]},{"title":"玩转webpack","slug":"玩转webpack","date":"2021-04-28T08:19:47.000Z","updated":"2021-05-06T09:37:12.841Z","comments":true,"path":"2021/04/28/玩转webpack/","link":"","permalink":"https://scarlett9354.github.io/2021/04/28/%E7%8E%A9%E8%BD%ACwebpack/","excerpt":"","text":"1丨课程介绍 1-1 为什么要深入掌握webpack 1-2 初学者在学习webpack的过程中会遇到哪些困难 1-3 课程阶段 2丨内容综述 3丨为什么需要构建工具 (它的作用在哪里) 4丨前端构建演变之路 5丨为什么选择webpack 6丨初识webpack 6-1 webpack配置文件 6-2 webpack配置组成 7丨环境搭建-安装webpack 7-1 安装nvm 7-2 安装nodejs和npm 7-3 安装webpack和webpack-cli 8丨webpack初体验-一个最简单的例子 9丨通过npm script运行webpack 10丨webpack核心概念之entry用法 10-1 了解entry的含义 10-2 entry的用法 11丨webpack核心概念之output 11-1 output的核心概念 11-2 output的用法 12丨webpack核心概念之loaders 12-1 loaders的核心概念 12-2 常见的loaders有哪些 12-3 loaders的用法 13丨webpack核心概念之plugins 13-1 核心概念 13-2 常见的plugins有哪些 13-3 plugins的用法 14丨webpack核心概念之mode 14-1 核心概念 14-2 mode的内置函数功能 15丨解析es6和react jsx 15-1 资源解析之解析es6 15-2 资源解析之解析react jsx 16丨解析css less sass 16-1 解析资源之解析css 16-2 资源解析之解析less和sass 17丨解析图片和字体 17-1 资源解析之解析图片 17-2 资源解析之解析字体 17-3 资源解析之使用url-loader 18丨webpack中的文件监听 19丨webpack中的热更新及原理分析 19-1 热更新之webpack-dev-server 19-2 热更新之使用webpack-dev-middleware 19-3 热更新的原理分析 20丨文件指纹策略 (chunkhash contenthash hash) 20-1 文件指纹的含义 20-2 文件指纹如何生成或者说常见的文件指纹有哪几种 20-3 文件指纹的设置 20-4 举例说明 20-5 补充生产环境的配置和开发环境的配置文件对比 21丨html css js代码压缩 21-1 js文件的压缩 21-2 css文件的压缩 21-3 html文件的压缩 22丨自动清理构建目录产物 23丨postcss插件autoprefixer自动补齐css3前缀 24丨移动端css px自动转换成rem 25丨静态资源内联 25-1 资源内联的意义 25-2 代码层面的html和js内联 25-2 代码层面的css内联 26丨多页面应用打包通用方案 26-1 多页面应用 (mpa) 的概念 26-2 多页面打包的基本思路 27丨使用sourcemap 28丨提取页面公共资源 28-1 基础库分离 28-2 实战举例 29丨treeshaking的使用和原理分析 29-1 tree shaking (摇树优化) 29-2 tree shaking的原理 29-3 实际运用 30丨scope hoisting使用和原理分析 30-1 使用scope hoisting前 30-2 使用scope hoisting 31丨代码分割和动态import 31-1 代码分割的意义 31-3 如何使用动态import (实际运用) 32丨webpack和eslint结合 32-1 行业里面优秀的eslint规范实践 32-2 指定团队的eslint规范 32-3 eslint如何执行落地 32-3 webpack与eslint集成的实际运用 (以eslint-config-airbnb为例) 1丨课程介绍1-1 为什么要深入掌握webpack 首先，与我们目前的应用场景和开发方式息息相关。 最近十年，随着手机、移动平板和可穿戴设备的迅速普及，Web前端的开发触角也从传统的PC网页的开发发展到多终端的开发，所以我们就需要同时兼顾PC、H5等各类不同分辨率的网页开发，因此针对不同的应用场景，做不同的打包就显得很重要了。比如针对PC端的中后台应用，我们需要针对支持单页应用的打包构建；而H5页面通常对性能和可访问性有着极高的要求，因此通过构建来支持服务端渲染和PWA离线缓存。 其次，整个Node.js社区异常繁荣。 Node.js自2009年发布以来，至今已历时十年，迄今为止，已经有80多万的第三方组件，而且这个数字每天还在快速增加，而npm的组件在浏览器端的JS代码中并不能直接引入，这时候就需要借助webpack等构建工具，来快速复用各种优秀成熟的组件，从而加速Web开发。 最后，三大框架的语法需要构建工具来进行转换。 React、Angular和Vue的一些语法，比如JSX和Vue指令，在浏览器都是无法直接解析的，也需要经过构建工具进行转换，而webpack是前端构建领域里最耀眼的，无论前端走哪条路线，都需要有很强的webpack知识。 熟悉webpack的使用和原理，可以拓宽你的前端技术栈，在发现页面打包的速度和资源体积的问题时，能够知道如何排查问题和优化，同时熟悉webpack的原理，有助于对其他跨端应用的开发，比如在对小程序、Weex、React Native、Electron等框架的打包时，能够快速上手。 1-2 初学者在学习webpack的过程中会遇到哪些困难 刚接触webpack时，可能对webpack的打包理念-“一切皆为模块”感到困惑，在webpack中不仅仅JS是模块，其他的HTML、CSS、图片和字体等都可以成为模块。 其次，webpack配置异常灵活，并且具备强大的插件化扩展能力。上手webpack确实需要了解它其中的众多的新概念，如entry、output、mode、loaders、plugins、热更新、code spliting、tree shaking等，可能会让初学者望而生畏。 另外，webpack的进一步学习是有一定学习曲线的，包括webpack打包的速度、体积、页面加载时的性能优化等，是需要具备全面的webpack知识，搞懂它内部的运行原理和插件机制，才能深入掌握的。 1-3 课程阶段 基础篇 帮助掌握webpack的核心概念和开发必备技巧 进阶篇 将会让你以工程化的思维去编写一份健壮可维护的webpack构建配置，同时掌握webpack构建速度和体积的优化策略 原理篇 将会通过webpack的源码，让你了解它内部的运行原理以及编写自定义loader和插件的能力 实战篇 将会从一个Web商城项目出发，讲解webpack如何运用到实际的项目中去，并且最大化地提升开发阶段和发布阶段的构建体验。 2丨内容综述 3丨为什么需要构建工具 (它的作用在哪里) 转换ES6语法 低版本浏览器和国产手机浏览器不支持ES6特性 转换JSX 有许多框架层面的语法糖，比如像JSX、vue和angular的一些指令，浏览器也是没办法识别的，所以也需要经过构建工具来转换 语法糖（Syntactic sugar），也译为糖衣语法，是由英国计算机科学家彼得·约翰·兰达（Peter J. Landin）发明的一个术语，指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。 CSS前缀补全/预处理器 通过Less、Scss这些预处理器编出的代码让CSS具有可编程性，代码便于维护，编写方便，效率更高 压缩混淆 图片压缩 4丨前端构建演变之路待续…… 5丨为什么选择webpack 得益于它社区的活跃度，社区生态丰富 配置灵活和插件化扩展 对于不满足开发需要的，可以通过webpack的插件机制进行扩展，可以定义自己的loaders和插件，去满足团队个性化的需要 官方更新迭代速度快 6丨初识webpack6-1 webpack配置文件 官方默认：webpack.config.js 可以通过webpack –config指定配置文件 如开发环境使用 webpack --config webpack.dev.config.js，生产环境使用webpack --config webpack.prod.config.js。 除此之外，也可以指定一些服务端渲染和其他的一些情景下的配置文件的名称。 6-2 webpack配置组成 常用的配置： 零配置的webpack，只包含entry和output： 1234module.exports = &#123; entry: &#x27;./src/index.js&#x27;, output: &#x27;./dist/main.js&#x27;&#125; 7丨环境搭建-安装webpack7-1 安装nvm 通过curl安装： 运行$ curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.2/install.sh | bash 把nvm添加到环境变量中去：$ source ~/.bash_profile 判断nvm是否安装成功：$ nvm list 通过wget安装：wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.2/install.sh | bash 7-2 安装nodejs和npm 运行$ nvm install v10.15.3 查看Node.js是否安装成功$ node -v 查看npm是否安装成功$ npm -v 7-3 安装webpack和webpack-cli​ 由于在webpack4里将webpack的内核和webpack-cli进行分离，所以在实际项目中使用，需要分别同时安装。 创建空目录$ mkdir my-project 进入这个目录$ cd my-project 运行$ npm init -y，-y是指默认都选择yes 安装webpack和webpack-cli$ npm install webpack webpack-cli --save-dev，–save-dev(缩写为-D)是指依赖会安装到dev-dependencies里 打印webpack，确认是否安装成功./node_modules/.bin/webpack -v 8丨webpack初体验-一个最简单的例子 创建webpack的配置文件webpack.config.js： 123456789const path = require(&#x27;path&#x27;)module.exports = &#123; entry: &#x27;./src/index.js&#x27;, // 入口 output: &#123; path: path.join(__dirname, &#x27;dist&#x27;), // 输出的文件夹，其中__dirname代表当前文件夹下 filename: &#x27;bundle.js&#x27; // 打包出的文件名 &#125;, mode: &#x27;production&#x27; // 生产模式&#125; 创建一个业务文件src/helloworld.js，在其中编写一个简单的函数： 123export function helloworld() &#123; return &#x27;Hello webpack&#x27;&#125; 在src/index.js中引入那个函数并输出： 12import &#123; helloworld &#125; from &#x27;./helloworld&#x27;document.write(helloworld()) 运行打包$ ./node_modules/.bin/webpack，这样是不知道webpack配置文件的名称： 新建个html文件dist/index.html，手动引入脚本，在页面看下效果： 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Hello webpack&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;./bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 9丨通过npm script运行webpack 原理：模块局部安装会在node_modules/.bin目录创建软连接。 具体做法：package.json能够读取到.bin下的命令，在package.json中增加scripts，并在其中增加webpack命令 手动删除上次构建出来的dist目录$ rm -rf dist，还有更优雅的方式，以后再介绍 然后运行打包命令$ npm run build，dist目录依然能正确地打包出来。 10丨webpack核心概念之entry用法10-1 了解entry的含义 Entry用来指定webpack的打包入口，对应我们的源代码 为什么需要这个entry呢？ 这离不开webpack的构建机制，webpack是一个模块打包器，它会把一切的资源（如Js、Css等代码资源和图片、字体、文本等非代码资源）当作一个模块，而这些模块之间存在一定的依赖关系。因此，webpack根据入口文件entry，去找到依赖，入口文件的依赖可能也会依赖其他的文件，这样就存在一棵依赖树，在依赖树上只要遇到依赖，webpack就会将依赖文件加入到下面的依赖图中去，最终遍历完了才会生成一个打包后的资源。 10-2 entry的用法有两种情况： 单入口：entry是一个字符串，适用于只有一个页面，或者单页应用 123module.exports = &#123; entry: &#x27;./src/index.js&#x27;&#125; 多入口：entry是一个对象，适用于多页应用 123456module.exports = &#123; entry: &#123; app: &#x27;./src/app.js&#x27;, adminApp: &#x27;./src/adminApp.js&#x27; &#125;&#125; 11丨webpack核心概念之output11-1 output的核心概念output用来指定webpack的打包输出，对应打包后的结果代码。它告诉webpack如何将编译后的文件输出到磁盘：具体输出到磁盘的哪个目录、输出文件的名称 11-2 output的用法 单入口配置 1234567module.exports = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123; filename: &#x27;bundle.js&#x27;, path: __dirname + &#x27;/dist&#x27; &#125;&#125; 多入口配置 12345678910module.exports = &#123; entry: &#123; app: &#x27;./src/app.js&#x27;, search: &#x27;./src/search.js&#x27; &#125;, output: &#123; filename: &#x27;[name].js&#x27;, // 通过占位符确保文件名称的唯一 path: __dirname + &#x27;/dist&#x27; &#125;&#125; 以上编写完成后，新建src/search.js，先清除dist目录$ rm -rf dist，再打包$ npm run build，就可以看到在新生成的dist目录下含有index.js和search.js 12丨webpack核心概念之loaders12-1 loaders的核心概念 我们知道，webpack开箱即用只支持JS和JSON两种文件类型，对于像CSS文件、Less及目前市场上比较新的语法糖如JSX、Vue等等这些指令、字体等，webpack并不是很了解。怎么解决呢？ 需要通过loaders去处理，将webpack原生不支持的类型转化成支持的，使得webpack解析时将它们加入到依赖图里去。 loaders本身是一个函数，它接收源文件作为参数，经过loaders转化后输出返回转换后的结果。 12-2 常见的loaders有哪些 名称 描述 补充 babel-loader 转换ES6、ES7等JS新特性语法 css-loader 支持.css文件的加载和解析 因为webpack本身并不支持.css文件，每当在js代码中通过import语法引入css时，webpack都会用css-loader处理并解析它 less-loader 将less文件转换成css ts-loader 将TS转换成JS file-loader 进行图片、字体、富媒体等的打包 raw-loader 将文件以字符串的形式导入 另外，首屏的资源需要内联时，可以借助raw-loader thread-loader 多进程打包JS和CSS 正常情况下，webpack打包只开一个进程，thread-loader让webpack支持多进程，还可以使打包的速度更快 12-3 loaders的用法1234567891011module.exports = &#123; output: &#123; filename: &#x27;bundle.js&#x27; &#125;, module: &#123; rules: [&#123; test: /\\.txt$/, use: &#x27;raw-loader&#x27; &#125;] &#125;&#125; 其中，test指定匹配规则，use指定使用的loader名称。 13丨webpack核心概念之plugins13-1 核心概念 plugins用于打包输出文件bundle文件的优化，以及资源管理和环境变量的注入 通俗点讲，plugins可以理解为任何loaders没法做的事都可以用它来完成，比如构建之前需要删除目录，可以用plugins plugins作用于整个构建过程，即从构建开始到构建结束整个阶段都可以去使用plugins 13-2 常见的plugins有哪些 名称 描述 补充 CommonsChunkPlugin 将chunks相同的模块代码提取成公共js 通常用于多个页面打包的情况下，可以将每个页面公共的js模块提取成一些独立的commonJs CleanWebpackPlugin 清理构建目录 ExtractTextWebpackPlugin 将CSS从bundle文件里提取成一个独立的CSS文件 CopyWebpackPlugin 将文件或者文件夹拷贝到构建的输出目录 HtmlWebpackPlugin 创建html文件去承载输出的bundle 多页面打包时会用到 UglifyWebpackPlugin 压缩JS ZipWebpackPlugin 将打包出的资源生成一个zip包 13-3 plugins的用法12345678910module.exports = &#123; output: &#123; filename: &#x27;bundle.js&#x27; &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: &#x27;./src/index.html&#x27; &#125;) ]&#125; 14丨webpack核心概念之mode14-1 核心概念 mode用来指定webpack当前打包构建的环境，常用的有三个值：production、development或者none mode是webpack4.0提出的新概念 设置mode可以利用mode自动触发webpack内置的函数，默认值为production。假如设为development，webpack会默认开启在开发阶段的一些参数和插件的功能；如果设为none，webpack就什么都不做。 14-2 mode的内置函数功能 选项 描述 补充 development 意味着设置process.env.NODE_ENV的值为development，默认开启NamedChunksPlugin和NamedModulesPlugin 这两个插件在热更新(HRM)阶段很实用，可以在控制台打印出是哪个模块发生了热更新，这个模块的路径是什么样子的 production 意味着设置process.env.NODE_ENV的值为production，默认开启很多插件：FlagDependencyUsagePlugin、FlagIncludeChunksPlugin、ModuleConcatenationPlugin、NoEmitOnErrorsPlugin、OccurrenceOrderPlugin、SideEffectsFlagPlugin和TerserPlugin 开启这些插件，webpack会默认帮助做代码的压缩和生产阶段js的压缩，会默认识别package.json中的代码是否存在副作用的SideEffect参数 none 不开启任何优化选项 15丨解析es6和react jsx15-1 资源解析之解析es6 使用babel-loader 12345678module.exports = &#123; module: &#123; rules: [&#123; test: /\\.js$/, use: &#x27;babel-loader&#x27; &#125;] &#125;&#125; 并在项目里使用babel的配置文件.babelrc，增加ES6的babel preset配置：（1）具体要先安装$ npm i @babel/core @babel/preset-env babel-loader -D，然后创建.babelrc文件： 12345&#123; &quot;presets&quot;: [ &quot;@babel/preset-env&quot; ]&#125; （2）在webpack.config.js配置文件中的module.rules添加babel-loader，见上（3）配置完成后，运行$ rm -rf dist清除dist，再打包$ npm run build即可。 babel有两块比较重要的概念：presets和plugins。plugins可以理解成一个plugin对应一个功能，presets是一系列babel plugins的集合 15-2 资源解析之解析react jsx 安装react相关的库$ npm i react react-dom @babel/preset-react -D 在前面.babelrc配置的基础上，增加react的preset的配置： 123456&#123; &quot;presets&quot;: [ &quot;@babel/preset-env&quot;, &quot;@babel/preset-react&quot; ]&#125; 修改src/search.js，增加React和ReactDOM的引用，定义一个Search组件，render返回一个dom，再通过ReactDOM进行引用，把Search组件渲染出来，放到页面的root节点上去： 1234567891011import React from &#x27;react&#x27;import ReactDOM from &#x27;react-dom&#x27;class Search extends React.Component &#123; render() &#123; return &lt;div&gt;Search Text&lt;/div&gt; &#125;&#125;ReactDOM.render( &lt;Search /&gt;, document.getElementById(&#x27;root&#x27;)) 构建$ npm run build，成功后在dist下新建dist/search.html，引用dist/search.js，并在页面添加root节点，然后在页面就可以看出效果： 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt; &lt;title&gt;Document&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;div id&#x3D;&quot;root&quot;&gt;&lt;&#x2F;div&gt; &lt;script src&#x3D;&quot;.&#x2F;search.js&quot;&gt;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 16丨解析css less sass16-1 解析资源之解析css 在webpack里要想解析css，首先要使用css-loader，它的作用是用域加载.css文件，它的加载时机是在代码里比如在index.js中引用到了这个css，这时就会去加载css文件，并且将其转换成commonjs对象，插入到js代码中去。 然后还需要使用style-loader，它的作用是将样式通过&lt;style&gt;标签插入到head中去。 ​ 具体使用举例： 先安装$ npm i style-loader css-loader -D 安装完成后，创建src/search.css： 1234.search-text &#123; font-size: 20px; color: #f00;&#125; 然后在src/search.js引入并增加className： 123456789101112import React from &#39;react&#39;import ReactDOM from &#39;react-dom&#39;import &#39;.&#x2F;search.css&#39;class Search extends React.Component &#123; render() &#123; return &lt;div className&#x3D;&quot;search-text&quot;&gt;Search Text&lt;&#x2F;div&gt; &#125;&#125;ReactDOM.render( &lt;Search &#x2F;&gt;, document.getElementById(&#39;root&#39;)) 接下来在webpack.config.js配置文件中增加关于css的解析： 12345678module.exports &#x3D; &#123; module: &#123; rules: [&#123; test: &#x2F;\\.css$&#x2F;, use: [&#39;style-loader&#39;, &#39;css-loader&#39;] &#125;] &#125;&#125; ps: 这里需要注意的是loader是链式调用的，它执行顺序是从右向左的，因此我们先写style-loader，再写css-loader，这样在实际执行时会先使用css-loader去解析css，然后再将解析好的css传递给style-loader。 运行$ npm run build进行构建，然后在浏览器打开dist/search.html，可以看到样式生效了。 16-2 资源解析之解析less和sass 在webpack中解析less，要使用less-loader，它用于将less转换成css. 具体使用时要先进行安装$ npm i less less-loader -D 然后将src/search.css改为src/search.less，再把src/search.js中对它的引入后缀更改一下。 最后在配置中增加对less的解析，其实是在css的解析基础上增加个less-loader即可： 12345678module.exports &#x3D; &#123; module: &#123; rules: [&#123; test: &#x2F;\\.less$&#x2F;, use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;less-loader&#39;] &#125;] &#125;&#125; 以上准备就绪，运行$ npm run build重新打包，然后在浏览器中进行预览。 17丨解析图片和字体17-1 资源解析之解析图片 解析图片需要用到file-loader，用于处理文件。 先准备一张图片放到src/images中，并在src/search.js组件中使用它： 12345678import logo from &#39;.&#x2F;images&#x2F;logo.jpg&#39;class Search extends React.Component &#123; render() &#123; return &lt;div className&#x3D;&quot;search-text&quot;&gt; Search Text&lt;img src&#x3D;&#123;logo&#125;&#x2F;&gt; &lt;&#x2F;div&gt; &#125;&#125; 然后在配置文件中增加对图片资源的解析： 12345678module.exports &#x3D; &#123; module: &#123; rules: [&#123; test: &#x2F;\\.(png|jpg|gif|jpeg)$&#x2F;, use: &#39;file-loader&#39; &#125;] &#125;&#125; 记得安装$ npm i file-loader -D，然后运行构建脚本$ npm run build，其中框住部分为图片的哈希： 17-2 资源解析之解析字体 在webpack中解析字体和解析图片是一样的，因为图片和字体都不是代码文件，都可以采用file-loader处理。 具体使用时，先在src/search.less中引入字体： 123456789101112@font-face &#123; font-family: &#39;webfont&#39;; font-display: swap; src: url(&#39;.&#x2F;images&#x2F;webfont.woff2&#39;) format(&#39;woff2&#39;), url(&#39;.&#x2F;images&#x2F;webfont.woff&#39;) format(&#39;woff&#39;), &#x2F;* chrome、firefox *&#x2F; url(&#39;.&#x2F;images&#x2F;webfont.ttf&#39;) format(&#39;truetype&#39;); &#x2F;* chrome、firefox、opera、Safari, Android, iOS 4.2+*&#x2F;&#125;.search-text &#123; font-size: 20px; color: #f00; font-family: &#39;webfont&#39; !important;&#125; 然后再进行配置： 12345678module.exports &#x3D; &#123; module: &#123; rules: [&#123; test: &#x2F;\\.(woff|woff2|eot|ttf|otf)$&#x2F;, use: &#39;file-loader&#39; &#125;] &#125;&#125; 运行$ npm run build进行构建。 17-3 资源解析之使用url-loader 除file-loader之外，也可以采用url-loader处理图片和字体，二者功能上差不多。只不过，url-loader还可以设置较小资源自动转换base64。其实url-loader的内部也是用的file-loader。 采用url-loader进行小图片的base64转换时，需要配置参数options.limit，limit的单位是字节，其中10240字节等于10kb，表示如果图片的大小小于10k，webpack打包时会对它进行自动的base64转换。 12345678910111213module.exports &#x3D; &#123; module: &#123; rules: [&#123; test: &#x2F;\\.(png|jpg|gif|jpeg)$&#x2F;, use: [&#123; loader: &#39;url-loader&#39;, options: &#123; limit: 10240 &#125; &#125;] &#125;] &#125;&#125; 记得安装$ npm i url-loader -D，然后$ npm run build，发现图片为11kb，我们修改一下limit为11265，重新打包发现图片就被转换为base64打包到search.js中去了： 18丨webpack中的文件监听 以前我们修改源代码后，都会手动运行构建命令，十分麻烦、低效，因此在webpack中进行文件的自动编译，非常有必要。文件监听的作用是在发现源码发生变化时，自动重新构建出新的输出文件。 在webpack中开启文件监听模式，有两种方式： 启动webpack命令时，带上–watch参数，即在package.json中新配置个启动命令： 1234&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack&quot;, &quot;watch&quot;: &quot;webpack --watch&quot; &#125;, 我们只需要在开始编译时，运行$ npm run watch，之后每当有文件变化，它会自动监听文件变化，并且自动进行构建。 在配置webpack.config.js中设置watch: true。 以上两种方式的唯一缺陷：webpack每次自动编译完成后，浏览器不会自动刷新，需要手动刷新浏览器。 文件监听的原理分析： webpack会轮询判断文件的最后编辑时间是否变化。 一开始我们有个文件的修改时间，这个时间会先被存储起来，下一次再有修改时，就会和上一次的修改时间进行比对，如果发现不一致，并不会立刻告诉监听者，而是先将这个文件的修改缓存起来，等待一定时间。等待的这段时间内，如果有其他文件也发生了变化，它会把这些变化了的文件列表一起构建，最后一起把构建的结果生成到bundle文件中。 webpack.config.js中添加的配置如下： 12345678module.exports = &#123; watch: true, // 默认false，也就是不开启 watchOptions: &#123; // 只有开启监听模式时，watchOptions才有意义 ignored: /node_modules/, // 默认为空，不监听的文件或文件夹，支持正则匹配 aggregateTimeout: 300, // 监听到变化发生后会等300ms再去执行，默认300ms poll: 1000 // 判断文件是否发生变化是通过不停询问系统指定文件有没有变化实现的，默认每秒问1000次 &#125;,&#125; aggregateTimeout是指前面所说的缓存的等待时间；轮询的时间是由poll进行控制，默认每秒循环1k次；ignored参数把node_modules忽略掉，文件监听的性能就会有所提升。 19丨webpack中的热更新及原理分析19-1 热更新之webpack-dev-server 第18讲的两种文件监听方式都存在需要手动刷新浏览器的缺陷，实际上webpack有更好的方式，就是借助WDS，它在每次代码有修改时，都会自动构建，构建完成后通过热更新的方式让浏览器中的内容自动变化，即WDS不需要手动刷新浏览器。 WDS通常与HotModuleReplacementPlugin插件一起结合使用，开启热更新的功能。 WDS有个比较大的优势，它没有磁盘的I/O，它不输出文件，它的文件放在内存中，而不是像watch方式那样将文件放到本地磁盘中去，所以它的构建速度也会有更大的优势。 WDS举例说明 在package.json中添加dev命令： 123&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --open&quot; &#125;, –open参数是指每次构建完成后，自动开启一个浏览器。 先注释掉字体代码，因为它较大，影响构建速度。因为WDS只有在开发时使用，所以先将webpack.config.js中的mode改为development。 在配置文件中引入webpack内置的HMR插件： 123456const webpack = require(&#x27;webpack&#x27;)module.exports = &#123; plugins: [ new webpack.HotModuleReplacementPlugin() ]&#125; 配置devServer，首先指定WDS服务的基础的目录，同时开启热更新： 123456module.exports = &#123; devServer: &#123; contentBase: &#x27;./dist&#x27;, hot: true &#125;&#125; 记得安装$ npm i webpack-dev-server -D，然后再运行$ npm run dev，会自动打开一个localhost:8080窗口，把构建的所有内容都输出出来： 点击search.html页面，修改src/search.js中代码保存后，验证发现页面内容即时发生了变化，浏览器并没有被刷新。 19-2 热更新之使用webpack-dev-middleware WDM方式与HMR方式可以实现相同的效果，却比它更加灵活。 使用WDM方式需要再引入Node的server，即我们自己创建一个node server，通常是用Express或者koa。 WDM可以将webpack输出的文件传输给服务器，适用于比较灵活的定制场景，我们可以对webpack的配置控制得更多。 19-3 热更新的原理分析​ 先了解图中的几个概念： Webpack Compiler即webpack的编译器，它的作用是将JS源代码编译成bundle.js，即打包好输出的那个文件。 HMR Server用来将热更新的文件传输给HMR Runtime。 Bundle server提供文件在浏览器中的访问，比如编译好的bundle.js本来在浏览器中是通过文件目录的方式访问，Bundle server可以使它通过服务器方式访问，比如localhost:8080/bundle.js。 HRM Runtime在开发阶段的打包阶段会被注入到浏览器端的bundle.js中，这样浏览器端的bundle.js就可以和服务器之间建立一个连接，通常这个连接是个websocket，然后就可以更新文件的变化，当它收到有些文件更新的数据回包后，就会自动更新这个文件。 bundle.js是指构建输出的文件。 热更新有两个过程： 启动阶段：文件系统进行编译，经过Webpack Compile进行打包，打包后将编译好的文件传输给bundle server，这个bundle server其实就是个服务器，它可以以server的方式让这个文件被浏览器访问到，即图中的1-&gt;2-&gt;A-&gt;B。 对于文件更新的情况，即本地开发时有文件发生了变化，这时候的流程其实是个文件系统的变化，变化好后代码还是会经过Webpack Compile进行编译，编译好后它会将代码发送给HMR Server，HMR Server就可以知道哪些模块(是指源代码部分的模块)发生了改变，然后它就会通知HMR Runtime，HMR Server是在服务端，HMR Runtime在客户端，相当于HMR的server端通知到浏览器端哪些文件发生了变化，这个通知过程通常是以JSON数据形式进行传输，传输到HMR Runtime后，它就会更新我们的代码，最终代码就会发生改变，并且不会且不需要刷新浏览器，这个过程为2-&gt;3-&gt;4-&gt;5. 20丨文件指纹策略 (chunkhash contenthash hash)20-1 文件指纹的含义 是指打包后输出的文件名的后缀。 图中index_后的6位字符其实就是文件指纹。 文件指纹的好处是它通常被用来做一些版本的管理，比如每次项目要发布时，有些文件修改了有些没修改，我们只需要将修改了的文件发布上去，没有修改的文件指纹并不需要更改。另外，设置了文件指纹，对于没修改的文件，可以用浏览器本地的缓存，这样可以加速我们页面的访问。 20-2 文件指纹如何生成或者说常见的文件指纹有哪几种 Hash：和整个项目的构建相关，在webpack打包阶段有compile和compilation，compile是webpack启动的那一次，会创建一个compile对象；compilation是每次只要有文件发生了变化也就会变化。因此只要项目文件有修改，整个项目构建的hash值就会收到compilation的影响而发生变化。比如修改了A页面的js，打包后B页面的js的hash值也会变化，其实是没有必要的，这就需要引入Chunkhash的概念。 Chunkhash：和webpack打包的chunk有关，chunk通常是指模块，不同的entry会生成不同的chunkhash值，即不同入口的chunk保持独立，这样A页面有一个文件发生了变化并不会影响其他页面，因此对于js的指纹，我们常采用Chunkhash。 Contenthash：某个页面既有js资源又有css资源，如果css资源也使用Chunkhash，就会存在一个问题，即我们修改了js但css并没有变，然后导致css内容没有变化，但发布上去的文件却改变了。因此对于css我们采用根据内容进行文件指纹的生成，即采用Contenthash。 20-3 文件指纹的设置 JS的文件指纹只需要设置输出output的filename，使用[chunkhash]： 123456module.exports &#x3D; &#123; output: &#123; path: path.join(__dirname, &#39;dist&#39;), filename: &#39;[name][chunkhash:8].js&#39; &#125;,&#125; CSS文件在正常情况下，会由style-loader将css插入到style里，并放到head头部，这时并没有一个独立的css文件，因此我们采用MiniCssExtractPlugin，通过这个插件把style-loader里的css提取出来，成为一个独立文件。因此对于CSS的文件指纹也是设置MiniCssExtractPlugin的filename，并使用[contenthash]： 1234567module.exports &#x3D; &#123; plugins: [ new MiniCssExtractPlugin(&#123; filename: &#39;[name][contenthash:8].css&#39; &#125;) ],&#125; 图片和字体的文件指纹设置在file-loader或者url-loader的options.name里，使用[hash]： 12345678910111213module.exports &#x3D; &#123; module: &#123; rules: [&#123; test: &#x2F;\\.(png|jpg|gif|jpeg)$&#x2F;, use: [&#123; loader: &#39;file-loader&#39;, options: &#123; name: &#39;img&#x2F;[name][hash:8].[ext]&#39; &#125; &#125;] &#125;] &#125;,&#125; 注意：这里的hash和前面js和css里的hash不一样，这里的hash也是指文件内容的hash，是采用md5生成的。通常我们会把图片放到img文件夹中，[hash:8]代表取hash串的前8位，md5的hash默认有32位。 20-4 举例说明 我们需要把webpack.config.js改为webpack.dev.js代表开发阶段的webpack配置，并复制创建一个生产环境的配置文件webpack.prod.js，因为Chunkhash没办法和热更新一起使用，所以需要去掉，并修改mode为production。 再修改package.json： 1234&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack --config webpack.prod.js&quot;, &quot;dev&quot;: &quot;webpack-dev-server --config webpack.dev.js --open&quot; &#125;, 在webpack.prod.js中增加js和图片、字体的文件指纹，并运行$ npm run build进行构建： 1234567891011121314151617181920212223242526const path &#x3D; require(&#39;path&#39;)module.exports &#x3D; &#123; output: &#123; path: path.join(__dirname, &#39;dist&#39;), filename: &#39;[name]_[chunkhash:8].js&#39; &#125;, module: &#123; rules: [&#123; test: &#x2F;\\.(png|jpg|gif|jpeg)$&#x2F;, use: [&#123; loader: &#39;file-loader&#39;, options: &#123; name: &#39;[name]_[hash:8].[ext]&#39; &#125; &#125;] &#125;, &#123; test: &#x2F;\\.(woff|woff2|eot|ttf|otf)$&#x2F;, use: [&#123; loader: &#39;file-loader&#39;, options: &#123; name: &#39;[name]_[hash:8].[ext]&#39; &#125; &#125;] &#125;] &#125;&#125; 设置css的文件指纹： 先安装$ npm i mini-css-extract-plugin -D 在webpack.prod.js中引入使用： 12345678const MiniCssExtractPlugin &#x3D; require(&#39;mini-css-extract-plugin&#39;)module.exports &#x3D; &#123; plugins: [ new MiniCssExtractPlugin(&#123; filename: &#39;[name]_[contenthash:8].css&#39; &#125;) ]&#125; 因为这个插件是把css提取成独立的css文件，它与style-loader把css插入到head中的功能是互斥的，所以需要做如下配置，配置完成后重新$ npm run build： 12345678910111213141516module: &#123; rules: [&#123; test: &#x2F;\\.css$&#x2F;, use: [ MiniCssExtractPlugin.loader, &#39;css-loader&#39; ] &#125;, &#123; test: &#x2F;\\.less$&#x2F;, use: [ MiniCssExtractPlugin.loader, &#39;css-loader&#39;, &#39;less-loader&#39; ] &#125;]&#125; 20-5 补充生产环境的配置和开发环境的配置文件对比 生产环境不需要热更新 mode的区别 21丨html css js代码压缩21-1 js文件的压缩 webpack4.0内置了uglifyjs-webpack-plugin插件，所以我们默认打包出来的js文件就已经被压缩过了，我们就不需要做其他的操作。 当然，我们也可以手动安装这个插件，然后自定义设置一些额外的参数，比如默认开启并行压缩，是通过parallel参数控制的。 21-2 css文件的压缩 在webpack3.0时是通过css-loader设置minify参数来压缩的，但是css-loader在1.0之后去掉了这个参数，所以该方法就行不通了。 现在，我们使用optimize-css-assets-webpack-plugin插件，同时安装预处理器cssnano，然后匹配到所有的css文件，然后再对它采用预处理器进行压缩。 具体做法： 安装$ npm i optimize-css-assets-webpack-plugin -D 添加到webpack.prod.js配置中： 123456789const OptimizeCssAssetsPlugin &#x3D; require(&#39;optimize-css-webpack-assets-plugin&#39;)module.exports &#x3D; &#123; plugins: [ new OptimizeCssAssetsPlugin(&#123; assetNameRegExp: &#x2F;\\.css$&#x2F;g, cssProcessor: require(&#39;cssnano&#39;) &#125;) ]&#125; 因为这个插件依赖css处理器，所以需要安装$ npm i cssnano -D 以上准备完成后，清除dist$ rm -rf dist，重新打包$ npm run build，就可以看到css其实是压缩成功了： 然后也可以看到dist/search.js文件默认也被压缩了。 21-3 html文件的压缩 使用一个强大的、使用webpack必接触的插件html-webpack-plugin，设置压缩参数。这个插件自身支持传入minify参数，这个参数可以把空格、换行符、注释等都处理掉，以达到压缩的效果。 具体做法： 新建src/index.html和src/search.html 安装$ npm i html-webpack-plugin -D 在webpack.prod.js中配置; 12345678910111213141516171819202122232425262728293031323334const path &#x3D; require(&#39;path&#39;)const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;)module.exports &#x3D; &#123; plugins: [ new HtmlWebpackPlugin(&#123; template: path.join(__dirname, &#39;src&#x2F;index.html&#39;), filename: &#39;index.html&#39;, chunks: [&#39;index&#39;], inject: true, minify: &#123; html5: true, collapseWhitespace: true, preserveLineBreaks: false, minifyCSS: true, minifyJS: true, removeComments: false &#125; &#125;), new HtmlWebpackPlugin(&#123; template: path.join(__dirname, &#39;src&#x2F;search.html&#39;), filename: &#39;search.html&#39;, chunks: [&#39;search&#39;], inject: true, minify: &#123; html5: true, collapseWhitespace: true, preserveLineBreaks: false, minifyCSS: true, minifyJS: true, removeComments: false &#125; &#125;) ]&#125; 参数说明： template指的是html模板所在的位置，这个模板里可以使用ejx的语法； filename是指定打包出来的html文件名称； chunks指定生成html要使用哪些chunk； inject为true是指打包出来的chunk如js和css，会自动注入到这个html里。以上每一个new的HtmlWebpackPlugin都是一个单页的html，如果多个html，需要用多个htmlWebpackPlugin，后面会讲更简洁的办法。 构建$ npm run build，可以看到dist下的那两个html都被成功压缩了： 如果我们想看效果，在src/search.html添加root节点，重新打包，打开dist/search.html即可看到。 22丨自动清理构建目录产物 前面章节构建时存在的问题： 每次构建的时候不会清理目录，造成构建的输出目录output文件越来越多 通过npm scripts清理构建目录： rm -rf ./dist &amp;&amp; webpack rimraf ./dist &amp;&amp; webpack 这个方法并不优雅，还有更好的办法！ 这个办法就是使用webpack的插件clean-webpack-plugin，实现自动清理构建目录： 能避免每次构建前都需要手动删除dist； 这个插件我们只需将其安装并引入进来，使用时默认会删除output指定的输出目录。 插件clean-webpack-plugin的具体用法： 安装$ npm i clean-webpack-plugin -D 在webpack.dev.js和webpack.prod.js中都进行以下配置： 123456const &#123; CleanWebpackPlugin &#125; &#x3D; require(&#39;clean-webpack-plugin&#39;)module.exports &#x3D; &#123; plugins: [ new CleanWebpackPlugin() ],&#125; 运行构建两次$ npm run build，验证了dist下的文件确实没有增加。 23丨postcss插件autoprefixer自动补齐css3前缀 CSS3的属性为什么需要前缀？ 因为浏览器的标准并没有完全统一，目前有4种浏览器内核，分别是： 内核 浏览器代表 前缀 Webkit 谷歌 -webkit Geko 火狐 -moz Trident IE -ms Presto 欧朋 -o 举个例子：给一个盒子设置某个css3属性，以前需要手动补全前缀解决样式的不兼容问题： 1234567.box &#123; -webkit-border-radius: 10px; -moz-border-radius: 10px; -ms-border-radius: 10px; -o-border-radius: 10px; border-radius: 10px;&#125; 在webpack中，可以通过PostCSS的插件autoprefixer来自动补全CSS3前缀。autoprefixer是css的一个后置处理器，是在打包后样式生成后对样式进行后置处理，而less和sass是css的预处理器，一般在打包前处理。 这个插件是根据Can I Use规则（https://caniuse.com/），搜一下试试： 这个插件通常是和postcss-loader一起使用（https://github.com/postcss/postcss-loader），postcss-loader的功能非常强大，除了支持css3前缀补全外，还支持css modules和style lint等. 具体使用： 安装$ npm i postcss-loader autoprefixer -D 在webpack.prod.js中进行配置： 12345678910111213141516171819202122module.exports &#x3D; &#123; module: &#123; rules: [&#123; test: &#x2F;\\.less$&#x2F;, use: [ MiniCssExtractPlugin.loader, &#39;css-loader&#39;, &#39;less-loader&#39;, &#123; loader: &#39;postcss-loader&#39;, options: &#123; plugins: () &#x3D;&gt; [ require(&#39;autoprefixer&#39;)(&#123; browsers: [&#39;last 2 version&#39;, &#39;&gt;1%&#39;, &#39;ios 7&#39;] &#125;) ] &#125; &#125; ] &#125;] &#125;,&#125; autoprefixer这个插件有一个参数browsers，表示autoprefixer所需要兼容的浏览器版本，以上的取值表示兼容浏览器最近的两个版本、这个浏览器的版本使用人数所占的比例等。 运行$ npm run build重新构建，效果如下： 24丨移动端css px自动转换成rem 由于浏览器的分辨率不同，需要在webpack中做自动的rem转换，分辨率以IOS为例： 在以前，我们使用CSS的媒体查询实现响应式布局，有个缺陷，即需要写多套适配样式代码，影响开发效率。 现在有个很好的方式，使用rem。 W3C对rem的定义：font-size of the root element，即根元素的字号大小。 rem和px的对比：rem是相对单位，px是绝对单位。 在webpack中，使用px2rem-loader实现px自动转换成rem，然后在页面渲染时动态计算根元素的font-size值。我们可以利用手淘里比较成熟的方案lib-flexible库https://github.com/amfe/lib-flexible，这个库会自动根据当前设备的宽高计算根元素实际的font-size值。 具体使用： 安装$ npm i px2rem-loader -D和$ npm i lib-flexible -S，-S可以将其安装到项目依赖中去。 在webpack.prod.js中配置： 12345678910111213141516171819202122232425module.exports &#x3D; &#123; module: &#123; rules: [&#123; test: &#x2F;\\.less$&#x2F;, use: [ MiniCssExtractPlugin.loader, &#39;css-loader&#39;, &#39;less-loader&#39;, &#123; loader: &#39;postcss-loader&#39;, options: &#123; ...... &#125; &#125;, &#123; loader: &#39;px2rem-loader&#39;, options: &#123; remUnit: 75, remPrecision: 8 &#125; &#125; ] &#125;] &#125;,&#125; remUnit是rem相对于px的转换的单位，设置成75表示，1rem=75px，这时候就比较适合750的设计稿； remPrecision是px转换成rem时的小数点位数。 运行$ npm run build进行构建，结果如下： 接下来，需要将根元素的相对rem单位设置出来，也就是根元素html这个节点在实际设备分辨率下的font-size大小。这时，我们需要libflexible，目前的构建还不支持这个代码的内联，所以需要先手动的将其内联到src/search.html中。这个lib flexible文件是指node_modules下的lib-flexible下的flexible.js，将其中的js代码复制到search.html中。 这里需要注意的是，由于我们不能把这段代码打包到js中去，但是需要在页面打开时马上计算这个值，所以它的位置需要前置，放在head标签下的script中。 以上设置完成后，我们重新构建，这时候页面就拥有了自动计算根元素font-size大小的能力，看下页面效果： 25丨静态资源内联25-1 资源内联的意义 代码层面： 页面框架的初始化脚本： 打开一个页面需要做初始化的工作，比如上节中，刚打开页面就需要计算rem根元素的font-size的大小。 上报相关打点： 比如page start、css和js的初始化和加载完成等等一些上报点的代码都需要内联到html里去，而不能直接放到脚本中。 css内联避免页面闪动： 通常情况下，我们会把整个页面的css或者首屏的css的内流内联到html中，这样保证在加载页面的同时即html回来时，css也能回来，从而避免页面的闪动。 请求层面：资源内联能减少HTTP网络请求数量 小图片或者字体内联: 比如把小于5k或10k的图片或字体文件内联到代码中，之前讲过，使用url-loader，添加参数limit即可。 25-2 代码层面的html和js内联 可以直接使用raw-loader，建议使用v0.5.1，因为最新的版本存在问题。 CSS内联： 比如在开发手机端页面时，会有大段的meta信息，这是每个页面都需要的，这时我们就可以把meta片段拆出来成meta.html，每个页面模板把它内联进来。 JS内联： 比如可以把lib-flexible库内联进来，如果内联的脚本是我们自己写的业务代码，存在ES6代码，我们除了raw-loader外，还需要加上babel-loader，这样在内联之前可以将ES6代码进行转换，转换完成后再通过raw-loader将其内联进来。 具体做法： 整理src下的文件目录，新建src/search/meta.html，代码来自view-source:https://now.qq.com/： 安装$ npm i raw-loader@0.5.1 -D，raw-loader的原理：它读取一个文件，然后把自己返回的string插入到对应的内容。 删除src/search/index.html中头部的meta，并把meta.html引入进来，这里需要注意的是，因为我们使用的是html-webpack-plugin，它默认的模板引擎是是ejs的模板引擎，所以可以直接使用$&#123;&#125;语法。 然后再把rem计算的脚本引入进来，结合第3步，index.html如下： 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; $&#123; require(&#39;raw-loader!.&#x2F;meta.html&#39;) &#125; &lt;title&gt;Document&lt;&#x2F;title&gt; &lt;script&gt;$&#123; require(&#39;raw-loader!babel-loader!..&#x2F;..&#x2F;node_modules&#x2F;lib-flexible&#x2F;flexible.js&#39;) &#125;&lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;div id&#x3D;&quot;root&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 构建后，进入dist和网页查看： 25-2 代码层面的css内联主要有两种做法： 借助style-loader，给它设置参数singleton:true，这样就能在打包完成后将所有的style标签合并成一个。 1234567891011121314151617181920module.exports &#x3D; &#123; module: &#123; rules: [ &#123; test: &#x2F;\\.scss$&#x2F;, use: [ &#123; loader: &#39;style-loader&#39;, options: &#123; insertAt: &#39;top&#39;, &#x2F;&#x2F; 样式插入到&lt;head&gt; singleton: true &#125; &#125;, &#39;css-loader&#39;, &#39;sass-loader&#39; ] &#125; ] &#125;&#125; 使用html-inline-css-webpack-plugin插件，这是应用更加广泛的方式，它是针对打包好的css chunk代码，怎么把它内联到html的head和head之间。 26丨多页面应用打包通用方案26-1 多页面应用 (mpa) 的概念 每一次页面跳转的时候，后台服务器都会给返回一个新的html文档，这种类型的网站也就是多页网站，也叫做多页应用。 跟单页面应用相比，最直接的是多页面发布上线之后，有很多个入口，即一个页面就是一个业务，而单页面应用是把所有业务都放到一个大的入口里面去，不同的子业务还是同一个url，只不过它后面的哈希不同。 多页面应用的优势： 多页面应用相当于每个页面之间是解耦的； 多页面应用对SEO更加友好。 26-2 多页面打包的基本思路 前面章节的做法是每个页面对应一个entry、对应一个html-webpack-plugin。这种做法的缺点是，每次新增或删除页面，都需要手动修改webpack配置，即修改对应的entry及与之对应的html-webpack-plugin。 更好的做法是，动态获取entry和设置html-webpack-plugin数量。 在webpack里，可以利用glob https://www.npmjs.com/package/glob，glob的原理类似linux操作系统下的文件的通配匹配的概念，我们需要输入一个类似正则的匹配规则，然后glob会把匹配到的文件信息或目录的内容返回回来，然后我们就操作这个返回的内容即可。 利用glob.sync，它是用同步的方式把文件都查询出来：entry: glob.sync(path.join(__dirname, &#39;./src/*/index.js&#39;)) __dirname是指执行webpack脚本时所在的目录，即项目的根目录。这里我们有个约定，就是把所有页面都放在src下的文件夹目录的index.js中，这样我们就能通过js脚本获取src里面所有的目录，然后就可以指定所有入口文件的数量，在打包的时候就可以动态地设置html-webpack-plugin。 具体做法： 整理src下的文件目录，然后安装$ npm i glob -D 在webpack.prod.js中，先定义函数setMPA，动态设置entry和htmlWebpackPlugins，先$ npm run build 打印entryFiles看下： 123456789101112const glob &#x3D; require(&#39;glob&#39;)const setMPA &#x3D; () &#x3D;&gt; &#123; let entry &#x3D; &#123;&#125; let htmlWebpackPlugins &#x3D; [] const entryFiles &#x3D; glob.sync(path.join(__dirname, &#39;.&#x2F;src&#x2F;*&#x2F;index.js&#39;)) console.log(&#39;entryFiles&#39;, entryFiles) return &#123; entry, htmlWebpackPlugins &#125;&#125;setMPA() 动态设置entry，再次打印： 123456Object.keys(entryFiles) .map((index) &#x3D;&gt; &#123; const entryFile &#x3D; entryFiles[index] const pageName &#x3D; entryFile.match(&#x2F;src\\&#x2F;(.*)\\&#x2F;index\\.js&#x2F;) console.log(&#39;pageName&#39;, pageName) &#125;) 完成后的相关代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142const glob &#x3D; require(&#39;glob&#39;)const path &#x3D; require(&#39;path&#39;)const HtmlWebpackPlugin &#x3D; require(&#39;html-webpack-plugin&#39;)const setMPA &#x3D; () &#x3D;&gt; &#123; let entry &#x3D; &#123;&#125; let htmlWebpackPlugins &#x3D; [] const entryFiles &#x3D; glob.sync(path.join(__dirname, &#39;.&#x2F;src&#x2F;*&#x2F;index.js&#39;)) Object.keys(entryFiles) .map((index) &#x3D;&gt; &#123; const entryFile &#x3D; entryFiles[index] const match &#x3D; entryFile.match(&#x2F;src\\&#x2F;(.*)\\&#x2F;index\\.js&#x2F;) const pageName &#x3D; match &amp;&amp; match[1] entry[pageName] &#x3D; entryFile htmlWebpackPlugins.push( new HtmlWebpackPlugin(&#123; template: path.join(__dirname, &#96;src&#x2F;$&#123;pageName&#125;&#x2F;index.html&#96;), filename: &#96;$&#123;pageName&#125;.html&#96;, chunks: [pageName], inject: true, minify: &#123; html5: true, collapseWhitespace: true, preserveLineBreaks: false, minifyCSS: true, minifyJS: true, removeComments: false &#125; &#125;) ) &#125;) return &#123; entry, htmlWebpackPlugins &#125;&#125;const &#123; entry, htmlWebpackPlugins &#125; &#x3D; setMPA()module.exports &#x3D; &#123; entry, plugins: [ ...... ].concat(htmlWebpackPlugins)&#125; 然后再浏览器中查看dist/index.html和dist/search.html即可验证以上配置完全正确。 27丨使用sourcemap 作用：通过sourcemap定位到源代码 sourcemap的科普文http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html 一般情况下，sourcemap会在开发环境默认开启，线上环境关闭。之所以关闭是因为如果把sourcemap放上去，会把业务逻辑暴露出来，如果非要用，建议用对源码分析没那么深的sourcemap。 线上排查问题的时候，可以将sourcemap上传到错误监控系统。 sourcemap关键字： eval 在打包时，eval会将模块代码包裹起来，然后在每段代码块的后面会有一个sourcemap的文件，即sourcemap的url，来指定sourcemap的信息。 source map 会产生.map文件，也就是说sourcemap文件与打包出来的js、css文件是分离的。 cheap 不包含列信息，也就是说报错时，我们点开错误堆栈，会定位到几行几列，假如使用cheap的sourcemap，当报错时就没办法定位到列了。 inline 将.map作为DataURI嵌入，不单独生成.map文件，即soucemap的内容和js代码是打包在一起的，或者说sourcemap的内容内联到js文件中了。 module 指包含loader的sourcemap，当出错时可以进一步定位。 sourcemap的类型： 详见官网https://webpack.js.org/configuration/devtool/#devtool 具体用法： 将webpack.prod.js的mode设为none，再作如下设置，看下打包后的效果： 1234module.exports &#x3D; &#123; mode: &#39;none&#39;, devtool: &#39;eval&#39;&#125; > 可以看到，设置成eval，打包后没有单独的sourcemap文件，会把sourcemap放到js里去，是通过eval()方法将代码包裹起来，在eval后面有个sourceURL，来指定这个js对应的是哪个文件。 设置devtool: &#39;source-map&#39;，打包后发现在dist目录下生成了.map文件，且它与js文件分离，且在js文件的最后一行告诉它要使用的sourcemap文件是哪一个： 设置devtool: &#39;inline-source-map&#39;，打包后sourcemap的内容和js是在一起的，就没有独立的.map文件了： 可以看到，最后一行直接把sourcemap依赖进来了，js文件大小增大了许多 在本地开发时怎么利用sourcemap加速代码调试？ 先手动把上节讲的多页面打包代码复制到webpack.dev.js中 在src/search/index.js中打个断点debugger，先不使用sourcemap，$ npm run dev打包后看一下代码效果： 使用devtool: &#39;source-map&#39;打包后的效果： 使用devtool: &#39;cheap-souce-map&#39;打包后如果报错，只能看到行的错误堆栈，而不能看到列的，在src/search/index.js中乱写一行错误代码，打包后效果如下： 28丨提取页面公共资源28-1 基础库分离 方法一：使用html-webpack-externals-plugin 将react、react-dom基础包通过cdn引入，不打入bundle中，例如： 方法二（建议）：利用SplitChunksPlugin进行公共脚本分离 webpack4内置的，替代CommonsChunkPlugin插件，使用举例： chunks参数说明： async 对异步引入的库进行分离（默认）： 比如，在es6中动态import vue库，这个插件就只会分析这些异步引入的库，对同步引入的就会忽略掉。 initial 对同步引入的库进行分离： 即对同步引入的包如果相同的话，就会抽离出一个chunk all 对所有引入的库进行分离（推荐） minSize 表示抽离的公共包的最小的体积，单位是字节 maxSize 表示最大的体积 minChunks 该chunks使用的次数，比如某个公共方法在2个页面使用，这个minChunks就是2，意味着大于2时才会被提取成公共文件 maxAsyncRequests 浏览器同时请求的异步资源的次数，比如某些异步js通过这个插件分离出3个资源，这个参数就表示这些资源同时请求的数量 这个插件怎么使用呢： test：匹配出需要分离的包 28-2 实战举例 方法一举例 在npm官网找到并安装插件$ npm i html-webpack-externals-plugin -D 在webpack.prod.js中添加： 12345678910111213141516171819const HtmlWebpackExternalsPlugin = require(&#x27;html-webpack-externals-plugin&#x27;)module.exports = &#123; plugins: [ new HtmlWebpackExternalsPlugin(&#123; externals: [ &#123; module: &#x27;react&#x27;, entry: &#x27;https://now8.gtimg.com/now/lib/16.2.0/react.min.js&#x27;, global: &#x27;React&#x27;, &#125;, &#123; module: &#x27;react-dom&#x27;, entry: &#x27;https://now8.gtimg.com/now/lib/16.2.0/react-dom.min.js&#x27;, global: &#x27;ReactDOM&#x27;, &#125; ], &#125;) ]&#125; 其中entry是从 NOW直播 的复制的cdn地址 然后运行$ npm run build，并看下效果： 可以看出将react和react-dom提出后，search.js文件明显少了好多。 然后在src/search/index.html中将react和react-dom引入进来： 12345&lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script src=&quot;https://now8.gtimg.com/now/lib/16.2.0/react.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://now8.gtimg.com/now/lib/16.2.0/react-dom.min.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; 然后重新构建，就可以在dist/search.html中审查元素看到这两个js的引用了。 方法二举例 通过SplitChunks分离基础包 在webpack.prod.js中添加： 12345678910111213module.exports = &#123; optimization: &#123; splitChunks: &#123; cacheGroups: &#123; commons: &#123; test: /(react|react-dom)/, name: &#x27;vendors&#x27;, chunks: &#x27;all&#x27; &#125; &#125; &#125; &#125;,&#125; 以上配置完成后重新构建，可以看到vendors.js： 如果真正要使用它，就需要将这个vendorsChunk添加到html-webpack-plugin的chunks中，重新打包： 123456789new HtmlWebpackPlugin(&#123; template: path.join(__dirname, `src/$&#123;pageName&#125;/index.html`), filename: `$&#123;pageName&#125;.html`, chunks: [&#x27;vendors&#x27;, pageName], inject: true, minify: &#123; ...... &#125;&#125;) 然后就可以看到vendors引用成功了： 通过SplitChunks分离页面公共的文件 新建common/index.js： 123export function common() &#123; return &#x27;this is common&#x27;&#125; 在src/search/index.js和src/index/index.js中分别引用： 1import &#x27;../../common&#x27; 在webpack.prod.js中更新配置： 123456789101112optimization: &#123; splitChunks: &#123; minSize: 0, cacheGroups: &#123; commons: &#123; name: &#x27;commons&#x27;, chunks: &#x27;all&#x27;, minChunks: 2 &#125; &#125; &#125; &#125;, minSize: 0 表示只要有引用就会打包出commons.js文件 重新打包，可以看到commons.js，也可以在dist下看到该文件： 假如把配置中的minSize设为1000或minChunks设为3，重新打包后都没有commons文件： 同样，如果我们要在页面中引入，需要在html-webpack-plugin的chunks中添加commons。 29丨treeshaking的使用和原理分析29-1 tree shaking (摇树优化) 概念 一个模块可能有多个方法，只要其中的某个方法使用到了，则整个文件都会被打到bundle里面去，tree shaking就是只把用到的方法打入bundle，没用到的方法会在uglify阶段（webpack的构建阶段）被擦除掉。 使用 它并不是webpack一开始就有的，是借鉴了rollup工具；webpack4中默认支持，在.babelrc里设置modules: false 即可。 mode: production的情况下默认开启 要求 必须是ES6的预防，node.js中的CJS的方式（如require方法）不支持。 29-2 tree shaking的原理 在讲解原理前，先了解DCE(Dead Code Elimination)的概念： 代码不会被执行，不可到达。如： 123if(false) &#123; console.log(&#x27;这段代码永远不会执行&#x27;)&#125; 代码执行的结果不会被用到。比如定义了一个函数，这个函数返回一个结果，但如果不把这个结果赋值给一个变量，且不在其他地方用到。 代码只会影响死变量（只写不读）。比如定义了一个变量，我们还对它进行了赋值，却没有使用。 具体原理 利用ES6模块的特点： 只能作为模块顶层的语句出现 import的模块名只能是字符串常量，即不能动态地去设置要import的内容 import binding 是 immutable的，即不能对import出的模块进行修改 显然，CJS不具备这种特点，比如可以动态地require，也可以在不太条件下require. 代码擦除：在uglify阶段删除无用代码 tree shaking本质上是对模块的代码进行静态的分析，因此在编译阶段哪些代码是否有用到，是确定下来的，而不能通过代码实际运行时再分析。treeshaking会对没用到的代码增加注释标记，然后在uglify阶段删除。 29-3 实际运用 新建src/search/tree-shaking.js： 1234567export function a() &#123; return &#x27;this is func a&#x27;&#125;export function b() &#123; return &#x27;this is func b&#x27;&#125; 在src/search/index.js中引入这个模块： 1import &#123; a &#125; from &#x27;./tree-shaking&#x27; 将webpack.prod.js中的mode先改为’none’重新打包，可以看到dist/search.js中包含方法a和b： 再把mode改为’production’重新打包后，在dist/search.js中搜不到方法a和b了。 然后我们在src/search/index.js中使用方法a： 12345678class Search extends React.Component &#123; render() &#123; const funcA = a() return &lt;div className=&quot;search-text&quot;&gt; &#123; funcA &#125;Search Text搜索&lt;img src=&#123;logo&#125;/&gt; &lt;/div&gt; &#125;&#125; 重新打包后，在dist/search.js中可以搜到方法a，而且搜不到方法b，证明treeshaking失效了： 假如下面这种情况调方法a，重新打包后，可以看到方法a并没有被打包调用到： 12345import &#123; a &#125; from &#x27;./tree-shaking&#x27;if(false) &#123; a()&#125;class Search extends React.Component &#123;&#125; 30丨scope hoisting使用和原理分析30-1 使用scope hoisting前 构建后的代码存在大量闭包代码 编译前： 编译后： 会导致什么问题？ 大量函数闭包包裹代码，导致体积增大（模块越多越明显） 运行代码时创建的函数作用域变多，内存开销变大 为什么webpack会打包出这么多函数把代码包裹起来呢？ 模块转换分析 模块源代码： 模块初始化函数 - 指webpack对模块处理增加的包裹和对import、export处理之后的代码 webpack打包的原因是目前还存在许多浏览器不支持的特性，现阶段仍需要使用这些构建工具对它们进行转换。 其实就做了2件事情： 被webpack转换后的模块会带上一层包裹 import会被转换成__webpack_require__，export也会被转换__webpack_exports__ 进一步分析webpack的模块机制 分析： 打包出来的是一个IIFE（匿名闭包） modules是一个数组，每一项是一个模块初始化函数： 会将modules作为参数传递给函数，这个函数最核心的是通过__webpack_require进行处理： 1function(modules) &#123;&#125; __webpack_require的作用是用来加载模块，返回module.exports： 123function __webpack_require__(moduleId) &#123; return module.exports&#125; 我们从模块初始化函数可以看到： 首先它会根据moduleId去查看installedModules对象，如果这个对象中存在相应的module，就直接返回它； 123if(installedModule[moduleId]) &#123; return installedModules[moduleId].exports&#125; 如果这个module不存在，就会创建一个新的module对象，并存放到installedModules中去，之后将module.exports、module、__webpack_require__传递给找到的模块，并将这个模块是否加载标记成true。 1234567var module = installedModules[moduleId] = &#123; i: moduleId, l: false, exports: &#123;&#125;&#125;modules[moduleId].call(modules.exports, module, module.exports, __webpack_require__)module.l = true 通过WEBPACK_REQUIRE_METHOD(0)启动程序： 1__webpack_require__(0) 30-2 使用scope hoisting 原理 将所有模块的代码按照引用顺序放在一个函数作用域里，然后适当地重命名一些变量以防止变量名冲突。 比如说，前面的例子中，b模块调用a模块，我们以前的做法是可以将b模块放在前面，a模块放在后面，它们之间有模块包裹，所以并没有什么影响，如果要消除包裹代码，我们需要根据模块的引用顺序进行位置的排放，即把被引用的模块a放在b前面，那么b就能读取a的内容了。 这样做的好处是，可以减少函数声明的代码和内存开销。 在webpack中使用前的讲解 把mode设为’production’会默认开启这个插件ModuleConcatenationPlugin，就会自动使用ScopeHoisting这个特性 注意，我们写的代码必须是ES6语法，CJS不支持。这是因为CJS动态引入一个模块，webpack没办法静态地分析模块的引用顺序 将mode设为’none’，打包一下，在dist/index.js中可以看到： 12/* 0 *//***/ (function(module, __webpack_exports__, __webpack_require__) &#123;&#125; module指代这个模块的源码 因为harmony是es6的简称，所以打包后的js中的/* harmony import */ 指代es6的export语法。 12/* harmony import */ var _helloworld__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2); 下面代码表示webpack执行入口的模块，执行完后，webpack就会根据入口模块所依赖的模块不断地去分析其他的依赖，把其他的模块加载进来： 12// Load entry module and return exportsreturn __webpack_require__(__webpack_require__.s = 3); 另外还有注意，比如我们的index.js依赖了其他的模块，在import这个模块时会把这些变量传进去，同时也会传递一个__webpack_require__： 1modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); 在webpack中的具体使用 实际项目中，直接将mode改为’production’就默认开启scope hoisting，为了不压缩方便演示，我们手动引入插件看看效果。 先在webpack.prod.js的插件数组中添加： 123456const webpack = require(&#x27;webpack&#x27;)module.exports = &#123; plugins: [ new webpack.optimize.ModuleConcatenationPlugin() ]&#125; 构建后，在dist/index.js中可以看到，common模块的顺序在最前面，helloworld方法是直接内联进来的，但因为common模块被引用了两次，即使开启了scope hoisting，common方法仍然会被放在外面： 123456789101112131415161718192021222324252627282930/***/ 0:/***/ (function(module, __webpack_exports__, __webpack_require__) &#123;&quot;use strict&quot;;__webpack_require__.r(__webpack_exports__);/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, &quot;common&quot;, function() &#123; return common; &#125;);function common() &#123; return &#x27;this is common&#x27;;&#125;/***/ &#125;),/***/ 14:/***/ (function(module, __webpack_exports__, __webpack_require__) &#123;&quot;use strict&quot;;// ESM COMPAT FLAG__webpack_require__.r(__webpack_exports__);// CONCATENATED MODULE: ./src/index/helloworld.jsfunction helloworld() &#123; return &#x27;Hello webpack&#x27;;&#125;// EXTERNAL MODULE: ./common/index.jsvar common = __webpack_require__(0);// CONCATENATED MODULE: ./src/index/index.jsdocument.write(helloworld());/***/ &#125;) 我们可以将src/search/index.js中引入common删掉，重新打包，发现common和helloworld方法都被内联到首页index.js中了： 12345678910111213141516171819/***/ 12:/***/ (function(module, __webpack_exports__, __webpack_require__) &#123;&quot;use strict&quot;;// ESM COMPAT FLAG__webpack_require__.r(__webpack_exports__);// CONCATENATED MODULE: ./src/index/helloworld.jsfunction helloworld() &#123; return &#x27;Hello webpack&#x27;;&#125;// CONCATENATED MODULE: ./common/index.jsfunction common() &#123; return &#x27;this is common&#x27;;&#125;// CONCATENATED MODULE: ./src/index/index.jsdocument.write(helloworld());/***/ &#125;) 31丨代码分割和动态import31-1 代码分割的意义对于大的web应用来讲，将所有的代码都放在一个文件中显然是不够有效的，特别是当你的某些代码块是在某些特殊的时候才会被使用到。webpack有一个功能就是将你的代码库分割成chunks（语块），当代码运行到需要它们的时候再进行加载。 适用的场景 抽离相同代码到一个共享块 脚本懒加载，使得初始下载的代码更小 懒加载JS脚本的方式 CommonJS: require.ensure ES6: 动态import（目前还没有原生支持，需要babel转换），跟commonJs中的require有点像 31-3 如何使用动态import (实际运用) 安装babel插件： $ npm i @babel/plugin-syntax-dynamic-import -S 将这个babel插件添加到.babelrc的配置文件中去： 123&#123; &quot;plugins&quot;: [&quot;@babel/plugin-syntax-dynamic-import&quot;]&#125; 然后将前面讲到的htmlWebpackExternalsPlugin在webpack.prod.js中解开注释，以及html中解开引入 新建src/search/text.js： 12import React from &#x27;react&#x27;export default() =&gt; &lt;div&gt;动态 import&lt;/div&gt; 在src/search/index.js中给logo添加点击事件并懒加载这个脚本： 1234567891011121314151617181920212223242526272829303132import React from &#x27;react&#x27;import ReactDOM from &#x27;react-dom&#x27;import logo from &#x27;./images/logo.png&#x27;class Search extends React.Component &#123; constructor() &#123; super(...arguments) this.state = &#123; Text: null &#125; &#125; loadComponent() &#123; import(&#x27;./text.js&#x27;).then((Text) =&gt; &#123; this.setState(&#123; Text: Text.default &#125;) &#125;) &#125; render() &#123; const &#123; Text &#125; = this.state return &lt;div className=&quot;search-text&quot;&gt; &#123; Text ? &lt;Text /&gt; : null &#125; Search Text搜索&lt;img src=&#123;logo&#125; onClick=&#123;this.loadComponent.bind(this)&#125; /&gt; &lt;/div&gt; &#125;&#125;ReactDOM.render( &lt;Search /&gt;, document.getElementById(&#x27;root&#x27;)) 重新打包，可以看到多出一个js文件： 从dist/1.js中可以看到，通过webpackJsonp的方法发起的请求（即一开始没有这个标签，点击后插入，这就是典型的jsonp的形式），并创建creatElement一个组件： 在浏览器中操作可以得出下面的结论： 如果在search.js中使用了动态import语法，打包后，就会额外分割一个js文件，然后我们在这个页面点击logo按钮，才会异步加载请求这个分割出的js，在Network中可以看到。 32丨webpack和eslint结合32-1 行业里面优秀的eslint规范实践 Airbnb eslint-config-airbnb eslint-config-airbnb-base 腾讯 alloyteam团队 eslint-config-alloy(https://github.com/AlloyTeam/eslint-config-alloy) ivweb团队 eslint-config-ivweb(https://github.com/feflow/eslint-config-ivweb) 32-2 指定团队的eslint规范 不重复造轮子，基于eslint:recommend配置并改进 能够帮助发现代码错误的规则，全部开启 比如变量未定义就使用了，json里有重复的key 帮助保持团队的代码风格统一，而不是限制开发体验 比如function关键字后面的空格，js里的关键字前后的空格，缩进空格，单双引号等 32-3 eslint如何执行落地 和CI/CD系统集成（适合老项目接入） 和webpack集成（适合新项目开发时就使用） 使用eslint-loader，构建时检查JS规范 32-3 webpack与eslint集成的实际运用 (以eslint-config-airbnb为例) 安装相关依赖 $ npm i eslint eslint-plugin-import eslint-plugin-react eslint-plugin-react-hooks eslint-plugin-jsx-a11y -D 安装$ npm i eslint-loader -D，并将其添加到webpack.prod.js配置中： 123rules: [&#123; test: /\\.js$/, use: [&#x27;babel-loader&#x27;, &#x27;eslint-loader&#x27;]&#125;, 在根目录创建eslint的配置文件.eslintrc.js（见官网）","categories":[{"name":"webpack","slug":"webpack","permalink":"https://scarlett9354.github.io/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://scarlett9354.github.io/tags/webpack/"}]},{"title":"透视HTTP协议","slug":"透视HTTP协议","date":"2021-04-28T07:26:47.000Z","updated":"2021-05-06T09:31:20.270Z","comments":true,"path":"2021/04/28/透视HTTP协议/","link":"","permalink":"https://scarlett9354.github.io/2021/04/28/%E9%80%8F%E8%A7%86HTTP%E5%8D%8F%E8%AE%AE/","excerpt":"","text":"一 开篇词 0丨面试啊面试 二 破冰篇 1丨http的前世今生 1-1 几个概念 1-2 变更 1-3 小结 1-4 课下作业 1-5 延伸知识 2丨http是什么以及http又不是什么 2-1 基本概念 2-2 http是什么 2-3 http不是什么 (即不能干什么) 2-4 小结 2-5 思维导图 略~ 2-6 课下作业 2-7 延伸知识 3丨http世界全览 (上) 与http相关的各种概念 3-1 网络世界 3-2 浏览器 (web browser) 3-3 web服务器 3-4 cdn 3-5 爬虫 (crawler) 3-6 html webservice waf 3-7 小结 3-8 课下作业 3-9 延伸知识 4丨http世界全览 (下) 与http相关的各种协议 4-1 tcp ip 4-2 dns 4-3 uri url 4-4 https 4-5 代理 4-6 小结 4-7 课下作业 4-8 延伸知识 5丨常说的四层和七层到底是什么 五层和六层哪去了 5-1 tcp ip网络分层模型 5-2 osi网络分层模型 5-3 两个分层模型的映射关系 5-4 tcp ip协议栈的工作方式 5-5 小结 5-6 课下作业 5-7 延伸知识 6丨域名里有那些门道 6-1 域名的形式 6-2 域名的用途 6-3 域名的解析 6-4 域名的 [新玩法] 6-5 小结 6-6 课下作业 6-7 延伸知识 7丨自己动手 搭建http实验环境 7-1 软件准备 7-2 安装过程 7-3 测试验证 7-4 延伸知识 三 基础篇 8丨键入网址再按下回车 后面究竟发生了什么 8-1 抓包分析 8-2 浏览器http请求过程 8-3 使用域名访问web服务器 8-4 真实的网络世界 8-5 小结 8-6 课下作业 8-7 延伸知识 9丨http报文是什么样子的 9-1 报文结构 9-2 请求行 9-3 状态行 9-4 头部字段 9-5 常用头字段 9-6 小结 9-7 课下作业 9-8 延伸知识 10丨应该如何理解请求方法 10-1 标准请求方法 10-2 安全与幂等 10-3 小结 10-4 课下作业 11丨你能写出正确的网址吗 11-1 uri的格式 11-2 uri的基本组成 11-3 uri的查询参数 11-4 uri的完整格式 11-5 uri的编码 11-6 小结 11-7 课下作业 11-8 延伸知识 12丨响应状态码该怎么用 12-1 状态码 12-2 小结 12-3 课下作业 13丨http有哪些特点 13-1 五大基本特点 13-2 小结 13-3 课下作业 13-4 延伸知识 14丨http有哪些优点 又有哪些缺点 14-1 优点 14-2 双刃剑-既是优点也是缺点 14-3 缺点 14-4 小结 14-5 课下作业 14-6 延伸知识 四 进阶篇 15丨海纳百川 http的实体数据 15-1 数据类型与编码 15-2 数据类型使用的头字段 15-3 语言类型与编码 15-4 语言类型使用的头字段 15-5 内容协商的质量值 15-6 内容协商的结果 15-7 动手实验 15-8 小结 15-9 课下作业 15-10 延伸知识-经验之谈 16丨把大象装进冰箱 http传输大文件的方法 16-1 数据压缩 16-2 分块传输 16-3 范围请求 16-4 多段数据 16-5 小结 16-6 课下作业 16-7 延伸知识 17丨排队也要讲效率 http的连接管理 17-1 短连接 17-2 长连接 17-3 连接相关的头字段 17-4 队头阻塞 17-5 性能优化 17-6 小结 17-7 课下作业 17-8 延伸知识 18丨四通八达 http的重定向和跳转 18-1 重定向的过程 18-2 重定向状态码 18-3 重定向的应用场景 18-4 重定向的相关问题 18-5 小结 18-6 课下作业 18-7 延伸知识 19丨让我知道你是谁 http的cookie机制 19-1 什么是cookie 19-2 cookie的工作过程 19-3 cookie的属性 19-3-1 有哪些常见的cookie属性 19-3-2 浏览器中查看cookie的方式 19-4 cookie的应用 19-5 小结 19-6 课下作业 19-7 延伸知识 20丨生鲜速递 http的缓存控制 20-1 服务器的缓存控制 20-2 客户端的缓存控制 20-2 条件请求 20-3 小结 20-4 课下作业 20-5 延伸知识 一 开篇词0丨面试啊面试 用TCP实现http 你是怎么理解 HTTP 字面上的“超文本”和“传输协议”的？ 能否谈一下你对 HTTP 的认识？越多越好。 HTTP 有什么特点？有什么优点和缺点？ HTTP 下层都有哪些协议？是如何工作的？ 域名解析过程，CDN调度过程 关于请求方法还有两个面试时有可能会问到、比较重要的概念：安全与幂等 二 破冰篇1丨http的前世今生1-1 几个概念 URI：即统一资源标识符，作为互联网上资源的唯一身份； HTML：即超文本标记语言，描述超文本文档； HTTP：即超文本传输协议，用来传输超文本； 1-2 变更 HTTP/1.0相比0.9的变更点： 增加了HEAD、POST等新方法； 增加了响应状态码，标记可能的错误原因； 引入了协议版本号概念； 引入了HTTP Header（头部）的概念，让HTTP处理请求和响应更加灵活； 传输的数据不再仅限于文本。 HTTP/1.1相比1.0的主要变更点： 增加了PUT、DELETE等新的方法（这些可以用在restful应用里，表示各种对资源的操作）； 增加了缓存管理和控制； 明确了连接管理，允许持久连接； 允许响应数据分块（chunked），利于传输大文件； 强制要求Host头，让互联网主机托管成为可能。 HTTP/1.1的缺点是连接慢，无法跟上迅猛发展的互联网。 HTTP/2的制定充分考虑了现今互联网的现状：宽带、移动、不安全，在高度兼容1.1的同时在性能改善方面做了很大努力，主要的特点有： 二进制协议，不再是纯文本，如HTTP/1.1 中的 application/octet-stream 和 multipart/form-data ； 可发起多个请求，废弃了1.1里的管道； 使用专用算法压缩头部，减少数据传输量； 允许服务器主动向客户端推送数据； 增强了安全性，“事实上”要求加密通信。 HTTP/3还没正式发布。 1-3 小结 HTTP协议始于三十年前蒂姆·伯纳斯-李的一篇论文； HTTP/0.9是个简单的文本协议，只能获取文本资源； HTTP/1.0确立了大部分现在使用的技术，但它不是正是标准； HTTP/1.1是目前互联网上使用最广泛的协议，功能也非常完善； HTTP/2基于Google的SPDY协议，注重性能改善，但还未普及； HTTP/3基于Google的QUIC协议，是将来的发展方向。 1-4 课下作业 你认为推动HTTP发展的原动力是什么？ 用户需求推动技术发展 在实际商业应用、竞争和实践中反复打磨，让协议标准适应 不断发展变化的实际业务问题，而不是让日渐庞大复杂的业务去适应受限于特定时空因素 的标准。 标准的诞生和发展一方面是基于具体业务需要和技术发展，另一方面是为了统一游戏规则 你是怎么理解HTTP（超文本传输协议）的？ HTTP 的本质是 P（Protocol），即一个协议，定义了服务端与客户端数据交互的标 准。 1-5 延伸知识 http 安全知识方面的内容：比如host 头攻击、缓速攻击等。 http的优点是灵活方便，缺点是通信成本略高，每家公司选择通信协议都有自己的考虑，安全是因素之一，但真正的原因我们外人是不知道的。 那怎么看我们使用的是哪一个？ 看地址栏的uri，可以分辨http和https，具体的版本号就要用Chrome的开发者工具了。 2丨http是什么以及http又不是什么2-1 基本概念​ HTTP是超文本 传输 协议，也就是HyperText Transfer Protocol。 ​ 2-2 http是什么 首先，HTTP是一个协议。协议又是什么呢？有什么特点呢？ 协议必须要有两个或多个参与者，也就是“协”。 协议是对参与者的一种行为约定和规范，也就是“议”。 协议意味着有多个参与者为了达成某个共同的目的而站在了一起，除了要无疑义地沟通交流之外，还必须明确地规定各方的“责、权、利”，约定该做什么不该做什么，先做什么后做什么，做错了怎么办，有没有补救措施等等。 综上，HTTP是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。 第二层含义 - 传输，就是把一堆东西从A点搬到B点，或者从B点搬到A点，即“A&lt;===&gt;B”。所以： HTTP协议是一个“双向协议”。 通常我们把先发起传输动作的 A 叫做请求方，把后接到传输的 B 叫做应答方或者响应方。 数据虽然是在A和B之间传输，但并没有限制只有A和B这两个角色，允许中间有“中转”或者“接力”。 传输方式就变成了“A&lt;=&gt;X&lt;=&gt;Y&lt;=&gt;Z&lt;=&gt;B”，这些中间人也都遵从HTTP协议，只要不打扰基本的数据传输，就可以添加任意的额外功能，例如安全认证、数据压缩、编码转换等，优化整个传输过程。 综上，HTTP是一个在计算机世界里专门用来在两点之间传输数据的约定和规范。 第三层含义 - 超文本。 所谓“文本”，就表示HTTP传输的不是TCP/UDP这些底层协议里被切分的杂乱无章的二进制包（datagram），而是完整的、有意义的数据，可以被浏览器、服务器这样的上层应用程序处理。 图片、音频、视频，甚至压缩包，在HTTP眼里都算做“文本”。 所谓“超文本”，就是“超越了普通文本的文本”，它是文字、图片、音频和视频等的混合体，最关键的是含有“超链接”，能够从一个“超文本”跳跃到另一个“超文本”，形成复杂的非线性、网状的结构关系。 例如HTML，它本身只是纯文字文件，但内部用很多标签定义了对图、音、视等的链接，再经过浏览器的解释，呈现出的就是一个含有多种视听信息的页面。 综上，HTTP是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。 2-3 http不是什么 (即不能干什么) 它不存在“单独的实体”。 它不是浏览器、手机 APP 那样的应用程序，也不是 Windows、Linux 那样的操作系统，更不是 Apache、Nginx、Tomcat 那样的 Web 服务器。 但HTTP又与它们密切相关，在它们之间的通信过程中存在，而且是一种“动态的存在”，是发生在网络连接、传输超文本数据时的一个“动态过程”。 它不是互联网。 超文本资源使用 HTTP，普通 文件使用 FTP，电子邮件使用 SMTP 和 POP3 等。 它不是编程语言。 它不是HTML。 HTML 是超文本的载体，是一种标记语言，使用各种标签描述文字、图片、超链接等资 源，并且可以嵌入 CSS、JavaScript 等技术实现复杂的动态效果。单论次数，在互联网上 HTTP 传输最多的可能就是 HTML，但要是论数据量，HTML 可能要往后排了，图片、音 频、视频这些类型的资源显然更大。 它不是一个孤立的协议。 HTTP 通常跑在 TCP/IP 协议栈之上，依靠 IP 协议实现寻址和路由、TCP 协议实现可靠数据传输、DNS 协议实现域名查找、SSL/TLS 协议实现安全通信。此外，还 有一些协议依赖于 HTTP，例如 WebSocket、HTTPDNS 等。这些协议相互交织，构成了 一个协议网，而 HTTP 则处于中心地位。 2-4 小结 HTTP 是一个用在计算机世界里的协议，它确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。 HTTP 专门用来在两点之间传输数据，不能用于广播、寻址或路由。 HTTP 传输的是文字、图片、音频、视频等超文本数据。 HTTP 是构建互联网的重要基础技术，它没有实体，依赖许多其他的技术来实现，但同时许多技术也都依赖于它。 综上，我们可以把 HTTP 定义为“与 HTTP 协议相关的所有应用层技术的总和”。 2-5 思维导图 略~ 左边的部分是与HTTP有关系的各种协议，比较偏向于理论；而右边部分是与HTTP有关系的各种应用技术，偏向于实际应用。 2-6 课下作业 有一种流行的说法：“HTTP 是用于从互联网服务器传输超文本到本地浏览器的协议”，你认为这种说法对吗？对在哪里，又错在哪里？ 回答一：错误的说法，Http可以在任意两点间进行传输。只是从服务器传输到浏览器这种形式比较常见。 回答二：HTTP是在计算机世界里，用于两点之间传输超文本的协议。这两点并不限定于是服务器还是浏览器。可以是从浏览器到服务器，也可以从服务器到服务器，切记一点，两个浏览器不能通信。服务器可以当客户端，但浏览器只是客户端。 你能再说出几个“HTTP 不是什么”吗？ 2-7 延伸知识 为什么文章说HTTP通常跑在 TCP/IP协议栈之上，请问还有其它协议栈吗？ 有的，比如在UNIX上可以用Domain Socket，还有SSL/TLS。 1，浏览器只能是请求方，发送请求接收响应。 2，websocket是为了解决动态html的问题而出现的，应用场景是web，所以用到了http。 3丨http世界全览 (上) 与http相关的各种概念​ 3-1 网络世界 我们通常所说的“上网”实际上访问的只是互联网（Internet）的一个子集“万维网（World Wide Web）”，它基于HTTP协议，传输HTML等超文本资源，能力也就被限制在HTTP协议之内。 互联网上还有许多万维网之外的资源，如常用的电子邮件、BT和Magnet点对点下载、FTP文件下载、SSH安全登录、各种即时通信服务等，它们需要用各自的专有协议来访问。 不过由于 HTTP 协议非常灵活、易于扩展，而且“超文本”的表述能力很强，所以很多其他原本不属于 HTTP 的资源也可以“包装”成 HTTP 来访问，这就是我们为什么能够总看到各种“网页应用”——例如“微信网页版”“邮箱网页版”——的原因。 综合起来看，现在的互联网 90% 以上的部分都被万维网，也就是 HTTP 所覆盖，所以把互联网约等于万维网或 HTTP 应该也不算大错。 3-2 浏览器 (web browser) 常见的有Google的Chrome、Mozilla的Firefox、Apple的Safari、Microsoft的IE和Edge，还有小众的Opera以及国内的各种“换壳”的“极速”“安全”浏览器。 浏览器本质上是一个HTTP协议中的请求方，使用HTTP协议获取网络上的各种资源。 浏览器还继承了很多额外的功能：HTML排版引擎 - 用来展示页面，JavaScript引擎 - 用来实现动态化效果，开发者工具 - 用来调试网页，及各种插件和扩展。 在 HTTP 协议里，浏览器的角色被称为“User Agent”即“用户代理”，意思是作为访问者的“代理”来发起 HTTP 请求。不过在不引起混淆的情况下，我们通常都简单地称之为“客户端”。 3-3 web服务器 浏览器是HTTP里的请求方，服务器（Web Server）是协议另一端的应答方（响应方）。 Web服务器有两个层面的含义：硬件和软件。 硬件含义就是物理形式或“云”形式的机器，在大多数情况下它可能不是一台服务器，而是利用反向代理、负载均衡等技术组成的庞大集群。但从外界看来，它仍然表现为一台机器，但这个形象是“虚拟的”。 软件含义是提供Web服务的应用程序，通常会运行在硬件含义的服务器上。它利用强大的硬件能力响应海量的客户端 HTTP 请求，处理磁盘上的网页、图片等静态文件，或者把请求转发给后面的 Tomcat、Node.js 等业务应用，返回动态的信息。 常见的Web服务器： Apache - 老牌的服务器 Nginx - 后起之秀，特点是高性能、高稳定，且易于扩展。 windows上的IIS、Java的Jetty/Tomcat等。 3-4 cdn 浏览器通常不会直接连到服务器，中间会经过“重重关卡”，其中的一个重要角色就是CDN。 CDN（Content Delivery Network，内容分发网络），它应用了HTTP协议里的缓存和代理技术，代替源站响应客户端的请求。 CDN有什么好处？ 它可以缓存源站的数据，让浏览器的请求不用“千里迢迢”地到达源站服务器，直接在“半路”就可以获取响应。如果 CDN 的调度算法很优秀，更可以找到离用户近的节点，大幅度缩短响应时间。 CDN除了基本的网络加速外，还提供负载均衡、安全防护、边缘计算、跨运营商网络等功能，能够成倍地“放大”源站服务器的服务能力。 3-5 爬虫 (crawler) 它实际上是一种可以自动访问Web资源的应用程序。据估计，互联网上至少有 50% 的流量都是由爬虫产生的。 爬虫是怎么来的？ 绝大多数是由各大搜索引擎“放”出来的，抓取网页存入庞大的数据库，再建立关键字索引，这样我们才能够在搜索引擎中快速地搜索到互联网角落里的页面。 爬虫也有不好的一面，它会过度消耗网络资源，占用服务器和带宽，影响网站对真实数据的分析，甚至导致敏感信息泄漏。所以，又出现了“反爬虫”技术，通过各种手段来限制爬虫。其中一项就是“君子协定”robots.txt，约定哪些该爬，哪些不该爬。 无论是“爬虫”还是“反爬虫”，用到的基本技术都是两个，一个是 HTTP，另一个就是 HTML。 3-6 html webservice waf HTML 它是HTTP协议传输的主要内容之一，它描述了超文本页面，用各种“标签”定义文字、图片等资源和排版布局，最终由浏览器“渲染”出可视化页面。 WebService 它是一种由 W3C 定义的应用服务开发规范，使用 client-server 主从架构，通常使用 WSDL 定义服务接口，使用 HTTP 协议传输 XML 或 SOAP 消息，也就是说，它是一个基于 Web（HTTP）的服务架构技术，既可以运行在内网，也可以在适当保护后运行在外网。 因为采用了 HTTP 协议传输数据，所以在 WebService 架构里服务器和客户端可以采用不同的操作系统或编程语言开发。例如服务器端用 Linux+Java，客户端用 Windows+C#， 具有跨平台跨语言的优点。 WAF 意思是“网络应用防火墙”，与硬件“防火墙”类似，它是应用层面的“防火墙”，专门检测 HTTP 流量，是防护 Web 应用的安全技术。 WAF 通常位于 Web 服务器之前，可以阻止如 SQL 注入、跨站脚本等攻击，目前应用较多的一个开源项目是 ModSecurity，它能够完全集成进 Apache 或 Nginx。 3-7 小结 互联网上绝大部分资源都使用HTTP协议传输； 浏览器是HTTP协议里的请求方，即User Agent； 服务器是HTTP协议里的应答方，常用的有Apache和Nginx； CDN位于浏览器和服务器之间，主要起到缓存加速的作用； 爬虫是另一类User Agent，是自动访问网络资源的程序。 3-8 课下作业 你觉得 CDN 在对待浏览器和爬虫时会有差异吗？为什么？ 回答一： CDN 应当是不区分的，因为爬虫本身也是对 Web 资源的访问，且对于爬虫识别并不是 100% 准确的，因此 CDN 只会去计算实际使用了多少资源而不管其中多少来自爬虫。 回答二：应该不会有差异，因为爬虫主要就是无限模仿浏览器行为。 你怎么理解 WebService 与 Web Server 这两个非常相似的词？ 回答一：Web Service 是网络服务实体，而 Web Server 是网络服务器，后者的存在是为了承载前者。 回答二：Web Server是软件服务器，承载应用。WebService是一种服务方式。 补充回答：web server只能用http协议（因为是web），而websevice的接口就不固定了，有很多种。 3-9 延伸知识 在浏览某些网站时遇到过要求“验证你不是机器人”的页面，其实就是一种“反爬虫”手段。 RPC就是把网络通信封装成了函数调用的形式。SOAP是 WebService的消息格式。restful是一种web服务接口的设计理念。 4丨http世界全览 (下) 与http相关的各种协议​ 4-1 tcp ip TCP/IP协议实际上是一系列网络通信协议的统称，其中最核心的两个协议是TCP和IP，其他的还有UDP、ICMP、ARP等，共同构成了一个复杂但有层次的协议栈。 这个协议栈有四层，上层是“应用层”，下层是“链接层”，TCP 和 IP 则在中间：TCP 属于“传输层”，IP 属于“网际层”。 IP协议（Internet Protocol）主要目的是解决寻址和路由问题，以及如何在两点间传送数据包。IP 协议使用“IP 地址”的概念来定位互联网上的每一台计算机。 TCP协议（Transmission Control Protocol，传输控制协议），它位于 IP 协议之上，基于 IP 协议提供可靠的、字节流形式的通信，是 HTTP 协议得以实现的基础。 “可靠”是指保证数据不丢失，“字节流”是指保证数据完整，所以在 TCP 协议的两端可以如同操作文件一样访问传输的数据，就像是读写在一个密闭的管道里“流动”的字节。 互联网上的 HTTP 协议就运行在了 TCP/IP 上，HTTP 也就可以更准确地称为“HTTP over TCP/IP”。 4-2 dns 由于数字形式的IP地址对人类不便，就采用“域名系统（Domain Name System）”等价替代。 在 DNS 中，“域名”（Domain Name）又称为“主机名”（Host），为了更好地标记不同国家或组织的主机，让名字更好记，所以被设计成了一个有层次的结构。 域名用“.”分隔成多个单词，级别从左到右逐级升高，右边的被称为“顶级域名”。对于顶级域名，可能你随口就能说出几个，例如表示商业公司的“com”、表示教育机构 的“edu”，表示国家的“cn”“uk”等。 但想要使用 TCP/IP 协议来通信仍然要使用 IP 地址，所以需要把域名做一个转换，“映射”到它的真实 IP，这就是所谓的“域名解析”。 HTTP 协议中并没有明确要求必须使用 DNS，但实际上为了方便访问互联网上的 Web 服务器，通常都会使用 DNS 来定位或标记主机名，间接地把 DNS 与 HTTP 绑在了一起。 4-3 uri url URI（Uniform Resource Identifier，统一资源定位符），即我们俗称的“网址”，它实际上是 URI 的一个子集，不过因为这两者几乎是相同的，差异不大，所以通常不会做严格的区分。 举例说明 http://nginx.org/en/download.html，可以看到URI主要有三个基本部分构成： 协议名（http）：即访问该资源应当使用的协议； 主机名（nginx.org）：即互联网上主机的标记，可以是域名或IP地址； 路径（/en/download.html）：即资源在主机上的位置，使用“/”分隔多级目录。 4-4 https HTTPS是运行在SSL/TLS协议上的HTTP，全称是“HTTP over SSL/TLS”。SSL/TLS是一个负责加密通信的安全协议，建立在 TCP/IP 之上，所以也是个可靠的传输协议，可以被用作 HTTP 的下层。 SSL（Secure Socket Layer）发展到3.0时被标准化，改名为TLS（Transport Layer Security）。 SSL 使用了许多密码学先进的研究成果，综合了对称加密、非对称加密、摘要算法、数字签名、数字证书等技术，能够在不安全的环境中为通信的双方创建出一个秘密的、安全的传输通道，为 HTTP 套上一副坚固的盔甲。 看一下浏览器地址栏，如果有一个小锁头标志，那就表明网站启用了安全的 HTTPS 协议，而 URI 里的协议名，也从“http”变成了“https”。 4-5 代理 代理（Proxy）是HTTP协议中请求方和应答方中间的一个环节，作为“中转站”，既可以转发客户端的请求，也可以转发服务器的应答。 代理有很多种类，常见的有： 匿名代理：完全“隐匿”了被代理的机器，外界看到的只是代理服务器； 透明代理：在传输过程是“透明开放”的，外界既知道代理，也知道客户端； 正向代理：靠近客户端，代表客户端向服务器发送请求； 反向代理：靠近服务器端，代表服务器响应客户端的请求。 CDN实际上就是一种代理，它代替源站服务器响应客户端的请求，通常扮演着透明代理和反向代理的角色。 由于代理在传输过程中插入了一个“中间层”，所以在这个环节可以做很多有意思的事情，比如： 负载均衡：把访问请求均匀分散到多台机器，实现访问集群化； 内容缓存：暂存上下行的数据，减轻后端的压力； 安全防护：隐匿 IP, 使用 WAF 等工具抵御网络攻击，保护被代理的机器； 数据处理：提供压缩、加密等额外的功能。 4-6 小结 TCP/IP 是网络世界常用的协议，HTTP 通常运行在 TCP/IP 提供的可靠传输基础上； DNS 域名是 IP 地址的等价替代，需要用域名解析实现到 IP 地址的映射； URI 是用来标记互联网上资源的一个名字，由“协议名 + 主机名 + 路径”构成，俗称 URL； HTTPS 相当于“HTTP+SSL/TLS+TCP/IP”，为 HTTP 套了一个安全的外壳； 代理是 HTTP 传输过程中的“中转站”，可以实现缓存加速、负载均衡等功能。 4-7 课下作业 DNS 与 URI 有什么关系？ 回答一：DNS 是将域名解析出真实IP地址的系统，URI 是统一资源标识符，标定了客户端需要访问的资源所处的位置，如果URI中的主机名使用域名，则需要使用DNS来将域名解析为IP。 回答二：URI为了方便拥有记忆可以采用域名代替IP。当用户使用域名访问时，就需要DNS技术找到对应的IP地址。然后找到对应的服务器或者代理。DNS域名解析发生在客户端。服务端接受到的还是用户输入的域名，或者IP。服务器(代理)可开启限制，只采用域名访问。 在讲代理时我特意没有举例说明，你能够用引入一个“小强”的角色，通过打电话来比 喻一下吗？ 4-8 延伸知识 如果使用UNIX/Linux操作系统，HTTP可以运行在本机的UNIX Domain Socket上，它是一种进程间通信机制，但也满足HTTP对下层的“可靠传输”要求，所以就成了“HTTP over UNIX Domain Socket”。 Http协议不是依赖tcp/ip的拆包和封包吗？Unix domain socket可以做到吗？ 当然可以，如果在Linux上跑Nginx，就可以指定用Unix domain socket。 关键要理解协议栈，http不强制要求下层必须是tcp。 域名可以对应多个IP，IP也可以通过端口映射对应多个域名。这种做法很普遍，比如以前的z.cn和www.amzon.cn都指向一个站点。 另外，ip对应多个域名，不用端口映射。 数据是通过什么方式从七层传到一层的呢，是有相关的系统接口来发这些数据吗？ 网卡又是怎么知道数据是要往外发的呢？ 调用Socket API（send），然后层层打包，由操作系统发。到ip层就有ip地址知道发去哪里了。 网络是7层模型：应用层 表示层 会话层 传输层 网络层 数据链路层 物理层。 URI会有默认端口号，比如HTTP默认是80，用TCP连接必须要同时指定IP地址和端口。 服务器进程在指定端口上监听，然后TCP就可以建立连接。 5丨常说的四层和七层到底是什么 五层和六层哪去了5-1 tcp ip网络分层模型​ ​ TCP/IP协议栈共有四层： 第一层叫“链接层（link layer）” 负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标记网络上的设备，所以有时候也叫 MAC 层。 第二层叫“网际层”或者“网络互连层”(internet layer)，IP协议就处在这一层。 因为 IP 协议定义了“IP 地址”的概念，所以就可以在“链接层”的基础上，用 IP 地址取代 MAC 地址，把许许多多的局域网、广域网连接成一个虚拟的巨大网络，在这个网络里找设备时只要把 IP 地址再“翻译”成 MAC 地址就可以了。 第三层叫“传输层”(transport layer)，这个层次协议的职责是保证数据在 IP 地址标记的两点之间“可靠”地传输，是 TCP 协议工作的层次，另外还有它的一个“小伙伴”UDP。 两个协议的区别： TCP 是一个有状态的协议，需要先与对方建立连接然后才能发送数据，而且保证数据不丢失不重复。而 UDP 则比较简单，它无状态，不用事先建立连接就可以任意发送数据，但不保证数据一定会发到对方。 数据形式的区别，TCP 的数据是连续的“字节流”，有先后顺序，而 UDP 则是分散的小数据包，是顺序发，乱序收。 第四层叫“应用层”(application layer)，这层有各种面向具体应用的协议，例如 Telnet、SSH、FTP、 SMTP 等等，当然还有 HTTP。 MAC 层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。 5-2 osi网络分层模型 OSI(Open System Interconnection Reference Model，开放式系统互联通信参考模型)，共分七层： 1. 第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等； 2. 第二层：数据链路层，它基本相当于TCP/IP的链接层； 3. 第三层：网络层，相当于TCP/IP里的网际层； 4. 第四层：传输层，相当于TCP/IP里的传输层； 5. 第五层：会话层，维护网络中的连接状态，即保持会话和同步； 6. 第六层：表示层，把数据转换为合适、可理解的语法和语义； 7. 第七层：应用层，面向具体的应用传输数据。 OSI模型的优点： TCP/IP 是一个纯软件的栈，没有网络应有的最根基的电缆、网卡等物理设备的位置。而 OSI 则补足了这个缺失，在理论层面上描述网络更加完整。 OSI 为每一层标记了明确了编号，最底层是一层，最上层是七层，而 TCP/IP 的层次从来只有名字而没有编号。显然，在交流的时候说“七层”要 比“应用层”更简单快捷，特别是英文，对比一下“Layer seven”与“application layer”。 综上，在OSI模型之后，“四层”“七层”这样的说法就逐渐流行开了。 5-3 两个分层模型的映射关系 对应关系如下： 1. 第一层：物理层，TCP/IP里无对应； 2. 第二层：数据链路层，对应TCP/IP的链接层； 3. 第三层：网络层，对应TCP/IP的网际层； 4. 第四层：传输层，对应TCP/IP的传输层； 5. 第五、六、七层：统一对应到TCP/IP的应用层。 > OSI的分层模型在四层以上分得太细，而TCP/IP实际应用时的会话管理、编码转换、压缩等和具体应用经常联系得很紧密，很难分开。 所谓“四层负载均衡”就是指工作在传输层上，基于TCP/IP协议的特性，例如IP地址、端口号等实现对后端服务器的负载均衡。 所谓“七层负载均衡”就是指工作中应用层上，看到的是HTTP协议，解析HTTP报文里的URI、主机名、资源类型等数据，再用适当的策略转发给后端服务器。 5-4 tcp ip协议栈的工作方式​ 以发快递过程举例…说明HTTP协议的传输过程就是这样通过协议栈逐层向下，每一层都添加本层的专有数据，层层打包，然后通过下层发送出去。 接收数据则是相反的操作，从下往上穿过协议栈，逐层拆包，每层去掉本层的专有头，上层就会拿到自己的数据。 但下层的传输过程对于上层是完全“透明”的，上层也不需要关心下层的具体实现细节，所以就 HTTP 层次来看，它不管下层是不是 TCP/IP 协议，看到的只是一个可靠的传输链路，只要把数据加上自己的头，对方就能原样收到。 5-5 小结 TCP/IP 分为四层，核心是二层的 IP 和三层的 TCP，HTTP 在第四层； OSI 分为七层，基本对应 TCP/IP，TCP 在第四层，HTTP 在第七层； OSI 可以映射到 TCP/IP，但这期间一、五、六层消失了； 日常交流的时候我们通常使用 OSI 模型，用四层、七层等术语； HTTP 利用 TCP/IP 协议栈逐层打包再拆包，实现了数据传输，但下面的细节并不可见。 有一个辨别四层和七层比较好的小窍门，“两个凡是”：凡是由操作系统负责处理的就是四层或四层以下，否则，凡是需要由应用程序（也就是你自己写代码）负责处理的就是七层。当然，“两个凡是”也不是绝对的，比如dpdk就把tcp协议栈都拿到了操作系统外实现，但大多数情况下传输层以下都由操作系统负责。 5-6 课下作业 你能用自己的话解释一下“二层转发”“三层路由”吗？ 回答一： ​ 二层转发，工作在二层的设备（i.e交换机）只认识MAC地址，所以建立MAC地址和端口的映射关系，来决定往哪个端口转发。 ​ 三层路由，工作在三层的设备（i.e路由器）利用ip地址和port，根据路由表选择最佳路径来转发包。 回答二： 二层转发：二层应该指数据链路层，工作在二层的设备，通过查找到目标MAC地址，进行数据转发 三层路由：三层应该指网络层，工作在三层的设备，通过解析数据包头信息，找到目标IP地址，转发数据 你认为上一讲中的 DNS 协议位于哪一层呢？ 回答一： dns域名解析是需要请求dns服务器的，而服务器本质是一个软件 (应用)，不是操作系统处理，由”两个凡是”定理推出，dns为应用层协议。 你认为 CDN 工作在那一层呢？ 回答一： DNS和CDN都在应用层 5-7 延伸知识 MAC地址(Media Access Control Address)，也称为局域网地址，可以唯一地标识一个网卡，也就同时标识了此网卡所属的设备。 在TCP/IP协议栈之外，还是有一些协议位于OSI“五层”和“六层”的，例如UNIX域套接字就可以认为是在“五层”。 6丨域名里有那些门道6-1 域名的形式​ 域名是一个有层次的结构，是一串用“.”分隔的多个单词，最右边的被称为“顶级域名”，然后是“二级域名”，层级关系向左依次降低。左边的是主机名，通常用来表明主机的用途，比如“www”表示提供万维网服务、“mail”表示提供邮件服务等。 6-2 域名的用途 域名能够代替IP地址 在 Apache、Nginx 这样的 Web 服务器里，域名可以用来标识虚拟主机，决定由哪个虚拟主机来对外提供服务。比如在 Nginx 里就会使用“server_name”指令： 12345server &#123; listen 80; # 监听 80 端口 server_name time.geekbang.org; # 主机名是 time.geekbang.org ... &#125; 域名本质上还是个名字空间系统，使用多级域名就可以划分出不同的国家、地区、组织、公司、部门，每个域名都是独一无二的，可以作为一种身份的标识。 而XML 里使用 URI 作为名字空间，也是间接使用了域名。 6-3 域名的解析 就像 IP 地址必须转换成 MAC 地址才能访问主机一样，域名也必须要转换成 IP 地址，这个过程就是“域名解析”。 DNS 的核心系统是一个三层的树状、分布式服务，基本对应域名的结构： 1. 根域名服务器（Root DNS Server）：管理顶级域名服务器，返回“com”“net”“cn”等顶级域名服务器的 IP 地址； 2. 顶级域名服务器（Top-level DNS Server）：管理各自域名下的权威域名服务器，比如 com 顶级域名服务器可以返回 apple.com 域名服务器的 IP 地址； 3. 权威域名服务器（Authoritative DNS Server）：管理自己域名下主机的 IP 地址，比如 apple.com 权威域名服务器可以返回 www.apple.com 的 IP 地址。 > 在这里根域名服务器是关键，它必须是众所周知的，否则下面的各级服务器就无从谈起了。目前全世界共有 13 组根域名服务器，又有数百台的镜像，保证一定能够被访问到。 > 有了这个系统以后，任何一个域名都可以在这个树形结构里从顶至下进行查询，就好像是把域名从右到左顺序走了一遍，终究获得了域名对应的 IP 地址。 在核心 DNS 系统之外，还有两种手段用来减轻域名解析的压力，并且能够更快地获取结果，基本思路就是“缓存”。 首先，许多大公司、网络运行商都会建立自己的 DNS 服务器，作为用户 DNS 查询的代理，代替用户访问核心 DNS 系统。这些“野生”服务器被称为“非权威域名服务器”，可以缓存之前的查询结果，如果已经有了记录，就无需再向根服务器发起查询，直接返回对应的 IP 地址。 这些 DNS 服务器的数量要比核心系统的服务器多很多，而且大多部署在离用户很近的地方。比较知名的 DNS 有 Google 的“8.8.8.8”，Microsoft 的“4.2.2.1”，还有 CloudFlare 的“1.1.1.1”等等。 其次，操作系统里也会对 DNS 解析结果做缓存，如果你之前访问过“www.apple.com”，那么下一次在浏览器里再输入这个网址的时候就不会再跑到 DNS 那里去问了，直接在操作系统里就可以拿到 IP 地址。 另外，操作系统里还有一个特殊的“主机映射”文件，通常是一个可编辑的文本，在 Linux 里是“/etc/hosts”，在 Windows 里 是“C:\\WINDOWS\\system32\\drivers\\etc\\hosts”，如果操作系统在缓存里找不到 DNS 记录，就会找这个文件。 &gt; 在 Nginx 里有这么一条配置指令“resolver”，它就是用来配置 DNS 服务器的，如果没有它，那么 Nginx 就无法查询域名对应的 IP，也就无法反向代理到外部的网站。 1resolver 8.8.8.8 valid=30s; # 指定 Google 的 DNS，缓存 30 秒 6-4 域名的 [新玩法] 第一种，也是最简单的，“重定向”。 因为域名代替了 IP 地址，所以可以让对外服务的域名不变，而主机的 IP 地址任意变动。当主机有情况需要下线、迁移时，可以更改 DNS 记录，让域名指向其他的机器。 第二种，因为域名是一个名字空间，所以可以使用 bind9 等开源软件搭建一个在内部使用的 DNS，作为名字服务器。这样我们开发的各种内部服务就都用域名来标记，比如数据库服务都用域名“mysql.inner.app”，商品服务都用“goods.inner.app”，发起网络通信时也就不必再使用写死的 IP 地址了，可以直接用域名，而且这种方式也兼具了第一种“玩法”的优势。 第三种“玩法”包含了前两种，也就是基于域名实现的负载均衡。这种“玩法”也有两种方式，两种方式可以混用。 因为域名解析可以返回多个 IP 地址，所以一个域名可以对应多台主机，客户端收到多个 IP 地址后，就可以自己使用轮询算法依次向服务器发起请求，实现负载均衡。 域名解析可以配置内部的策略，返回离客户端近的主机，或者返回当前服务质量好的主机，这样在 DNS 端把请求分发到不同的服务器，实现负载均衡。 当然也有一些恶意的DNS，例如： “域名屏蔽”，对域名直接不解析，返回错误，让你无法拿到 IP 地址，也就无法访问网站； “域名劫持”，也叫“域名污染”，你要访问 A 网站，但 DNS 给了你 B 网站。 6-5 小结 域名使用字符串来代替 IP 地址，方便用户记忆，本质上是一个名字空间系统； DNS 就像是我们现实世界里的电话本、查号台，统管着互联网世界里的所有网站，是一 个“超级大管家”； DNS 是一个树状的分布式查询系统，但为了提高查询效率，外围有多级的缓存； 使用 DNS 可以实现基于域名的负载均衡，既可以在内网，也可以在外网。 6-6 课下作业 在浏览器地址栏里随便输入一个不存在的域名，比如就叫“www. 不存在.com”，试着解释一下它的 DNS 解析过程。 老师的答案： 浏览器缓存-&gt;操作系统缓存-&gt;hosts-&gt;dns 如果因为某些原因，DNS 失效或者出错了，会出现什么后果？ 回答一： 如果无本地缓存或缓存有问题那么会无法解析出 IP 地址导致无法访问相应网站 6-7 延伸知识 为何全世界只有 13 组根域名服务器呢？ 简单来说是因为dns协议还有udp协议里包大小的限制，只有512字 节，再除以dns记录长度，多15组，再去掉buffer。 终极dns的解析是由谁实现的或者谁规定的？ 域名由专门的域名注册机构管理，终极的是ICANN。 IP地址的分配也由ICANN管理，当然有浪费，美国是互联网的发明国，所以占用ip地址多。 ip地址查找由专门的协议，比如arp。 根和顶级dns由互联网组织ICANN管理，不属于任何公司。根dns只管理顶级dns。 之前碰到过这样一个问题：域名解析返回两个IP地址，其中一个IP无法正常访问。Safari可以自动切换到正常的IP地址继续访问 Chrome会尝试TCP连接不正常的IP，大约1分多钟之后会连接另一个IP 终导致Chrome页面访问速度缓慢。想问下这种问题是属于浏览器问题，还是DNS的问题？ 这个应该是浏览器的重连策略问题，dsn解析结果已经出来了，就已经跟dns无关了。 dns解析出ip后访问失败就不会再解析了。 重试几次，DNS集群的域名是最终一致。 当域名所对应的ip发生变化的时候，因为本地或者”野生”域名服务器上的 ip是怎么发生变化的呢？因为在域名所对应的ip发生变化的时候应该是通知的权威域名服务器吧。 域名解析有个ttl有效期，到期就会去上一级dns重新获取，当然也可以主动刷新。 7丨自己动手 搭建http实验环境7-1 软件准备 Wireshark是著名的网络抓包工具，能够截获在 TCP/IP 协议栈中传输的所有流量，并按协议类型、地址、端口等任意过滤。下载 Chrome对 HTTP/1.1、HTTPS、HTTP/2、QUIC 等的协议都支持得非常好，用 F12 打开“开发者工具”还可以非常详细地观测 HTTP 传输全过程的各种数据。 或Firefox Telnet是一个经典的虚拟终端，基于 TCP 协议远程登录主机，我们可以使用它来模拟浏览器的行为，连接服务器后手动发送 HTTP 请求，把浏览器的干扰也彻底排除，能够从最原始的层面去研究 HTTP 协议。 安装：“控制面板”-&gt;”程序”-&gt;”启动或关闭windows功能”-&gt;勾选”Telnet client”-&gt;”确定”等待安装 OpenResty是基于 Nginx 的一个“强化包”，里面除了 Nginx 还有一大堆有用的功能模块，不仅支持 HTTP/HTTPS，还特别集成了脚本语言 Lua 简化 Nginx 二次开发，方便快速地搭建动态网关，更能够当成应用容器来编写业务逻辑。下载 特别注意：必须把OpenResty的压缩包解压到项目的根目录里，并改名为“openresty”。 7-2 安装过程 下载项目 为了能够让浏览器能够使用 DNS 域名访问我们的实验环境，还要改一下本机的 hosts 文件（管理员权限修改），位置在“C:\\WINDOWS\\system32\\drivers\\etc”，添加三行本机 IP 地址到测试域名的映射，也可以参考 GitHub 项目里的 hosts 文件，这就相当于在一台物理实机上“托管”了三个虚拟主机。 123127.0.0.1 www.chrono.com 127.0.0.1 www.metroid.net 127.0.0.1 origin.io 7-3 测试验证 首先启动Web服务器，即OpenResty。 在 http_study 的“www”目录下有四个批处理文件，分别是： start：启动 OpenResty 服务器； stop：停止 OpenResty 服务器； reload：重启 OpenResty 服务器； list：列出已经启动的 OpenResty 服务器进程。 双击“start”就会启动OpenResty服务器在后台运行，运行后双击“list”可以查看是否正常启动。 然后运行Wireshark开始抓包。 因为我们的实验环境运行在本机的 127.0.0.1 上，也就是 loopback“环回”地址。所以， 在 Wireshark 里要选择“Npcap loopback Adapter”，过滤器选择“HTTP TCP port(80)”，即只抓取 HTTP 相关的数据包。双击开始界面里的“Npcap loopback Adapter”即可开始抓取本机上的网络数据。 然后打开Chrome，在地址栏输入“http://localhost/”，访问刚才启动的 OpenResty 服务器，就会看到一个简单的欢迎界面： 这时再回头去看 Wireshark，应该会显示已经抓到了一些数据，就可以用鼠标点击工具栏 里的“停止捕获”按钮告诉 Wireshark“到此为止”，不再继续抓包。 切记：实验结束后运行批处理“stop”停止 OpenResty 服务器。 7-4 延伸知识 除了经典的Wireshark，另外有一个专门抓HTTP包的工具Fiddler。 有时stop批处理无法正确停止OpenResty，可以手动在任务管理器查找nginx.exe关闭。 三 基础篇8丨键入网址再按下回车 后面究竟发生了什么8-1 抓包分析​ 8-2 浏览器http请求过程 浏览器从地址栏的输入中获得服务器的 IP 地址和端口号； 浏览器用 TCP 的三次握手与服务器建立连接； 浏览器向服务器发送拼好的报文； 服务器收到报文后处理请求，同样拼好报文再发给浏览器； 浏览器解析报文，渲染输出页面。 8-3 使用域名访问web服务器​ 解析过程仍然是：浏览器本地缓存-&gt;操作系统的缓存-&gt;本机域名解析文件hosts(查看里面是否有IP地址和域名的映射关系，即本地DNS解析)-&gt;根DNS-&gt;顶级DNS-&gt;权威DNS 8-4 真实的网络世界​ 假设要访问Apple网站，除了用DNS协议进行域名解析外，CDN会在DNS的解析过程中“插上一脚”，DNS 解析可能会给出 CDN 服务器的 IP 地址，这样你拿到的就会是 CDN 服务器而不是目标网站的实际地址。 因为 CDN 会缓存网站的大部分资源，比如图片、CSS 样式表，所以有的 HTTP 请求就不需要再发到 Apple，CDN 就可以直接响应你的请求，把数据发给你。 由 PHP、Java 等后台服务动态生成的页面属于“动态资源”，CDN 无法缓存，只能从目标网站获取。于是你发出的 HTTP 请求就要开始在互联网上的“漫长跋涉”，经过无数的路由器、网关、代理，最后到达目的地。 目标网站的服务器对外表现的是一个 IP 地址，但为了能够扛住高并发，在内部也是一套复杂的架构。通常在入口是负载均衡设备，例如IP层的 LVS 或者七层的 Nginx，在后面是许多的服务器，构成一个更强更稳定的集群。 负载均衡设备会先访问系统里的缓存服务器，通常有 memory 级缓存 Redis 和 disk 级缓存Varnish，它们的作用与 CDN 类似，不过是工作在内部网络里，把最频繁访问的数据缓存几秒钟或几分钟，减轻后端应用服务器的压力。 如果缓存服务器里也没有，那么负载均衡设备就要把请求转发给应用服务器了。这里就是各种开发框架大显神通的地方了，例如 Java 的 Tomcat/Netty/Jetty，Python 的 Django， 还有 PHP、Node.js、Golang 等等。它们又会再访问后面的 MySQL、PostgreSQL、 MongoDB 等数据库服务，实现用户登录、商品查询、购物下单、扣款支付等业务操作，然后把执行的结果返回给负载均衡设备，同时也可能给缓存服务器里也放一份。 应用服务器的输出到了负载均衡设备这里，请求的处理就算是完成了，就要按照原路再走回去，还是要经过许多的路由器、网关、代理。如果这个资源允许缓存，那么经过 CDN 的时候它也会做缓存，这样下次同样的请求就不会到达源站了。 最后网站的响应数据回到了你的设备，它可能是 HTML、JSON、图片或者其他格式的数据，需要由浏览器解析处理才能显示出来，如果数据里面还有超链接，指向别的资源，那么就又要重走一遍整个流程，直到所有的资源都下载完。 8-5 小结 HTTP 协议基于底层的 TCP/IP 协议，所以必须要用 IP 地址建立连接； 如果不知道 IP 地址，就要用 DNS 协议去解析得到 IP 地址，否则就会连接失败； 建立 TCP 连接后会顺序收发数据，请求方和应答方都必须依据 HTTP 规范构建和解析报文； 为了减少响应时间，整个过程中的每一个环节都会有缓存，能够实现“短路”操作； 虽然现实中的 HTTP 传输过程非常复杂，但理论上仍然可以简化成实验里的“两点”模型。 8-6 课下作业 你能试着解释一下在浏览器里点击页面链接后发生了哪些事情吗？ 回答一： 浏览器判断是不是ip地址，不是就进行域名解析，依次通过浏览器缓存，系统缓存，host 文件，还是没找到的请求DNS服务器获取IP解析(解析失败的浏览器尝试换别的DNS服务器，最终失败的进入错误页面)，有可能获取到CDN服务器IP地址，访问CDN时先看是否缓存了，缓存了响应用户，无法缓存、缓存失效或者无缓存，回源到服务器。经过防火墙外网网管路由到nginx接入层。ng缓存中存在的直接放回，不存在的负载到web服务器。 回答二： 浏览器判断这个链接是要在当前页面打开还是新开标签页，然后拿到ip地址和端口号，建立tcp/ip链接，发送请求报文，接收服务器返回并渲染。 这一节课里讲的都是正常的请求处理流程，如果是一个不存在的域名，那么浏览器的工作流程会是怎么样的呢？ 8-7 延伸知识 因为Chrome浏览器会缓存之前访问过的网站，所以当再次访问“127.0.0.1”的时候它可能会直接从本地缓存而不是服务器获取数据，这样就无法用Wireshark捕获网络流量，解决办法是在Chrome的开发者工具或者设置里清除相关的缓存。 浏览器接受到服务器返回的html 后 html 用到的css js 图片或者视频链接是什么时候再次发送请求到服务器的呢？是一边接受一边加载这些资源还是完全接收后再根据页面中出现 的顺序有序加载？ 收到html后浏览器会解析，发现这些链接后就再发请求。具体的加载次序是浏览器自己决定的，排版引擎比较复杂，通常都是边接收边加载。 输入一个地址按下回车，浏览器把页面请求发送出去，服务器响应后返回 html，浏览器在接受到html后就会立即发生四次挥手吗？还是说会延迟一会，遇到link、 img等这些带外链的标签后继续去发送请求(省去dns解析和ip寻址？)，最终确定html中没 有外链请求了才会断开链接呢？ 现在的http都是长连接，不会立即断开连接，尽量复用，因为握手和挥手的成本太高 了。 9丨http报文是什么样子的9-1 报文结构 HTTP协议的核心部分就是它传输的报文内容。 以TCP报文为例：它在实际要传输的数据之前附加了一个20字节的头部数据，存储TCP协议必须的额外信息，例如发送方的端口号、接收方的端口号、包序号、标志位等。 有了这个附加的 TCP 头，数据包才能够正确传输，到了目的地后把头部去掉，就可以拿到真正的数据。 > HTTP协议是一个“**纯文本**”的协议，在实际传输的数据前头数据都是ASCII码的文本，容易阅读，不需借助程序解析。 HTTP协议的请求报文和响应报文的结构基本相同，由三大部分组成： 起始行（start line）：描述请求或响应的基本信息； 头部字段集合（header）：使用 key-value 形式更详细 地说明报文； 消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。 起始行和头部字段又合称为“请求头”或“响应头”，消息正文又称为“实体”，但与“header”对应，很多时候就直接成为“body”。HTTP协议规定报文必须有header，但可以没有body，而在header之后必须要有一个“空行”，也就是“CRLF”，十六进制的“0D0A”。所以，一个完整的HTTP报文就像下图： 我们之前用Wireshark抓的包如下： > 在这个浏览器发出的请求报文里，第一行“GET / HTTP/1.1”就是请求行，而后面 的“Host”“Connection”等等都属于 header，报文的 最后是一个空白行结束，没有 body。 > 注意：请求头不允许过大，可能会占用大量的服务器资源，影响运行效率。 9-2 请求行 请求报文里的起始行也就是请求行（request line），它简要描述了客户端想要如何操作服务器端的资源。 请求行由三部分构成： 请求方法：是一个动词，如GET/POST，表示对资源的操作； 请求目标：通常是一个URI，标记了请求方法要操作的资源； 版本号：表示报文使用的HTTP协议版本。 这三个部分通常使用空给（space）来分隔，最后要用CRLF换行表示结束。 以Wireshark抓包的数据来举例：GET / HTTP/1.1，在这个请求行里，“GET”是请求方法，“/”是请求目标，“HTTP/1.1”是版本号，把这三部分连起来，意思就 是“服务器你好，我想获取网站根目录下的默认文件，我用 的协议版本号是 1.1，请不要用 1.0 或者 2.0 回复我。” 9-3 状态行 响应报文里的起始行叫做状态行(status line)，意思是服务器响应的状态。 状态行也由三部分构成： 版本号：表示报文使用的 HTTP 协议版本； 状态码：一个三位数，用代码的形式表示处理的结果，比 如 200 是成功，500 是服务器错误； 原因：作为数字状态码补充，是更详细的解释文字，帮助 人理解原因。 以Wireshark抓包里的响应报文举例：HTTP/1.1 200 OK，意思就是：“浏览器你好，我已经处理完了你的请求，这个 报文使用的协议版本号是 1.1，状态码是 200，一切 OK。”HTTP/1.1 404 Not Found翻译：“抱歉啊浏览器，刚才你的请求收到了， 但我没找到你要的资源，错误代码是 404，接下来的事情你就看着办吧。” 9-4 头部字段 请求行或状态行再加上头部字段集合就构成了 HTTP 报文里 完整的请求头或响应头： 头部字段是key-value的形式，key和value之间用“:”分隔，最后用CRLF换行表示字段结束。 HTTP 头字段非常灵活，不仅可以使用标准里的 Host、 Connection 等已有头，也可以任意添加自定义头，这就给 HTTP 协议带来了无限的扩展可能。 不过使用头字段需要注意以下几点： 字段名不区分大小写，例如“Host”也可以写 成“host”，但首字母大写的可读性更好； 字段名里不允许出现空格，可以使用连字符“-”，但不 能使用下划线“_”。例如，“test-name”是合法的字 段名，而“test name”“test_name”是不正确的字段名； 字段名后面必须紧接着“:”，不能有空格，而“:”后的字段值前可以有多个空格； 字段的顺序是没有意义的，可以任意排列不影响语义； 字段原则上不能重复，除非这个字段本身的语义允许，例如 Set-Cookie。 9-5 常用头字段​ 分四大类： 通用字段：在请求头和响应头里都可以出现； Date字段，通常出现在响应头里，表示 HTTP 报文创建的时间，客户端可以使用这个时间再搭配其 他字段决定缓存策略。 请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件； Host字段，只能出现在请求头里，它同时也是唯一一个HTTP/1.1规范里要求必须出现的字段，也就是说，如果请求头里没有 Host，那这就是一个错误的报文。Host 字段告诉服务器这个请求应该由哪个主机来处理，当 一台计算机上托管了多个虚拟主机的时候，服务器端就需要 用 Host 字段来选择，有点像是一个简单的“路由重定向”。例如我们的试验环境，在 127.0.0.1 上有三个虚拟主机：“www.chrono.com”“www.metroid.net”和“ori gin.io”。那么当使用域名的方式访问时，就必须要用 Host 字段来区分这三个 IP 相同但域名不同的网站，否则服务器 就会找不到合适的虚拟主机，无法处理。 User-Agent字段，只出现在请求头里。它使用一个 字符串来描述发起 HTTP 请求的客户端，服务器可以依据它来返回最合适此浏览器显示的页面。 响应字段：仅能出现在响应头里，补充说明响应报文的信息； Server字段只能出现在响应头里，它告诉客户 端当前正在提供 Web 服务的软件名称和版本号，例如在我 们的实验环境里它就是“Server: openresty/1.15.8.1”， 即使用的是 OpenResty 1.15.8.1。 Server 字段也不是必须要出现的，因为这会把服务器的一部分信息暴露给外界，如果这个版本恰好存在bug，那么黑 客就有可能利用 bug 攻陷服务器。所以，有的网站响应头里要么没有这个字段，要么就给出一个完全无关的描述信息。 比如 GitHub，它的 Server 字段里就看不出是使用了 Apache 还是 Nginx，只是显示“GitHub.com”。 实体字段：它实际上属于通用字段，但专门描述 body 的额外信息。 Content-Length字段，表示报文里 body 的长度，也就是请求头或响应头空行后面数据的长 度。服务器看到这个字段，就知道了后续有多少数据，可以 直接接收。如果没有这个字段，那么 body 就是不定长的， 需要使用 chunked 方式分段传输。 对 HTTP 报文的解析和处理实际上主要就是对头字段的处理，理解了头字段也就理解了 HTTP 报文。 9-6 小结 HTTP 报文结构就像是“大头儿子”，由“起始行 + 头 部 + 空行 + 实体”组成，简单地说就是“header+body”； HTTP 报文可以没有 body，但必须要有 header，而且 header 后也必须要有空行，形象地说就是“大头”必须 要带着“脖子”； 请求头由“请求行 + 头部字段”构成，响应头由“状态行 + 头部字段”构成； 请求行有三部分：请求方法，请求目标和版本号； 状态行也有三部分：版本号，状态码和原因字符串； 头部字段是 key-value 的形式，用“:”分隔，不区分大小写，顺序任意，除了规定的标准头，也可以任意添加自定义字段，实现功能扩展； HTTP/1.1 里唯一要求必须提供的头字段是 Host，它必 须出现在请求头里，标记虚拟主机名。 9-7 课下作业 如果拼 HTTP 报文的时候，在头字段后多加了一个 CRLF，导致出现了一个空行，会发生什么？ 回答一： 在header 下面第一个空行以后都会被当作body体处理 讲头字段时说“:”后的空格可以有多个，那为什么绝大多数情况下都只使用一个空格呢？ 老师回答： 按照rfc标准，空格可以是零个或多个，但一个空 格已经成了约定俗成的习惯。见rfc7230 3.2.3。 9-8 延伸知识 在Nginx里，默认的请求头大小不能超过8K，但可以用指令“large_client_header_buffers”修改。 在HTTP报文里用来分隔请求方法、URI等部分的不一定必须是空给，制表符（tab）也是允许的。 与Server类似的一个响应头字段是“X-Powered-By”，它是非标准字段，表示服务器使用的编程语言，例如“X-Powered-By: PHP/7.0.22”。 Host 攻击，简单来说，就是在host头里面加入精心设计的代码，诱骗服务器执行。 为什么请求头太大会占用服务器资源呢？ 因为服务器必须分配内存存储请求头，然后才能 处理，如果头很大，比如说16k，那么几万个请求就会占用 非常多的内存。 Nginx里限制头不超过4k，就是为了节约内存资源。 host字段是给Web服务器（Apache，Nginx）用 的。 解析出ip后，请求到达Nginx，因为上面运行了很多的虚拟 主机，比如a.com/b.com/c.com，那么应该进那个呢？ 这个时候就要用到host字段了。如果host=b.com，那么 Nginx就会使用b.com的配置提供服务。 你最后的问题其实是反了，浏览器解析域名得到ip地址，它 不知道域名对应的是不是虚拟主机，也可能是真实主机。 http请求头是什么数据类型呢？ 是个纯文本的字符串，你看wireshark抓包，很明显。 头结束用的是crlf，就是回车换行。 10丨应该如何理解请求方法10-1 标准请求方法 请求方法的实际含义就是客户端发出了一个“动作指令”，要求服务器端对URI定位的资源执行这个动作。 HTTP/1.1规定了八种方法，单词都必须是大写的形式： GET、HEAD、POST、PUT DELETE、CONNECT、OPTIONS、TRACE > 当我们GET请求时返回405 Method Not Allowed，可以查看Allow头改用HEAD方法获取文件的元信息。 GET方法的含义是请求从服务器获取资源，搭配 URI 和其他头字段就能实现对资源更精细的操作。例如： 在 URI 后使用“#”，就可以在获取页面后直接定位 到某个标签所在的位置； 使用 If-Modified-Since 字段就变 成了“有条件的请求”，仅当资源被修改时才会执行获取动 作； 使用 Range 字段就是“范围请求”，只获取资源的一部分数据。 HEAD与GET方法类似，HEAD 方法可以看做是 GET 方法的一个“简化版”或者“轻量版”，唯一区别是服务器不会返回请求的实体数据，只会传回响应头，也就是资源的“元信息”。 它可以用在很多并不真正需要资源的场合，避免传输 body 数据的浪费。比如： 想要检查一个文件是否存在，只要发个 HEAD 请求 就可以了，没有必要用 GET 把整个文件都取下来。 要检查文件是否有新版本，同样也应该用 HEAD，服 务器会在响应头里把文件的修改时间传回来。 POST方法与前两个方法相反，是向URI指定的资源提交数据，数据就放在报文的body里。 PUT方法与POST类似，但存在微妙的不同，通常POST表示的是“新建”“create”，而PUT则是“修改”“update”。 另有一些冷僻的、应用不多的其他方法： DELETE方法指示服务器删除资源，因为这个动作危险性太大，所以通常服务器不会执行真正的删除操作，而是对资源做一个删除标记。当然，更多的时候服务器就直接不处理 DELETE 请求。 CONNECT是一个比较特殊的方法，要求服务器为客户端和另一台远程服务器建立一条特殊的连接隧道，这时 Web 服务器在中间充当了代理的角色。 OPTIONS方法要求服务器列出可对资源实行的操作方法， 在响应头的 Allow 字段里返回。它的功能很有限，用处也不 大，有的服务器（例如 Nginx）干脆就没有实现对它的支持。 补充一条同学回答： OPTIONS 方法还是用的很多的，CORS跨域请求必须用到OPTIONS方法了。 TRACE方法多用于对 HTTP 链路的测试或诊断，可以显示出请求 - 响应的传输路径。它的本意是好的，但存在漏洞，会泄漏网站的信息，所以 Web 服务器通常也是禁止使用。 10-2 安全与幂等 在 HTTP 协议里，所谓的“安全”是指请求方法不会“破 坏”服务器上的资源，即不会对服务器上的资源造成实质的修改。 按照这个定义，只有 GET 和 HEAD 方法是“安全”的，因 为它们是“只读”操作，只要服务器不故意曲解请求方法的 处理方式，无论 GET 和 HEAD 操作多少次，服务器上的数 据都是“安全的”。 而 POST/PUT/DELETE 操作会修改服务器上的资源，增加 或删除数据，所以是“不安全”的。 所谓的“幂等”意思是多次执行相同的操作，结果也都是相同的（指客户端操作对服务器的状态没有产生改 变，虽然报文内容变了，但服务器还是没有变化），即多次“幂”后结果“相等”。 GET 和 HEAD 既是安全的也是幂等的，DELETE 可以多次删除同一个资源，效果都是“资源不存在”，所以也是幂等的。 POST 和 PUT 的幂等性质就略费解一点。 按照 RFC 里的语义，POST 是“新增或提交数据”，多次提交数据会创建多个资源，所以不是幂等的；而 PUT 是“替换或更新数据”，多次更新一个资源，资源还会是第一次更新的状态，所以是幂等的。 10-3 小结 请求方法是客户端发出的、要求服务器执行的、对资源的一种操作； 请求方法是对服务器的“指示”，真正应如何处理由服务器来决定； 常用的请求方法是 GET 和 POST，分别是获取数据和发送数据； HEAD 方法是轻量级的 GET，用来获取资源的元信息； PUT 基本上是 POST 的同义词，多用于更新数据； “安全”与“幂等”是描述请求方法的两个重要属性，具有理论指导意义，可以帮助我们设计系统。 10-4 课下作业 你能把 GET/POST 等请求方法对应到数据库的“增删改查”操作吗？请求头应该如何设计呢？ 回答一： 增：POST 删：DELETE 改：PUT 查：GET 回答二： restful&quot;架构&quot;就是严格按照http规范， 比如，查询都用GET，新增用POST，更新用PUT，删除 用DELETE，url的设计也按照rest风格设计。 你觉得 TRACE/OPTIONS/CONNECT 方法能够用 GET 或 POST 间接实现吗？ 回答二： 我认为可以，因为http协议具有很好的灵活性。具体的对资源操作是由服务器决定的。 11丨你能写出正确的网址吗11-1 uri的格式 URI(UnIform Resource Identifier，统一资源标识符)与URL(Uniform Resorce Locator，统一资源定位符)可以简单地视为相等。 URI本质上是一个字符串，这个字符串的作用是唯一地标记资源的位置或者名字。 URI最常用的形式是由scheme、host:port、path和query四个部分组成，有的部分可以视情况省略。 11-2 uri的基本组成 第一部分，scheme“方案名”或者“协议名”，表示资源应该使用哪种协议来访问。 最常见的当然就是“http”了，表示使用 HTTP 协议。 另外 还有“https”，表示使用经过加密、安全的 HTTPS 协议。 此外还有其他不是很常见的，如 ftp、ldap、file、news 等。 显然，如果一个 URI 没有提供 scheme，即使后面的 地址再完善，也是无法处理的。 第二部分必须是三个特定的字符 :// ，它把 scheme 和后面的部分分离开。 第三部分是被称为“authority”的部分，表示资源所在的主机名，通常的形式是“host:post”，即主机名加端口号。 主机名可以是 IP 地址或者域名的形式，必须要有，否则浏览器就会找不到服务器。但端口号有时可以省略，浏览器等客户端会依据 scheme 使用默认的端口号，例如 HTTP 的默认端口号是 80，HTTPS 的默认端口号是 443。 第四部分是标记资源所在位置的path，它采用了类似文件系统“目录”“路径”的表示方式，因为早期互联网上的计算机多是 UNIX 系统，所以采用了 UNIX 的“/”风格。 这里特别注意：URI 的 path 部分必须 以“/”开始，也就是必须包含“/”，不要把“/”误认为属于前面 authority。 举个file类型URI的特例：file:///D:/http_study/www/，它省略了主机名，默认是本机localhost。 客户端和服务器 看到的 URI 是不一样的。客户端看到的必须是完整的 URI， 使用特定的协议去连接特定的主机，而服务器看到的只是报 文请求行里被删除了协议名和主机名的 URI。打开Google浏览器的开发者工具可以查看下图： 11-3 uri的查询参数 在URI后有个“query”部分，在path之后，用一个“?”开始，但不包含“?”，表示对资源附加的额外要求。 查询参数query的格式是多个“key=value”的字符串，这些KV值用字符“&amp;”连接，浏览器和客户端都可以按照这个格式把长串的查询参数 解析成可理解的字典或关联数组形式。 11-4 uri的完整格式​ ​ 上面这个“真正”形态比基本形态多了两部分： 是协议名之后、主机名之前的身份信息“user:passwd@”，表示登录主机时的用户名和密码，但现在已经不推荐使用这种形式了（RFC7230），因为它把敏感信息以明文形式暴露出来，存在严重的安全隐患。 查询参数后的片段标识符“#fragment”，它是 URI 所定位的资源内部的一个“锚点”或者说是“标签”，浏览器可以在获取资源后直接跳转到它指示的位置。但片段标识符仅能由浏览器这样的客户端使用，服务器是看不到的。也就是说，浏览器永远不会把带“#fragment”的URI 发送给服务器，服务器也永远不会用这种方式去处理资源的片段。 11-5 uri的编码​ URI引入了编码机制，对于 ASCII 码以外的字符集和特殊字符（如汉语、日语或@&amp;？等）做一个特殊的操作，把它们转换成与 URI 语义不冲突的形式。这在 RFC 规范里称为“escape”和“unescape”，俗称“转义”。​ URI 转义的规则有点“简单粗暴”，直接把非 ASCII 码或特殊字符转换成十六进制字节值，然后前面再加上一个“%”。​ 例如，空格被转义成“%20”，“?”被转义成“%3F”。 而中文、日文等则通常使用 UTF-8 编码后再转义，例如“银河”会被转义成“%E9%93%B6%E6%B2%B3”。​ 不过我们在浏览器的地址栏里通常是不会看到这些转义后 的“乱码”的，这实际上是浏览器一种“友好”表现，隐藏 了 URI 编码后的“丑陋一面”。 11-6 小结 URI 是用来唯一标记服务器上资源的一个字符串，通常也 称为 URL； URI 通常由 scheme、host:port、path 和 query 四个部 分组成，有的可以省略； scheme 叫“方案名”或者“协议名”，表示资源应该使 用哪种协议来访问； “host:port”表示资源所在的主机名和端口号； path 标记资源所在的位置； query 表示对资源附加的额外要求； 在 URI 里对“@&amp;/”等特殊字符和汉字必须要做编码， 否则服务器收到 HTTP 报文后会无法正确处理。 11-7 课下作业 HTTP 协议允许在在请求行里使用完整的 URI，但为什么浏览器没有这么做呢？ 回答一： 因为在请求头的字段中都有，没必要重复 URI 的查询参数和头字段很相似，都是 key-value 形 式，都可以任意自定义，那么它们在使用时该如何区别 呢？ 老师的回答： query参数针对的是资源（uri），而字段针对的是本次请求，也就是报文。 一个是长期、稳定的，一个是短期、临时的。 11-8 延伸知识 如果查询参数query太长，也可以使用POST方法，放在body里发送给服务器。 注意URI编码转义与HTML里的编码转义是完全不同的，前者使用的是“%”，后者使用“&amp;#”。 +号属于非法字符，以及标准的做法 是前端encode之后再给后端传过去，后端貌似会自动 decode。 12丨响应状态码该怎么用12-1 状态码 状态码（Status Code）是一个十进制数字，以代码的形式表示服务器对请求的处理结果，客户端可以依据代码适时转换 处理状态，例如继续发送请求、切换协议，重定向跳转等。 RFC 标准把状态码分成了五类，用数字的第一位表示分类， 而 099 不用，这样状态码的实际可用范围就大大缩小了， 由 000999 变成了 100~599。 这五类的具体含义是： 1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作。 偶尔能见到的是101 Switching Protocols，意思是客户端使用 Upgrade 头字段，要求在 HTTP 协议 的基础上改成其他的协议继续通信，比如 WebSocket。而 如果服务器也同意变更协议，就会发送状态码 101，但这之 后的数据传输就不会再使用 HTTP 了。 *2××**：成功，服务器已经成功收到报文并正确处理了客户端的请求。 200 OK是最常见的成功状态码，表示一切正常，服务器如客户端所期望的那样返回了处理结果，如果是非 HEAD 请求，通常在响应头后都会有 body 数据。 204 No Content是另一个很常见的成功状态码，它的含义与“200 OK”基本相同，但响应头后没有 body 数据。所以对于 Web 服务器来说，正确地区分 200 和 204 是很必要的。 206 Partial Content是 HTTP 分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的部分数 据时出现，它与 200 一样，也是服务器成功处理了请求， 但 body 里的数据不是资源的全部，而是其中的一部分。状态码 206 通常还会伴随着头字段“Content-Range”， 表示响应报文里 body 数据的具体范围，供客户端确认，例如“Content-Range: bytes 0-99/2000”，意思是此次获取的是总计 2000 个字节的前 100 个字节。 *3××**：重定向，资源位置发生变动，需要客户端重新发送请求。 301 Moved Permanently俗称“永久重定向”，含义是此次请求的资源已经不存在了，需要改用改用新的 URI 再次访问。 302 Found，曾经的描述短语是“Moved Temporarily”，俗称“临时重定向”，意思是请求的资源还在，但需要暂时用另一个 URI 来访问。 301 和 302 都会在响应头里使用字段Location指明后续要跳转的 URI，最终的效果很相似，浏览器都会重定向到新的URI。两者的根本区别在于语义，一个是“永久”，一个是“临时”，所以在场景、用法上差距很大。举例说明例一：你的网站升级到了 HTTPS，原来的 HTTP 不打算用了，这就是“永久”的，所以要配置 301 跳转，把所有的 HTTP 流量都切换到 HTTPS。例二：今天夜里网站后台要系统维护，服务暂时不可用，这就属于“临时”的，可以配置成 302 跳转，把流量临时切换到一个静态通知页面，浏览器看到这个 302 就知道这只是暂时的情况，不会做缓存优化，第二天还会访问原来的地址。 304 Not Modified是一个比较有意思的状态码，它用于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成“重定向已到缓存的文件”（即“缓存重定向”）。 *4××**：客户端错误，请求报文有误，服务器无法处理，它是真正的“错误码”。 400 Bad Request是一个通用的错误码，表示请求报 文有错误，但具体是数据格式错误、缺少请求头还是 URI 超 长它没有明确说，所以，在开发 Web 应 用时应当尽量避免给客户端返回 400。 同学补充的： 401一般都不作处理，比如获取登录 用户的信息的接口，未登录的时候调是401，是因为没有 带相应token过去，登录之后就能正常返回登录用户的信 息了，自己处理的情况比如SPA，用户访问了一个不存… 403 Forbidden实际上不是客户端的请求出错，而是 表示服务器禁止访问资源。原因可能多种多样，例如信息敏 感、法律禁止等，如果服务器友好一点，可以在 body 里详 细说明拒绝请求的原因，不过现实中通常都是直接给一 个“闭门羹”。 404 Not Found它的原意是资源在本服务器上未找到，所 以无法提供给客户端。但现在已经被“用滥了”，只要服务 器“不高兴”就可以给出个 404，而我们也无从得知后面到 底是真的未找到，还是有什么别的原因，某种程度上它比 403 还要令人讨厌。 405 Method Not Allowed：不允许使用某些方法操作资 源，例如不允许 POST 只能 GET； 406 Not Acceptable：资源无法满足客户端请求的条件，例如请求中文但只有英文； 408 Request Timeout：请求超时，服务器等待了过长的 时间； 409 Conflict：多个请求发生了冲突，可以理解为多线程 并发时的竞态； 413 Request Entity Too Large：请求报文里的 body 太 大； 414 Request-URI Too Long：请求行里的 URI 太大； 429 Too Many Requests：客户端发送了太多的请求， 通常是由于服务器的限连策略； 431 Request Header Fields Too Large：请求头某个字 段或总体太大。 *5××**：服务器错误，服务器在处理请求时内部发生了错误。 500 Internal Server Error与 400 类似，也是一个通 用的错误码，服务器究竟发生了什么错误我们是不知道的。 不过对于服务器来说这应该算是好事，通常不应该把服务器 内部的详细信息，例如出错的函数调用栈告诉外界。虽然不 利于调试，但能够防止黑客的窥探或者分析。 501 Not Implemented表示客户端请求的功能还不支 持，这个错误码比 500 要“温和”一些，和“即将开业， 敬请期待”的意思差不多，不过具体什么时候“开业”就不 好说了。 502 Bad Gateway通常是服务器作为网关或者代理时 返回的错误码，表示服务器自身工作正常，访问后端服务器 时发生了错误，但具体的错误原因也是不知道的。 503 Service Unavailable表示服务器当前很忙，暂时 无法响应服务，我们上网时有时候遇到的“网络服务正忙， 请稍后重试”的提示信息就是状态码 503。503 是一个“临时”的状态，很可能过几秒钟后服务器就不 那么忙了，可以继续提供服务，所以 503 响应报文里通常 还会有一个“Retry-After”字段，指示客户端可以在多久 以后再次尝试发送请求。 12-2 小结 状态码在响应报文里表示了服务器对请求的处理结果； 状态码后的原因短语是简单的文字描述，可以自定义； 状态码是十进制的三位数，分为五类，从 100 到 599； 2××类状态码表示成功，常用的有 200、204、206； 3××类状态码表示重定向，常用的有 301、302、304； 4××类状态码表示客户端错误，常用的有 400、403、 404； 5××类状态码表示服务器错误，常用的有 500、501、 502、503。 12-3 课下作业 你在开发 HTTP 客户端，收到了一个非标准的状态码， 比如 4××、5××，应当如何应对呢？ 回答一： 目前客户端基本都是解析成失败的情况，大部分给个失败错误友好界面。 回答二： 4xx一般都是弹窗提示，将错误显示出来，5xx有单独的 页面显示错误信息。 你在开发 HTTP 服务器，处理请求时发现报文里缺了一 个必需的 query 参数，应该如何告知客户端错误原因呢？ 回答一： 目前服务器很多也是返回4xx的错误码，感觉被烂用了，应该要返回5xx，然后我们还会定义一个msg说明请求缺少query参数。 回答二： 在自己的项目中都是返回json直接明确告诉缺少什么参数，会内部再定义一 个code和msg，然后定义一个参数错误code，在msg中 提示错误具体原因。 13丨http有哪些特点​ 13-1 五大基本特点 首先， HTTP 协议是一个“灵活可扩展”的传输协议。 HTTP 协议初诞生的时候就比较简单，本着开放的精神只规定了报文的基本格式，比如用空格分隔单词，用换行分隔字段，“header+body”等，报文里的各个组成部分都没有做严格的语法语义限制，可以由开发者任意定制。所以，HTTP 协议就随着互联网的发展一同成长起来了。在这个过程中，HTTP 协议逐渐增加了请求方法、版本号、状态码、头字段等特性。而 body 也不再限于文本形式的 TXT 或 HTML，而是能够传输图片、音频视频等任意数据，这些都是源于它的“灵活可扩展”的特点。 第二个特点， HTTP 协议是一个“可靠”的传输协议。 因为 HTTP 协议是基于 TCP/IP 的，而 TCP 本身是一个“可靠”的传 输协议，所以 HTTP 自然也就继承了这个特性，能够在请求方和应答方之间“可靠”地传 输数据。它的具体做法与 TCP/UDP 差不多，都是对实际传输的数据（entity）做了一层包装，加上 一个头，然后调用 Socket API，通过 TCP/IP 协议栈发送或者接收。 不过我们必须正确地理解“可靠”的含义，HTTP 并不能 100% 保证数据一定能够发送到 另一端，在网络繁忙、连接质量差等恶劣的环境下，也有可能收发失败。“可靠”只是向使 用者提供了一个“承诺”，会在下层用多种手段“尽量”保证数据的完整送达。 当然，如果遇到光纤被意外挖断这样的极端情况，即使是神仙也不能发送成功。所以，“可 靠”传输是指在网络基本正常的情况下数据收发必定成功，借用运维里的术语，大概就 是“3 个 9”或者“4 个 9”的程度吧。 第三个特点，HTTP 协议是一个应用层的协议。 许多应用层协议都仅关注很小的应用领域，局限在很少的应用场景，例如 FTP 只能传输文件、SMTP 只能发送邮件、SSH 只能 远程登录等，在通用的数据传输方面“完全不能打”。所以 HTTP 凭借着可携带任意头字段和实体数据的报文结构，以及连接控制、缓存代理等 方便易用的特性，一出现就“技压群雄”，迅速成为了应用层里的“明星”协议。只要不太 苛求性能，HTTP 几乎可以传递一切东西，满足各种需求，称得上是一个“万能”的协议。 第四个特点，HTTP 协议使用的是请求 - 应答通信模式。 这个请求 - 应答模式是 HTTP 协议根本的通信模型，通俗来讲就是“一发一收”“有来有去”，就像是写代码时的函数调用，只要填好请求头里的字段，“调用”后就会收到答复。 请求 - 应答模式也明确了 HTTP 协议里通信双方的定位，永远是请求方先发起连接和请求，是主动的，而应答方只有在收到请求后才能答复，是被动的，如果没有请求时不会有任何动作。 当然，请求方和应答方的角色也不是绝对的，在浏览器 - 服务器的场景里，通常服务器都是应答方，但如果将它用作代理连接后端服务器，那么它就可能同时扮演请求方和应答方的 角色。 HTTP 的请求 - 应答模式也恰好契合了传统的 C/S（Client/Server）系统架构，请求方作为客户端、应答方作为服务器。所以，随着互联网的发展就出现了 B/S（Browser/Server）架构，用轻量级的浏览器代替笨重的客户端应用，实现零维护的“瘦”客户端，而服务器则摈弃私有通信协议转而使用 HTTP 协议。 此外，请求 - 应答模式也完全符合RPC（Remote Procedure Call）的工作模式，可以把 HTTP 请求处理封装成远程函数调用，导致了 WebService、RESTful 和 gPRC 等的出现。 第五个特点，HTTP 协议是无状态的。 这个所谓的“状态”其实就是客户端或者服务器里保存的一些数据或者标志，记录了通信过程中的一些 变化信息。 TCP 协议是有状态的，一开始处于 CLOSED 状态，连接成功后是 ESTABLISHED 状态，断开连接后是 FIN-WAIT 状态，后又是 CLOSED 状态。这些“状态”就需要 TCP 在内部用一些数据结构去维护，可以简单地想象成是个标志量， 标记当前所处的状态，例如 0 是 CLOSED，2 是 ESTABLISHED 等等。 而HTTP在整个协议里没有规定任何的“状态”， 客户端和服务器永远是处在一种“无知”的状态。建立连接前两者互不知情，每次收发的报 文也都是互相独立的，没有任何的联系。收发报文也不会对客户端或服务器产生任何影响， 连接后也不会要求保存任何信息。 “无状态”形象地来说就是“没有记忆能力”。 对比 UDP 协议，它是无连接也无状态的，顺序发包乱序收包，数据包发出去后就不管了，收到后也不会顺序整理。而 HTTP 是有连接无状态，顺序发包顺序收包，按照收发的顺序管理报文。 其实 HTTP 协议还有非常多的特点，例如传输的实体数据可缓存可压缩、可分段获取数据、支持身份认证、支持国际化语言等。但这些并不能算是 HTTP 的基本特点，因为这都是由第一个“灵活可扩展”的特点所衍生出来的。 13-2 小结 HTTP 是灵活可扩展的，可以任意添加头字段实现任意功能； HTTP 是可靠传输协议，基于 TCP/IP 协议“尽量”保证数据的送达； HTTP 是应用层协议，比 FTP、SSH 等更通用、功能更多，能够传输任意数据； HTTP 使用了请求 - 应答模式，客户端主动发起请求，服务器被动回复请求； HTTP 本质上是无状态的，每个请求都是互相独立、毫无关联的，协议不要求客户端或 服务器记录请求相关的信息。 13-3 课下作业 你能说一下今天列出的这些 HTTP 的特点中哪些是优点，哪些是缺点吗？ 回答一： 灵活可扩张是大优点吧。 可靠性比不上MQ， 传输数据虽然通用，可是文件传输时效率肯定比不是FTP， 无状态，在需要状态的地方通过扩展弥补不足。 请求应答，有些需要服务器主动推得需要用websocket协议。 回答二： 1、灵活可扩展是优点，促进其发展。 2和3也是优点。 4、是优点也是缺点，缺点是应答 方不能做到主动反馈。 5、即是优点也是缺点，主要是看适用的场景，无状态，请求时需 要携带更多的数据。 不同的应用场合有不同的侧重方面，你觉得哪个特点对你来说是重要的呢？ 13-4 延伸知识 如果要100%保证数据收发成功就不能使用HTTP或者TCP协议了，而是要用各种消息中间件（MQ），如RabbitMQ、ZeroMQ、Kafka等。 以前HTTP协议的“无连接”特点很影响性能，在HTTP/1.1里就改成了综上默认启用keepalive长连接机制。 请求应答模式也就注定了HTTP不适合用于IM场景？ 是的，所以就出现了WebSocket。 14丨http有哪些优点 又有哪些缺点​ 特别注意：今天的讨论范围仅限于HTTP/1.1。 14-1 优点 首先，HTTP 最重要也是最突出的优点是“简单、灵活、易于扩展”。 初次接触 HTTP 的人都会认为，HTTP 协议是很“简单”的，基本的报文格式就 是“header+body”，头部信息也是简单的文本格式，用的也都是常见的英文单词，即使 不去看 RFC 文档，只靠猜也能猜出个“八九不离十”可不要小看了“简单”这个优点，它不仅降低了学习和使用的门槛，能够让更多的人研究和 开发 HTTP 应用，而且“简单”蕴含了进化和扩展的可能性，所 谓“少即是多”，“把简单的系统变复杂”，要比“把复杂的系统变简单”容易得多。 所以，在“简单”这个最基本的设计理念之下，HTTP 协议又多出了“灵活和易于扩展”的 优点。“灵活和易于扩展”实际上是一体的，它们互为表里、相互促进，因为“灵活”所以才 会“易于扩展”，而“易于扩展”又反过来让 HTTP 更加灵活，拥有更强的表现能力。HTTP 协议里的请求方法、URI、状态码、原因短语、头字段等每一个核心组成要素都没有 被“写死”，允许开发者任意定制、扩充或解释，给予了浏览器和服务器最大程度的信任和 自由，也正好符合了互联网“自由与平等”的精神——缺什么功能自己加个字段或者错误 码什么的补上就是了。“灵活、易于扩展”的特性还表现在 HTTP 对“可靠传输”的定义上，它不限制具体的下 层协议，不仅可以使用 TCP、UNIX Domain Socket，还可以使用 SSL/TLS，甚至是基于 UDP 的 QUIC，下层可以随意变化，而上层的语义则始终保持稳定。 HTTP 协议的另一大优点是“应用广泛”，软硬件环境都非常成熟。 HTTP 的触角已经延伸到了世界的每一个角落：从简 单的 Web 页面到复杂的 JSON、XML 数据，从台式机上的浏览器到手机上的各种 APP，从看新闻、泡论坛到购物、理财、“吃鸡”，你很难找到一个没有使用 HTTP 的地方。 不仅在应用领域，在开发领域 HTTP 协议也得到了广泛的支持。它并不限定某种编程语言 或者操作系统，所以天然具有“跨语言、跨平台”的优越性。而且，因为本身的简单特性很 容易实现，所以几乎所有的编程语言都有 HTTP 调用库和外围的开发测试工具。 HTTP 广泛应用的背后还有许多硬件基础设施支持，各个互联网公司和传统行业公司都不遗 余力地“触网”，购买服务器开办网站，建设数据中心、CDN 和高速光纤，持续地优化上 网体验，让 HTTP 运行的越来越顺畅。 14-2 双刃剑-既是优点也是缺点 无状态 优点：（1）因为服务器没有“记忆能力”，所以就不需要额外的资源来记录状态信息，不仅实现上会简 单一些，而且还能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。（2）而且，“无状态”也表示服务器都是相同的，没有“状态”的差异，所以可以很容易地组成 集群，让负载均衡把请求转发到任意一台服务器，不会因为状态不一致导致处理出错，使 用“堆机器”的“笨办法”轻松实现高并发高可用。 缺点：既然服务器没有“记忆能力”，它就无法支持需要连续多个步骤的“事务”操作。例如电商 购物，首先要登录，然后添加购物车，再下单、结算、支付，这一系列操作都需要知道用户 的身份才行，但“无状态”服务器是不知道这些请求是相互关联的，每次都得问一遍身份信 息，不仅麻烦，而且还增加了不必要的数据传输量。 所以，HTTP 协议最好是既“无状态”又“有状态”，不过还真有“鱼和熊掌”两者兼得这样的好事，这就是“小甜饼”Cookie 技术（第 19 讲）。 明文传输 “明文”意思就是协议里的报文（准确地说是 header 部分）不使用二进制数据，而是用简 单可阅读的文本形式。 优点：对比 TCP、UDP 这样的二进制协议，它的优点显而易见，不需要借助任何外部工具，用浏 览器、Wireshark 或者 tcpdump 抓包后，直接用肉眼就可以很容易地查看或者修改，为 我们的开发调试工作带来极大的便利。 缺点：HTTP 报文的所有信息都会暴露在“光天化日之 下”，在漫长的传输链路的每一个环节上都毫无隐私可言，不怀好意的人只要侵入了这个链 路里的某个设备，简单地“旁路”一下流量，就可以实现对通信的窥视。案例：“免费 WiFi 陷阱” 14-3 缺点 不安全 安全有很多的方面，明文只是“机密”方面的一个缺点，在“身份认证”和“完整性校 验”这两方面 HTTP 也是欠缺的。“身份认证”简单来说就是“怎么证明你就是你”。在虚拟的网络世界里这却是个麻烦事。HTTP 没有提供有效的手段来确认通信双方的真实 身份。虽然协议里有一个基本的认证机制，但因为刚才所说的明文传输缺点，这个机制几乎可以说是“纸糊的”，非常容易被攻破。如果仅使用 HTTP 协议，很可能你会连到一个页 面一模一样但却是个假冒的网站，然后再被“钓”走各种私人信息。 HTTP 协议也不支持“完整性校验”，数据在传输过程中容易被窜改而无法验证真伪。比如黑客可以篡改银行用HTTP发来的消息。虽然银行可以用 MD5、SHA1 等算法给报文加上数字摘要，但还是因为“明文”这个致命 缺点，黑客可以连同摘要一同修改，最终还是判断不出报文是否被窜改。 为了解决 HTTP 不安全的缺点，所以就出现了 HTTPS。 性能不算差，不够好 必须要说的是，TCP 的性能是不差的，否则也不会纵横互联网江湖四十余载了，而且它已 经被研究的很透，集成在操作系统内核里经过了细致的优化，足以应付大多数的场景。只可惜如今的江湖已经不是从前的江湖，现在互联网的特点是移动和高并发，不能保证稳定 的连接质量，所以在 TCP 层面上 HTTP 协议有时候就会表现的不够好。 而“请求 - 应答”模式则加剧了 HTTP 的性能问题，这就是著名的“队头阻塞”（Headof-line blocking），当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面 排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据。为了解决这个问题，就诞生出了一个专门的研究课题“Web 性能优化”，HTTP 官方标准 里就有“缓存”一章（RFC7234），非官方的“花招”就更多了，例如切图、数据内嵌与 合并，域名分片、JavaScript“黑科技”等等。 14-4 小结 HTTP 最大的优点是简单、灵活和易于扩展； HTTP 拥有成熟的软硬件环境，应用的非常广泛，是互联网的基础设施； HTTP 是无状态的，可以轻松实现集群化，扩展性能，但有时也需要用 Cookie 技术来实 现“有状态”； HTTP 是明文传输，数据完全肉眼可见，能够方便地研究分析，但也容易被窃听； HTTP 是不安全的，无法验证通信双方的身份，也不能判断报文是否被窜改； HTTP 的性能不算差，但不完全适应现在的互联网，还有很大的提升空间。 14-5 课下作业 你最喜欢的 HTTP 优点是哪个？最不喜欢的缺点又是哪个？为什么？ 你能够再进一步扩展或补充论述今天提到这些优点或缺点吗？ 你能试着针对这些缺点提出一些自己的解决方案吗？ 14-6 延伸知识 出于安全的原因，绝大多数网站都封禁了80/8080以外的端口号，只允许HTTP协议“穿透”，这也是造成HTTP流行的客观原因之一。 HTTP/1.1以文本格式传输header，有严重的数据冗余，也影响了它的性能。 虽然使用了HTTPS金融领域还是需要对数据加密和完整性检验，加密对body数据好加密对 于header部分不好加密，需要对KV一个一个加密有点麻烦，不过在传输的时候一般把字段 都用body传输，header里面不使用自定义字段。 作者回复: 用了https不就都全加密了吗？ 你的办法也对，保密的部分放在body里，反正http格式很灵活，收到以后随便解释。 四 进阶篇15丨海纳百川 http的实体数据15-1 数据类型与编码 HTTP 协议是应用层的协议，数据到达之后工 作只能说是完成了一半，还必须要告诉上层应用这是什么数 据才行，否则上层应用就会“不知所措”。 早在HTTP协议诞生前，有个用在电子邮件系统里的，让电子邮件可以发送ASCII码以外的任意数据，方案的名字叫做“多用途互联网邮件扩展”(Multipurpose Internet Mail Extensions)，简称MIME。 MIME 是一个很大的标准规范，但 HTTP 只“顺手牵羊”取 了其中的一部分，用来标记 body 的数据类型，这就是我们 平常总能听到的“MIME type”。 MIME 把数据分成了八大类，每个大类下再细分出多个子 类，形式是“type/subtype”的字符串，巧得很，刚好也 符合了 HTTP 明文的特点，所以能够很容易地纳入 HTTP 头 字段里。 这里简单列举一下在 HTTP 里经常遇到的几个类别： text：即文本格式的可读数据，我们最熟悉的应该就是 text/html 了，表示超文本文档，此外还有纯文本text/plain、样式表 text/css 等。 image：即图像文件，有 image/gif、image/jpeg、 image/png 等。 audio/video：音频和视频数据，例如 audio/mpeg、 video/mp4 等。 application：数据格式不固定，可能是文本也可能是二 进制，必须由上层应用程序来解释。常见的有 application/json，application/javascript、 application/pdf 等，另外，如果实在是不知道数据是什 么类型，像刚才说的“黑盒”，就会是 application/octet-stream，即不透明的二进制数据。 但仅有 MIME type 还不够，因为 HTTP 在传输时为了节约 带宽，有时候还会压缩数据，所以还需要有一个“Encoding type”，告诉数据是 用的什么编码格式，这样对方才能正确解压缩，还原出原始 的数据。 比起 MIME type 来说，Encoding type 就少了很多，常用 的只有下面三种： gzip：GNU zip 压缩格式，也是互联网上最流行的压缩 格式； deflate：zlib（deflate）压缩格式，流行程度仅次于 gzip； br：一种专门为 HTTP 优化的新压缩算法（Brotli）。 15-2 数据类型使用的头字段 有了 MIME type 和 Encoding type，无论是浏览器还是服 务器就都可以轻松识别出 body 的类型，也就能够正确处理 数据了。 HTTP 协议为此定义了两个 Accept 请求头字段和两个 Content 实体头字段，用于客户端和服务器进行“内容协商”。也就是说，客户端用 Accept 头告诉服务器希望接收 什么样的数据，而服务器用 Content 头告诉客户端实际发 送了什么样的数据。 Accept字段标记的是客户端可理解的 MIME type，可以 用“,”做分隔符列出多个类型，让服务器有更多的选择余 地，例如下面的这个头： 1Accept: text&#x2F;html,application&#x2F;xml,image&#x2F;webp,image&#x2F;png&#96; 这就是告诉服务器：“我能够看懂 HTML、XML 的文本， 还有 webp 和 png 的图片，请给我这四类格式的数据”。 相应的，服务器会在响应报文里用头字段Content-Type告诉实体数据的真实类型： 12Content-Type: text&#x2F;htmlContent-Type: image&#x2F;png 这样浏览器看到报文里的类型是“text/html”就知道是 HTML 文件，会调用排版引擎渲染出页面，看 到“image/png”就知道是一个 PNG 文件，就会在页面上 显示出图像。 补充： Content-Type是实体字段，所以请求和响应里都可以用，作用是指明body数据的类型。 实际上它是个通用字段，如果要发post请求，就需要带上它。 Accept-Encoding字段标记的是客户端支持的压缩格式，例如上面说的 gzip、deflate 等，同样也可以用“,”列出多个，服务器可以选择其中一种来压缩数据，实际使用的压缩格式放在响应头字段Content-Encoding里。 12Accept-Encoding: gzip, deflate, brContent-Encoding: gzip 不过这两个字段是可以省略的，如果请求报文里没有 Accept-Encoding 字段，就表示客户端不支持压缩数据； 如果响应报文里没有 Content-Encoding 字段，就表示响 应数据没有被压缩。 请求时注意区分Accept-表示客户端希望接受（支持）的数据类型；Content-表示我发送的数据就是这个类型的。后者常用于POST请求。 15-3 语言类型与编码 所谓的“语言类型”就是人类使用的自然语言，例如英语、 汉语、日语等，而这些自然语言可能还有下属的地区性方 言，所以在需要明确区分的时候也要使用“typesubtype”的形式，不过这里的格式与数据类型不同，分隔符不是“/”，而是“-”。例如： en 表示任意的英语，en-US 表示美式英语， en-GB 表示英式英语，而 zh-CN 就表示我们最常使用的汉 语。 关于自然语言的计算机处理还有一个更麻烦的东西叫做“字符集”。 Unicode字符集 和 UTF-8编码方案把世界上所有的语言都容纳在一种编码方案里，UTF-8 也成为了互联网上的标准编码方案。 15-4 语言类型使用的头字段 Accept-Language字段标记了客户端可理解的自然语言， 也允许用“,”做分隔符列出多个类型，例如： 1Accept-Language: zh-CN, zh, en 这个请求头会告诉服务器：“最好给我 zh-CN 的汉语文字，如果没有就用其他的汉语方言，如果还没有就给英文”。 相应的，服务器应该在响应报文里用头字段Content-Language告诉客户端实体数据使用的实际语言类型： 1Content-Language: zh-CN 字符集在 HTTP 里使用的请求头字段是Accept-Charset， 但响应头里却没有对应的 Content-Charset，而是在 Content-Type字段的数据类型后面用“charset=xxx”来 表示，这点需要特别注意。 例如，浏览器请求 GBK 或 UTF-8 的字符集，然后服务器返 回的是 UTF-8 编码，就是下面这样： 12Accept-Charset: gbk, utf-8Content-Type: text&#x2F;html; charset&#x3D;utf-8 不过现在的浏览器都支持多种字符集，通常不会发送 Accept-Charset，而服务器也不会发送 ContentLanguage，因为使用的语言完全可以由字符集推断出来， 所以在请求头里一般只会有 Accept-Language 字段，响应 头里只会有 Content-Type 字段。 15-5 内容协商的质量值 在 HTTP 协议里用 Accept、Accept-Encoding、AcceptLanguage 等请求头字段进行内容协商的时候，还可以用一 种特殊的“q”参数表示权重来设定优先级，这里 的“q”是“quality factor”的意思。 权重的最大值是 1，最小值是 0.01，默认值是 1，如果值是 0 就表示拒绝。具体的形式是在数据类型或语言代码后面加 一个“;”，然后是“q=value”。 这里要提醒的是“;”的用法，在大多数编程语言里“;”的 断句语气要强于“,”，而在 HTTP 的内容协商里却恰好反 了过来，“;”的意义是小于“,”的。例如下面的 Accept 字段： 1Accept: text&#x2F;html,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8 它表示浏览器最希望使用的是 HTML 文件，权重是 1，其 次是 XML 文件，权重是 0.9，最后是任意数据类型，权重 是 0.8。服务器收到请求头后，就会计算权重，再根据自己 的实际情况优先输出 HTML 或者 XML。 15-6 内容协商的结果 内容协商的过程是不透明的，每个 Web 服务器使用的算法 都不一样。但有的时候，服务器会在响应头里多加一个Vary 字段，记录服务器在内容协商时参考的请求头字段，给出一 点信息，例如： 1Vary: Accept-Encoding,User-Agent,Accept 这个 Vary 字段表示服务器依据了 Accept-Encoding、 User-Agent 和 Accept 这三个头字段，然后决定了发回的 响应报文。 Vary 字段可以认为是响应报文的一个特殊的“版本标 记”。每当 Accept 等请求头变化时，Vary 也会随着响应 报文一起变化。也就是说，同一个 URI 可能会有多个不同 的“版本”，主要用在传输链路中间的代理服务器实现缓存 服务，这个之后讲“HTTP 缓存”时还会再提到。 15-7 动手实验​ 启动后访问http://www.chrono.com/15-1?name=a.json，可以看到下图： ​ 15-8 小结​ 数据类型表示实体数据的内容是什么，使用的是 MIME type，相关的头字段是 Accept 和 Content-Type； 数据编码表示实体数据的压缩方式，相关的头字段是 Accept-Encoding 和 Content-Encoding； 语言类型表示实体数据的自然语言，相关的头字段是 Accept-Language 和 Content-Language； 字符集表示实体数据的编码方式，相关的头字段是 Accept-Charset 和 Content-Type； 客户端需要在请求头里使用 Accept 等头字段与服务器进 行“内容协商”，要求服务器返回最合适的数据； Accept 等头字段可以用“,”顺序列出多个可能的选项， 还可以用“;q=”参数来精确指定权重。 15-9 课下作业 回答一： 含义是：我这个请求最希望服务器给我返回的编码方式是gzip和deflate，他们俩在我这是最优的地位，我不接 受br的编码方式，如果还有其他的编码方式的话对我来说 权重0.5。 回答二： 服务器优先按照gzip和deflate压缩，否则用其他压缩算法，但是不用brotli算法。 假设你要使用 POST 方法向服务器提交一些 JSON 格式的数据，里面包含有中文，请求头应该是什么样子的呢？ 切记： post时一定要在 header中加上Content-type，不然会报错。 Content-type: application/json; charset=utf-8 Content-language: zh-CN 试着用快递发货收货比喻一下 MIME、Encoding 等概 念。 15-10 延伸知识-经验之谈 现在很多小文件 比如图片 都往云存上放了 千万指定正确 content-type 一旦指定错 批量修改太麻烦 而且会影响终端的解析。 每一个并发连接，都需要新建tcp三次握手吗？还 是一次tcp握手后，可以并发多个连接？ 作者回复: 每建立一个连接就需要tcp握手，对同一个ip地址 +端口，浏览器通常最多建立6个并发连接。 16丨把大象装进冰箱 http传输大文件的方法16-1 数据压缩​ 通常浏览器在发送请求时都会带着“Accept-Encoding”头字段，里面是浏览器支持的压缩格式列表， 例如 gzip、deflate、br 等，这样服务器就可以从中选择一 种压缩算法，放进“Content-Encoding”响应头里，再把 原数据压缩后发给浏览器。​ 不过这个解决方法也有个缺点，gzip 等压缩算法通常只对 文本文件有较好的压缩率，而图片、音频视频等多媒体数据 本身就已经是高度压缩的，再用 gzip 处理也不会变小（甚 至还有可能会增大一点），所以它就失效了。​ 不过数据压缩在处理文本的时候效果还是很好的，所以各大 网站的服务器都会使用这个手段作为“保底”。例如，在 Nginx 里就会使用“gzip on”指令，启用 对“text/html”的压缩。 16-2 分块传输 把大文件“拆开”，分解成多个小块，把这些小块分批发给浏览器，浏览器收到后再组装复原。 这样浏览器和服务器都不用在内存里保存文件的全部，每次只收发一小部分，网络也不会被大文件长时间占用，内存、 带宽等资源也就节省下来了。 这种“化整为零”的思路在 HTTP 协议里就 是“chunked”分块传输编码，在响应报文里用头字段“Transfer-Encoding: chunked”来表示，意思是报文 里的 body 部分不是一次性发过来的，而是分成了许多的块 （chunk）逐个发送。 分块传输也可以用于“流式数据”，例如由数据库动态生成 的表单页面，这种情况下 body 数据的长度是未知的，无法 在头字段“Content-Length”里给出确切的长度，所以也 只能用 chunked 方式分块发送。 “Transfer-Encoding: chunked”和“Content-Length”这两个字段是互斥的，也就是说响应报文里这两个字段不能同时出现，一个响应报文的传输要么是长度已 知，要么是长度未知（chunked），这一点你一定要记住。 分块传输的编码规则，同样采用了明文的方式，很类似响应头： 1. 每个分块包含两个部分，长度头和数据块； 2. 长度头是以 CRLF（回车换行，即\\r\\n）结尾的一行明 文，用 16 进制数字表示长度； 3. 数据块紧跟在长度头后，最后也用 CRLF 结尾，但数据不 包含 CRLF； 4. 最后用一个长度为 0 的块表示结束，即“0\\r\\n\\r\\n”。 请求效果如下： 不过浏览器在收到分块传输的数据后会自动按照规则去掉分 块编码，重新组装出内容，所以想要看到服务器发出的原始 报文形态就得用 Telnet 手工发送请求（或者用 Wireshark 抓包）。 16-3 范围请求 比如看剧想跳片头或拖动进度条快进，这实际上是想获取一个大文件其中的片段数据，分块传输并没有这个能力。 HTTP协议为了满足这样的需求，提出了“范围请求”（range requests）的概念，允许客户端在请求头里使 用专用字段来表示只获取文件的一部分，相当于是客户端的“化整为零”。 范围请求不是 Web 服务器必备的功能，可以实现也可以不 实现，所以服务器必须在响应头里使用字段“Accept-Ranges: bytes”明确告知客户端：“我是支持范围请求 的”。 如果不支持的话该怎么办呢？服务器可以发送“AcceptRanges: none”，或者干脆不发送“Accept-Ranges”字 段，这样客户端就认为服务器没有实现范围请求功能，只能 老老实实地收发整块文件了。 请求头Range是 HTTP 范围请求的专用字段，格式 是“bytes=x-y”，其中的 x 和 y 是以字节为单位的数据 范围。 要注意 x、y 表示的是“偏移量”，范围必须从 0 计数，例 如前 10 个字节表示为“0-9”，第二个 10 字节表示 为“10-19”，而“0-10”实际上是前 11 个字节。 Range 的格式也很灵活，起点 x 和终点 y 可以省略，能够 很方便地表示正数或者倒数的范围。假设文件是 100 个字 节，那么： “0-”表示从文档起点到文档终点，相当于“0-99”，即 整个文件；“10-”是从第 10 个字节开始到文档末尾，相当于“1099”；“-1”是文档的最后一个字节，相当于“99-99”；“-10”是从文档末尾倒数 10 个字节，相当于“9099”。 服务器收到 Range 字段后，需要做四件事： 它必须检查范围是否合法，比如文件只有 100 个字 节，但请求“200-300”，这就是范围越界了。服务器就会 返回状态码416，意思是“你的范围请求有误，我无法处 理，请再检查一下”。 如果范围正确，服务器就可以根据 Range 头计算偏 移量，读取文件的片段了，返回状态码“206 Partial Content”，和 200 的意思差不多，但表示 body 只是原 数据的一部分。 服务器要添加一个响应头字段Content-Range，告 诉片段的实际偏移量和资源的总大小，格式是“bytes xy/length”，与 Range 头区别在没有“=”，范围后多了 总长度。例如，对于“0-10”的范围请求，值就是“bytes 0-10/100”。 最后剩下的就是发送数据了，直接把片段用 TCP 发给客户 端，一个范围请求就算是处理完了。 【举例说明】 请求使用Range字段获取了文件的前 32 个字节： 1GET /16-2 HTTP/1.1 Host: www.chrono.com Range: bytes=0-31 返回的数据是（去掉了几个无关字段）： 123HTTP/1.1 206 Partial Content Content-Length: 32 Accept-Ranges: bytes Content-Range: bytes 0-31/96// this is a plain text json doc 不仅看视频的拖拽进度需要范围请求，常用的下载工具里的 多段下载、断点续传也是基于它实现的，要点是： 先发个 HEAD，看服务器是否支持范围请求，同时获取文 件的大小； 开 N 个线程，每个线程使用 Range 字段划分出各自负责 下载的片段，发请求传输数据； 下载意外中断也不怕，不必重头再来一遍，只要根据上次 的下载记录，用 Range 请求剩下的那一部分就可以了。 16-4 多段数据 可以在Range头里使用多个“x-y”，一次性获取多个片段数据，这种情况需要使用一种特殊的 MIME 类 型：“multipart/byteranges”，表示报文的 body 是由 多段字节序列组成的，并且还要用一个参 数“boundary=xxx”给出段之间的分隔标记。 多段数据的格式与分块传输也比较类似，但它需要用分隔标 记 boundary 来区分不同的片段，可以通过图来对比一下。 每一个分段必须以“- -boundary”开始（前面加两个“-”），之后要用“Content-Type”和“Content-Range”标记这段数据的类型和所在范围，然后就像普通的响应头一样以回车换行结束，再加上分段数据，最后用一个“- -boundary- -”（前后各有两个“-”）表示所有的 分段结束。 【举例说明】 发出有两个范围的请求： 123GET /16-2 HTTP/1.1Host: www.chrono.comRange: bytes=0-9, 20-29 得到的就会是下面这样： ```http HTTP/1.1 206 Partial Content Content-Type: multipart/byteranges; boundary=0000000000 Content-Length: 189 Connection: keep-alive Accept-Ranges: bytes ​​ –00000000001​ Content-Type: text/plain​ Content-Range: bytes 0-9/96​​ // this is​​ –00000000001​ Content-Type: text/plain​ Content-Range: bytes 20-29/96​​ ext json d​ –00000000001-​ ```​​ &gt; 报文里的“- -00000000001”就是多段的分隔符，使用它 客户端就可以很容易地区分出多段 Range 数据。 16-5 小结 压缩 HTML 等文本文件是传输大文件最基本的方法； 分块传输可以流式收发数据，节约内存和带宽，使用响应 头字段“Transfer-Encoding: chunked”来表示，分块 的格式是 16 进制长度头 + 数据块； 范围请求可以只获取部分数据，即“分块请求”，实现视 频拖拽或者断点续传，使用请求头字段“Range”和响应 头字段“Content-Range”，响应状态码必须是 206； 也可以一次请求多个范围，这时候响应报文的数据类型 是“multipart/byteranges”，body 里的多个部分会用 boundary 字符串分隔。 要注意这四种方法不是互斥的，而是可以混合起来使用，例 如压缩后再分块传输，或者分段后再分块。 16-6 课下作业 分块传输数据的时候，如果数据里含有回车换行（\\r\\n） 是否会影响分块的处理呢？ 回答一： 分块传输中数据里含有回车换行（\\r\\n）不影响分块处 理，因为分块前有数据长度说明。 如果对一个被 gzip 的文件执行范围请求，比如“Range: bytes=10-19”，那么这个范围是应用于原文件还是压缩后的文件呢？ 老师回答： 需要分情况，看原文件是什么形式。如果原来的文件是 gzip的，那就是应用于压缩后的文件 。如果原文件是文本，而是在传输过程中被压缩，那么就应用于压缩前的数据。 总之，range是针对原文件的。 再比如说，有一个1M的纯文本，range请求其中的500K，然 后服务器编码为gzip（Content-Encoding: gzip），压缩 成200k，浏览器收到后解压缩，就得到了这部分的500k数 据。 回答二： 可以想象 一下看视频的时候，我们拖拽进度条请求的range范围是 针对原视频长度的，如果针对压缩后的，那么我们实际拖 拽的范围和响应的数据范围就不一致了。 16-7 延伸知识 gzip的压缩率通常能够超过60%，而br算法是专为HTML设计的，压缩效率和性能比gzip还要好，能够再提高20%的压缩密度。 Nginx的“gzip on”指令很智能，只会压缩文本数据，不会压缩图片、音频、视频。 Transfer-Encoding字段最常见的值是chunked，但也可以用gzip、deflate等，表示传输时使用了压缩编码。注意这与Content-Encoding不同，Transfer-Encoding在传输后会被自动解码还原出原始数据，而Content-Encoding则必须由应用自行解码。 分块传输在末尾还允许有“拖尾数据”，由响应头字段Trailer指定。 http交给tcp进行传输的时候本来就会分块，那http分块的意义是什么呢？ 作者回复: 在http层是看不到tcp的，它不知道下层协议是否 会分块，下层是否分块对它来说没有意义，不关心。 在http里一个报文必须是完整交付，在处理大文件的时候就 很不方便，所以就要分块，在http层面方便处理。 chunked主要是在http的层次来解决问题。 在带宽固定的情况下，范围请求没发提高下载速 度。如果服务器对客户端每个累链接限速的情况下，可通 过多线程并发下载，提高下载速度是么？ 作者回复：是的 为啥分块意味着长度未知？ 作者回复: 举个例子，从GitHub上下载源码包，GitHub要 实时压缩实时发送，而不是一下子压缩好再发送，这样 body的长度一开始就是未知的。 所以就要用分块编码，压缩一部分，就发一部分，这部分的 长度是已知的，但总长度只有压缩完才能知道。 chunked编码用在“流式”收发数据的时候，通常数据是即 时生成的，也就是动态数据。 迅雷下载或者在线视频播放器是不是在使用分块或者任意请求功能? 作者回复: 只要是用http传输，就会用range，但他们也有 可能用自己的协议而不是http，比如rmtp。 分块后的数据在用 tcp 发回的时候，是一个 块 一个 tcp 传输吗? 使用wireshark 抓包看起来 不像是 3 个 chunk 用了 3 个 tcp 响应 。 作者回复: 一个http请求必定是在一个tcp连接里收发的。 虽然是分块，但也是用一个tcp。 响应报文返回的数据太大，所以采用了chunk分块传输的 话，那响应报文在传输完成前是什么样子，响应行和头过 来了，响应体还在流式传递，那响应体内的数据该怎么展 示?作者回复: 就是按照格式分成一些片段，逐块发送，浏览器 收到后去掉分隔符，再拼成原来的样子。 17丨排队也要讲效率 http的连接管理17-1 短连接 客户端与服务器的整个连接过程很短暂，不会与服务器保持长时间的连接状态，所以就被称为“短连接”（shortlived connections）。早期的 HTTP 协议也被称为是“无连接”的协议。 短连接的缺点相当严重，因为在 TCP 协议里，建立连接和 关闭连接都是非常“昂贵”的操作。TCP 建立连接要有“三 次握手”，发送 3 个数据包，需要 1 个 RTT；关闭连接 是“四次挥手”，4 个数据包需要 2 个 RTT。 而 HTTP 的一次简单“请求 - 响应”通常只需要 4 个包， 如果不算服务器内部的处理时间，最多是 2 个 RTT。这么算下来，浪费的时间就是“3÷5=60%”，有三分之二的时间 被浪费掉了，传输效率低得惊人。 “开盖 - 打卡 - 关盖”案例 17-2 长连接 针对短连接暴露出的缺点，HTTP 协议就提出了“长连接”的通信方式，也叫“持久连接”（persistent connections）、“连接保活”（keep alive）、“连接复用”（connection reuse）。 其实解决办法也很简单，用的就是“成本均摊”的思路，既 然 TCP 的连接和关闭非常耗时间，那么就把这个时间成本 由原来的一个“请求 - 应答”均摊到多个“请求 - 应答”上。 这样虽然不能改善 TCP 的连接效率，但基于“分母效应”，每个“请求 - 应答”的无效时间就会降低不少，整体 传输效率也就提高了。 短连接与长连接的对比示意图： 显然，如果在这个长连接上发送的请求越多，分母就越大，利用率也就越高。 还是下班打开的案例，早上不关盖，下班后再关咯~ 17-3 连接相关的头字段 由于长连接对性能的改善效果非常显著，所以在 HTTP/1.1 中的连接都会默认启用长连接。不需要用什么特殊的头字段 指定，只要向服务器发送了第一次请求，后续的请求都会重 复利用第一次打开的 TCP 连接，也就是长连接，在这个连接上收发数据。 当然，我们也可以在请求头里明确地要求使用长连接机制， 使用的字段是Connection，值是“keep-alive”。 不过不管客户端是否显式要求长连接，如果服务器支持长连 接，它总会在响应报文里放一个“Connection: keep-alive”字段，告诉客户端：“我是支持长连接的，接下来 就用这个 TCP 一直收发数据吧”。 具体请看下图： 不过长连接也有一些小缺点，问题就出在它的“长”字上。 因为 TCP 连接长时间不关闭，服务器必须在内存里保存它 的状态，这就占用了服务器的资源。如果有大量的空闲长连 接只连不发，就会很快耗尽服务器的资源，导致服务器无法 为真正有需要的用户提供服务。 所以，长连接也需要在恰当的时间关闭，不能永远保持与服 务器的连接，这在客户端或者服务器都可以做到： * 在客户端，可以在请求头里加上“**Connection: close**”字 段，告诉服务器：“这次通信后就关闭连接”。服务器看到 这个字段，就知道客户端要主动关闭连接，于是在响应报文 里也加上这个字段，发送之后就调用 Socket API 关闭 TCP 连接。 * 服务器端通常不会主动关闭连接，但也可以使用一些策略。 拿 Nginx 来举例，它有两种方式： 1. 使用“keepalive_timeout”指令，设置长连接的超时时 间，如果在一段时间内连接上没有任何数据收发就主动断开连接，避免空闲连接占用系统资源。 2. 使用“keepalive_requests”指令，设置长连接上可发送 的最大请求次数。比如设置成 1000，那么当 Nginx 在这 个连接上处理了 1000 个请求后，也会主动断开连接。 * 另外，客户端和服务器都可以在报文里附加通用头字 段“Keep-Alive: timeout=value”，限定长连接的超时时 间。但这个字段的约束力并不强，通信的双方可能并不会遵 守，所以不太常见。 17-4 队头阻塞 “队头阻塞”(Head-of-line blocking，也叫“队首阻塞”)是由 HTTP 基本 的“请求 - 应答”模型所导致的。 因为 HTTP 规定报文必须是“一发一收”，这就形成了一个 先进先出的“串行”队列。队列里的请求没有轻重缓急的优 先级，只有入队的先后顺序，排在最前面的请求被最优先处 理。 如果队首的请求因为处理的太慢耽误了时间，那么队列里后 面的所有请求也不得不跟着一起等待，结果就是其他的请求 承担了不应有的时间成本。 案例：打卡上班，队头遇到卡机故障，导致后面人全迟到了 17-5 性能优化 因为“请求 - 应答”模型不能变，所以“队头阻塞”问题在 HTTP/1.1 里无法解决，只能缓解，有什么办法呢？ 案例：多买几台打卡机，一个阻塞了用其他的 这在 HTTP 里就是“并发连接”（concurrent connections），也就是同时对一个域名发起多个长连接， 用数量来解决质量的问题。 但这种方式也存在缺陷。如果每个客户端都想自己快，建立 很多个连接，用户数×并发数就会是个天文数字。服务器的 资源根本就扛不住，或者被服务器认为是恶意攻击，反而会造成“拒绝服务”，这就是常说的DDoS。 所以，HTTP 协议建议客户端使用并发，但不能“滥用”并发。 但“并发连接”所压榨出的性能也跟不上高速发展的互联网 无止境的需求，还有什么别的办法吗？ 案例：公司规模变大，员工越来越多，前台空间有限，放不下更多打卡机。那就多开几个打卡的地方，分流 这个就是“域名分片”（domain sharding）技术，还是用数量来解决质量的思路。 多开几个域名，比如 shard1.chrono.com、 shard2.chrono.com，而这些域名都指向同一台服务器 www.chrono.com对应的ip地址，这样实际长连接的数量就又上去了。 17-6 小结 早期的 HTTP 协议使用短连接，收到响应后就立即关闭 连接，效率很低； HTTP/1.1 默认启用长连接，在一个连接上收发多个请求 响应，提高了传输效率； 服务器会发送“Connection: keep-alive”字段表示启用 了长连接； 报文头里如果有“Connection: close”就意味着长连接 即将关闭； 过多的长连接会占用服务器资源，所以服务器会用一些策 略有选择地关闭长连接； “队头阻塞”问题会导致性能下降，可以用“并发连 接”和“域名分片”技术缓解。 17-7 课下作业 在开发基于 HTTP 协议的客户端时应该如何选择使用的 连接模式呢？短连接还是长连接？ 回答一： 一般使用长连接，除非明确知道只会发送一个请求，比如 游戏内连接兑换码服务进行礼包兑换。 回答二： 工作开发一般是默认的长连接，keep-alive。 应当如何降低长连接对服务器的负面影响呢？ 回答一： 1，服务器端设置keepalive＿timeout表示多长时间没有 数据则关闭连接。 2，服务器端设置keepalive_requests，表示该连接上 回答二： 对于长连接的弊端规避方式是设置timeout和最多连接次 数keepalive_requests，不符合条件的都断开长连接。 17-8 延伸知识 因为TCP协议还有“慢启动”“拥塞窗口”等特性，通常新建立的“冷连接”会比打开了一段时间的“热连接”慢一些，所以长连接比短连接还多了这一层的优势。 在长连接中的一个重要问题是如何正确地区分多个报文的开始和结束，所以最好总使用“Content-Length”头明确响应实体的长度，正确标记报文结束。如果是流式传输，body长度不能立即确定，就必须用分块传输编码。 Connection字段还有一个取值：“Connection: Upgrade”，配合状态码101表示协议升级，例如从HTTP切换到WebSocket。 服务器或者客户端是怎么是判断一个连接的呢？是不是有 一个id来对应一个连接？一个连接具体是什么东西呢？是 双方在内存中开辟的空间吗？ 作者回复: http里的连接通常就是tcp连接，也就是调用 socket api打开的一个套接字，可以理解成一个流式文件的 句柄，可读可写，但数据都是在网络上。 想要理解清楚应该去看一下tcp/ip相关的资料。 请问一下老师域名分片技术是不是让一个浏览器跟不同的 域名都建立长连接, 而这些域名都指向同一个服务器集群? 作者回复: 前半句对，后半句不一定，也可能是镜像集群。 老师能解释下，为什么tcp握手1个rtt，挥手2个rtt吗？ 作者回复: 一个来回就是1rtt，三次回收准确来说是1.5个 rtt，四次挥手是两个来回，所以是2rtt。 使用长连接时，不同 http 是怎么复用相同的 tcp 的呢？套接字里好像没有记录使用的次数和时长 作者回复: 一个tcp连接打开后就不关闭，在上面发送多个请 求响应，不需要，看图其实比较好理解。 tcp不记录次数和时长，但服务器在外部可以记录，到次数 或者时间就可以关闭。 域名分片那里表示不理解，如果多个域名指向的是同一台 机器的话，就算请求过来了，还是缓解不了被阻塞的问题 吧？ 作者回复: 比如域名分片开了三个域名，那么客户端就可以 并发18个连接，这样它就可以用比一个域名多三倍的连接来 收发数据，效果肯定会好一些。 虽然实际上还有可能存在阻塞，但因为并发多了，总体上会变好。 当然，这只方便了客户端，但加大了服务器的负担。 老师，请问高并发请求和并发连接有什么关系吗？ 负载均衡解决高并发问题是并发连接吗？ 作者回复: “高并发请求”是服务器端的概念，意思是同时 有多个客户端连接服务器。 课程里的“并发连接”是客户端的概念，意思是一个浏览器 并发多个连接，访问服务器。 负载均衡是服务器端的概念，就是把大量的客户端连接均匀 分散到集群里的多台服务器 比方说我在电脑A上用游览器访问服务 器，这时候建立了长连接，我刷新页面用的是同一个长连 接，那如果我新开一个空白页面，同样访问服务器，这时 候用的连接和前边的还是同一个吗？(假设之前的连接没 有关闭)，如果我是在电脑B上同样访问服务器，和之前…作者回复: 1.在一个浏览器里对同一个网站，应该是复用长 连接，所以新的空白页面就会用刚才的连接收发数据。 2.换了电脑、换了浏览器，长连接当然就不存在了，它只能 在当前浏览器里生效，所以就要重新建立连接。 18丨四通八达 http的重定向和跳转重定向 ​ 点击页面“链接”时的跳转是怎样的呢？​ 浏览器首先要解析链接文字里的URI，再用这个URI发起一个新的HTTP请求，获取取响应报文后 就会切换显示内容，渲染出新 URI 指向的页面。这样的跳转动作是由浏览器的使用者主动发起的，可以称为“主动跳转”，但还有一类跳转是由服务器来发起的，浏 览器使用者无法控制，相对地就可以称为“被动跳转”，这 在 HTTP 协议里有个专门的名词，叫做“重定向”（Redirection）。 18-1 重定向的过程 重定向的过程“用户无感知”，举例查看响应如下： 从图中可看出，这次“重定向”实际发送了两次HTTP请求，第一个请求返回了302，第二个请求被重定向到了“/index.html”。 再来看看第一个请求返回的响应报文： 这里出现了一个新的头字段“Location: /index.html”，它就是301/302重定向跳转的秘密所在。 “Location”字段属于响应字段，必须出现在响应报文 里。但只有配合 301/302 状态码才有意义，它标记了服务器要求重定向的 URI，这里就是要求浏览器跳转到“index.html”。 浏览器收到 301/302 报文，会检查响应头里有没 有“Location”。如果有，就从字段值里提取出 URI，发出 新的 HTTP 请求，相当于自动替我们点击了这个链接。 在“Location”里的 URI 既可以使用绝对 URI，也可以使 用相对 URI。所谓“绝对 URI”，就是完整形式的 URI，包 括 scheme、host:port、path 等。所谓“相对 URI”，就 是省略了 scheme 和 host:port，只有 path 和 query 部 分，是不完整的，但可以从请求上下文里计算得到。 注意，在重定向时如果只是在站内跳转，你可以放心地使用相对 URI。但如果要跳转到站外，就必须用绝对 URI（包含http://）。 如果 301/302 跳转时没有 Location 字段会怎么样呢？ 18-2 重定向状态码​ 常见的重定向状态码就是 301 和 302，另外还有几个不太常见的，例如 303、307、308 等，有的浏览器和服务器可能不支持，慎用！ 301俗称“永久重定向”（Moved Permanently），意思 是原 URI 已经“永久”性地不存在了，今后的所有请求都必须改用新的 URI。 浏览器看到 301，就知道原来的 URI“过时”了，就会做适 当的优化。比如历史记录、更新书签，下次可能就会直接用 新的 URI 访问，省去了再次跳转的成本。搜索引擎的爬虫看到 301，也会更新索引库，不再使用老的 URI。 302俗称“临时重定向”（“Moved Temporarily”），意思是原 URI 处于“临时维护”状态，新的 URI 是起“顶 包”作用的“临时工”。 浏览器或者爬虫看到 302，会认为原来的 URI 仍然有效， 但暂时不可用，所以只会执行简单的跳转页面，不记录新的 URI，也不会有其他的多余动作，下次访问还是用原 URI。 303 See Other：类似 302，但要求重定向后的请求改为 GET 方法，访问一个结果页面，避免 POST/PUT 重复操作。 307 Temporary Redirect：类似 302，但重定向后请求 里的方法和实体不允许变动，含义比 302 更明确。 308 Permanent Redirect：类似 307，不允许重定向后 的请求变动，但它是 301“永久重定向”的含义。 18-3 重定向的应用场景 我们可以利用重定向在服务器端拥有主动权，控制浏览器的行为。使用重定向跳转，核心是要理解“重定向”和“永久 / 临时”这两个关键词。 什么时候需要重定向？ 一个常见的原因就是“资源不可用”，需要用另一个新的 URI 来代替。 至于不可用的原因那就很多了。例如域名变更、服务器变 更、网站改版、系统维护，这些都会导致原 URI 指向的资源 无法访问，为了避免出现 404，就需要用重定向跳转到新的 URI，继续为网民提供服务。 另一个原因就是“避免重复”，让多个网址都跳转到一个 URI，增加访问入口的同时还不会增加额外的工作量。 例如，有的网站都会申请多个名称类似的域名，然后把它们 再重定向到主站上。 决定要实行重定向后接下来要考虑的就是“永久”和“临 时”的问题了，也就是选择 301 还是 302。 301 的含义是“永久”的。 如果域名、服务器、网站架构发生了大幅度的改变，比如启 用了新域名、服务器切换到了新机房、网站目录层次重构， 这些都算是“永久性”的改变。原来的 URI 已经不能用了， 必须用 301“永久重定向”，通知浏览器和搜索引擎更新到 新地址，这也是搜索引擎优化（SEO）要考虑的因素之一。 302 的含义是“临时”的。 原来的 URI 在将来的某个时间点还会恢复正常，常见的应用 场景就是系统维护，把网站重定向到一个通知页面，告诉用户过一会儿再来访问。 另一种用法就是“服务降级”，比如在双十一促销的时候，把订单查询、领积分等不重要的功能 入口暂时关闭，保证核心服务能够正常运行。 18-4 重定向的相关问题 第一个问题是“性能损耗”。很明显，重定向的机制决定了 一个跳转会有两次请求 - 应答，比正常的访问多了一次。 虽然 301/302 报文很小，但大量的跳转对服务器的影响也 是不可忽视的。站内重定向还好说，可以长连接复用，站外 重定向就要开两个连接，如果网络连接质量差，那成本可就 高多了，会严重影响用户的体验。 所以重定向应当适度使用，决不能滥用。 第二个问题是“循环跳转”。如果重定向的策略设置欠考虑，可能会出现“A=&gt;B=&gt;C=&gt;A”的无限循环，不停地在这个链路里转圈圈，后果可想而知。 所以 HTTP 协议特别规定，浏览器必须具有检测“循环跳 转”的能力，在发现这种情况时应当停止发送请求并给出错误提示。如下图： 18-5 小结 重定向是服务器发起的跳转，要求客户端改用新的 URI 重新发送请求，通常会自动进行，用户是无感知的； 301/302 是常用的重定向状态码，分别是“永久重定 向”和“临时重定向”； 响应头字段 Location 指示了要跳转的 URI，可以用绝对 或相对的形式； 重定向可以把一个 URI 指向另一个 URI，也可以把多个 URI 指向同一个 URI，用途很多； 使用重定向时需要当心性能损耗，还要避免出现循环跳转。 18-6 课下作业 301 和 302 非常相似，试着结合第 12 讲，用自己的理 解再描述一下两者的异同点。 你能结合自己的实际情况，再列出几个应当使用重定向的 场景吗？ 18-7 延伸知识 重定向报文里还可以用Refresh字段，实现延时重定向，例如“Refresh: 5; url=xxx”告诉浏览器5秒钟后再跳转。 与跳转有关的还有一个“Referer”和“Referer-Policy”（注意前者是个拼写错误，但已经“将错就错”），表示浏览器跳转的来源（即引用地址），可用于统计分析和防盗链。 301/302重定向是由浏览器执行的，对于服务器来说可以称为“外部重定向”，相应的也就有服务器的“内部重定向”，直接在服务器内部跳转URI，因为不会发出HTTP请求，所以没有额外的性能损失。 19丨让我知道你是谁 http的cookie机制19-1 什么是cookie HTTP的Cookie机制相当于是服务器给每个客户端都贴上一张小纸条，上面写了一些只有服务器才能理解的数据，需 要的时候客户端把这些信息发给服务器，服务器看到 Cookie，就能够认出对方是谁了。 定义：Cookie 就是服务器委托浏览器存储在客户端里的一些数据，而这些数据通常都会记录用户的关键识别信息。 19-2 cookie的工作过程 那么，Cookie 这张小纸条是怎么传递的呢？ 这要用到两个字段：响应头字段Set-Cookie和请求头字段Cookie。 当用户通过浏览器第一次访问服务器的时候，服务器肯定是不知道他的身份的。所以，就要 创建一个独特的身份标识数据，格式是“key=value”，然后放进 Set-Cookie 字段里， 随着响应报文一同发给浏览器。 浏览器收到响应报文，看到里面有 Set-Cookie，知道这是服务器给的身份标识，于是就保 存起来，下次再请求的时候就自动把这个值放进 Cookie 字段里发给服务器。 因为第二次请求里面有了 Cookie 字段，服务器就知道这个用户不是新人，之前来过，就可 以拿出 Cookie 里的值，识别出用户的身份，然后提供个性化的服务。 不过因为服务器的“记忆能力”实在是太差，一张小纸条经常不够用。所以，服务器有时会 在响应头里添加多个 Set-Cookie，存储多个“key=value”。但浏览器这边发送时不需要 用多个 Cookie 字段，只要在一行里用“;”隔开就行。 这个过程如下图： 从这张图中我们也能够看到，Cookie 是由浏览器负责存储的，而不是操作系统。所以，它 是“浏览器绑定”的，只能在本浏览器内生效。换个浏览器或者换台电脑，这个Cookie都会失效。 【举例说明】首先访问页面时服务器会设置两个Cookie： 然后刷新这个页面，浏览器就会在请求头里自动送出 Cookie，服务器就能认出你了： 19-3 cookie的属性​ 需要在“key=value”外再用一些手段来保护记录用户的关键识别信息的Cookie数据，防止外泄或窃取，这些手段就是 Cookie 的属性。 19-3-1 有哪些常见的cookie属性​ 首先，我们应该设置 Cookie 的生存周期，也就是它的有效期，让它只能在一段时间内可 用，就像是食品的“保鲜期”，一旦超过这个期限浏览器就认为是 Cookie 失效，在存储里删除，也不会发送给服务器。 Cookie 的有效期可以使用 Expires 和 Max-Age 两个属性来设置。 “Expires”俗称“过期时间”，用的是绝对时间点，可以理解为“截止日 期”（deadline）。 “Max-Age”用的是相对时间，单位是秒，浏览器用收到报文的时间 点再加上 Max-Age，就可以得到失效的绝对时间。 Expires 和 Max-Age 可以同时出现，两者的失效时间可以一致，也可以不一致，但浏览器 会优先采用 Max-Age 计算失效期。 其次，我们需要设置 Cookie 的作用域，让浏览器仅发送给特定的服务器和 URI，避免被其他网站盗用。 作用域的设置比较简单，“Domain”和“Path”指定了 Cookie 所属的域名和路径，浏览器在发送 Cookie 前会从 URI 中提取出 host 和 path 部分，对比 Cookie 的属性。如果不满足条件，就不会在请求头里发送 Cookie。 使用这两个属性可以为不同的域名和路径分别设置各自的 Cookie，比如“/19-1”用一个 Cookie，“/19-2”再用另外一个 Cookie，两者互不干扰。不过现实中为了省事，通常 Path 就用一个“/”或者直接省略，表示域名下的任意路径都允许使用 Cookie，让服务器 自己去挑。 最后要考虑的就是Cookie 的安全性了，尽量不要让服务器以外的人看到。 属性“HttpOnly”会告诉浏览器，此 Cookie 只能通过浏览器 HTTP 协议传输，禁止其他 方式访问，浏览器的 JS 引擎就会禁用 document.cookie 等一切相关的 API，脚本攻击也 就无从谈起了。 另一个属性“SameSite”可以防范“跨站请求伪造”（XSRF）攻击，设置 成“SameSite=Strict”可以严格限定 Cookie 不能随着跳转链接跨站发送， 而“SameSite=Lax”则略宽松一点，允许 GET/HEAD 等安全方法，但禁止 POST 跨站发 送。 还有一个属性叫“Secure”，表示这个 Cookie 仅能用 HTTPS 协议加密传输，明文的 HTTP 协议会禁止发送。但 Cookie 本身不是加密的，浏览器里还是以明文的形式存在。 19-3-2 浏览器中查看cookie的方式 在Chrome开发者工具的“Network-Cookies”可以看到单个页面Cookie的各种属性。 在“Application”面板里则能够方便地看到全站的所有Cookie。 19-4 cookie的应用 Cookie 最基本的一个用途就是身份识别，保存用户的登录信息，实现会话事务。 比如，你用账号和密码登录某电商，登录成功后网站服务器就会发给浏览器一个 Cookie， 内容大概是“name=yourid”，这样就成功地把身份标签贴在了你身上。 之后你在网站里随便访问哪件商品的页面，浏览器都会自动把身份 Cookie 发给服务器，所 以服务器总会知道你的身份，一方面免去了重复登录的麻烦，另一方面也能够自动记录你的 浏览记录和购物下单（在后台数据库或者也用 Cookie），实现了“状态保持”。 Cookie 的另一个常见用途是广告跟踪。 你上网的时候肯定看过很多的广告图片，这些图片背后都是广告商网站（例如 Google）， 它会“偷偷地”给你贴上 Cookie 小纸条，这样你上其他的网站，别的广告就能用 Cookie 读出你的身份，然后做行为分析，再推给你广告。 这种 Cookie 不是由访问的主站存储的，所以又叫“第三方 Cookie”（third-party cookie）。如果广告商势力很大，广告到处都是，那么就比较“恐怖”了，无论你走到哪 里它都会通过 Cookie 认出你来，实现广告“精准打击”。 为了防止滥用 Cookie 搜集用户隐私，互联网组织相继提出了 DNT（Do Not Track）和 P3P（Platform for Privacy Preferences Project），但实际作用不大。 19-5 小结​ 虽然现在已经出现了多种 Local Web Storage 技术，能够比 Cookie 存储更多的数据，但 Cookie 仍然是最通用、兼容性最强的客户端数据存储手段。 Cookie 是服务器委托浏览器存储的一些数据，让服务器有了“记忆能力”； 响应报文使用 Set-Cookie 字段发送“key=value”形式的 Cookie 值； 请求报文里用 Cookie 字段发送多个 Cookie 值； 为了保护 Cookie，还要给它设置有效期、作用域等属性，常用的有 Max-Age、 Expires、Domain、HttpOnly 等； Cookie 最基本的用途是身份识别，实现有状态的会话事务。 19-6 课下作业 如果 Cookie 的 Max-Age 属性设置为 0，会有什么效果呢？ 回答一： 设置为0，服务器0秒就让Cookie失效，即立即失效，即便这个 Cookie 已存在于浏览器中，且尚未过期，服务器不存Cookie。 回答二： 立即失效，即每次访问都会重新设置cookie Cookie 的好处已经很清楚了，你觉得它有什么缺点呢？ 回答一： 好处：方便了市民 缺点：方便了黑客 回答二： 安全性问题，还有就是隐私的烦恼 19-7 延伸知识 浏览器对Cookie的数量和大小也都有现在，不允许无限存储，一般总大小不能超过4K。 如果不指定Expires或Max-Age属性，那么Cookie仅在浏览器运行时有效，一旦浏览器关闭就会失效，这被称为会话Cookie（session cookie）或内存Cookie（in-memory cookie），在Chrome里过期时间会显示为“Session”或“N/A”。 XSS（跨站脚本）攻击，是指第三方的JS代码读取到浏览器A网站的Cookie然后冒充我去访问A网站吗；XSRF（跨站请求伪造）攻击，指浏览器从A网站跳转到B网站是会带上B网站的Cookie。 作者再讲解广告追踪： 网站的页面里会嵌入很多广告代码，里面就会访问广告商，在浏览器里存储 广告商的cookie。 你换到其他网站，上面也有这个广告商的广告代码，因为都是一个广告商网站，自然就能够读取 之前设置的cookie，也就获得了你的信息。 rfc里有说明，如果max-age &lt;=0，统一按0算，立即过期。 20丨生鲜速递 http的缓存控制​ 缓存（Cache）是计算机领域里的一个重要概念，是优化系统性能的利器。​ 可以避免多次请求 - 应答的通信成本，节约网络带宽，也可以加快响应速度。 20-1 服务器的缓存控制 “生鲜速递”的案例翻译成HTTP就是： 浏览器发现缓存无数据，于是发送请求，向服务器获取资源； 服务器响应请求，返回资源，同时标记资源的有效期； 浏览器缓存资源，等待下次重用。 实验案例如图所示： 服务器标记资源有效期使用的头字段是“**Cache-Control**”，里面的值“**max-age=30**”就是资源的有效时间，相当于告诉浏览器，“这个页面只能缓存 30 秒，之后就 算是过期，不能用。” “Cache-Control”字段里的“max-age”和上一讲里 Cookie 有点像，都是标记资源的 有效期。 但必须注意，这里的 max-age 是“生存时间”（又叫“新鲜度”“缓存寿命”，类似 TTL，Time-To-Live），时间的计算起点是响应报文的创建时刻（即 Date 字段，也就是离开服务器的时刻），而不是客户端收到报文的时刻，也就是说包含了在链路传输过程中所有节点所停留的时间。 “max-age”是 HTTP 缓存控制最常用的属性，此外在响应报文里还可以用其他的属性来 更精确地指示浏览器应该如何使用缓存： no_store：不允许缓存，用于某些变化非常频繁的数据，例如秒杀页面； 生鲜速递：买来的西瓜不允许放进冰箱，要么立刻吃，要么立刻扔掉 no_cache：它的字面含义容易与 no_store 搞混，实际的意思并不是不允许缓存，而是可以缓存，但在使用之前必须要去服务器验证是否过期，是否有最新的版本； 生鲜速递：可以放进冰箱，但吃之前必须问超市有没有更新鲜的，有就吃超市里的 must-revalidate：又是一个和 no_cache 相似的词，它的意思是如果缓存不过期就可以 继续使用，但过期了如果还想用就必须去服务器验证。 生鲜速递 可以放进冰箱，保鲜期内可以吃，过期了就要问超市让不让吃 服务器的缓存控制策略的流程图： 20-2 客户端的缓存控制 当你点“刷新”按钮的时候，发现缓存30秒不起作用，这是因为浏览器会在请求头里加一个“Cache-Control: max-age=0”。 因为 max-age 是“生存时间”，max-age=0 的意思就是“我要一个最最新鲜 的西瓜”，而本地缓存里的数据至少保存了几秒钟，所以浏览器就不会使用缓存，而是向服 务器发请求。服务器看到 max-age=0，也就会用一个最新生成的报文回应浏览器。 Ctrl+F5 的“强制刷新”又是什么样的呢？ 它其实是发了一个“Cache-Control: no-cache”，含义和“max-age=0”基本一样，就 看后台的服务器怎么理解，通常两者的效果是相同的。 点击浏览器的“前进”“后退”按钮，会发现“from disk cache”字样，意思是没有发送网络请求，而是读取的磁盘上的缓存。 另外，如果用第 18 讲里的重定向跳转功能，也可以发现浏览器使用了缓存： 以上几个操作与刷新有什么区别呢？ 在“前进”“后退”“跳转”这些重定向动作中浏览器不会“夹带私货”， 只用最基本的请求头，没有“Cache-Control”，所以就会检查缓存，直接利用之前的资 源，不再进行网络通信。 20-2 条件请求 浏览器用“Cache-Control”做缓存控制只能是刷新数据，不能很好地利用缓存数据，又因 为缓存会失效，使用前还必须要去服务器验证是否是最新版。 那么该怎么做呢？ 浏览器可以用两个连续的请求组成“验证动作”：先是一个 HEAD，获取资源的修改时间 等元信息，然后与缓存数据比较，如果没有改动就使用缓存，节省网络流量，否则就再发一 个 GET 请求，获取最新的版本。 但上面这种两个请求网络成本太高了，所以 HTTP 协议就定义了一系列“If”开头的“条件请求”字段，专门用来检查验证资源是否过期，把两个请求才能完成的工作合并在一个请求里 做。而且，验证的责任也交给服务器，浏览器只需“坐享其成”。 条件请求一共有5 个头字段，我们最常用的是“if-Modified-Since”和“If-NoneMatch”。需要第一次的响应报文预先提供“Last-modified”和“ETag”，然后 第二次请求时就可以带上缓存里的原值，验证资源是否是最新的。 如果资源没有变，服务器就回应一个“304 Not Modified”，表示缓存依然有效，浏览器 就可以更新一下有效期，然后放心大胆地使用缓存了。 “Last-modified”就是文件的最后修改时间。 ETag 是“实体标签”（Entity Tag）的缩写，是资源的一个唯一标识，主要是用来解决修 改时间无法准确区分文件变化的问题。 比如，一个文件在一秒内修改了多次，但因为修改时间是秒级，所以这一秒内的新版本无法 区分。 再比如，一个文件定期更新，但有时会是同样的内容，实际上没有变化，用修改时间就会误 以为发生了变化，传送给浏览器就会浪费带宽。 使用 ETag 就可以精确地识别资源的变动情况，让浏览器能够更有效地利用缓存。 ETag 还有“强”“弱”之分。 强 ETag 要求资源在字节级别必须完全相符，弱 ETag 在值前有个“W/”标记，只要求资 源在语义上没有变化，但内部可能会有部分发生了改变（例如 HTML 里的标签顺序调整， 或者多了几个空格）。 实验案例：为资源增加了 ETag 字段，刷新页面时浏览器就会 同时发送缓存控制头“max-age=0”和条件请求头“If-None-Match”，如果缓存有效服 务器就会返回 304： 20-3 小结 缓存是优化系统性能的重要手段，HTTP 传输的每一个环节中都可以有缓存； 服务器使用“Cache-Control”设置缓存策略，常用的是“max-age”，表示资源的有 效期； 浏览器收到数据就会存入缓存，如果没过期就可以直接使用，过期就要去服务器验证是 否仍然可用； 验证资源是否失效需要使用“条件请求”，常用的是“if-Modified-Since”和“IfNone-Match”，收到 304 就可以复用缓存里的资源； 验证资源是否被修改的条件有两个：“Last-modified”和“ETag”，需要服务器预先 在响应报文里设置，搭配条件请求使用； 浏览器也可以发送“Cache-Control”字段，使用“max-age=0”或“no_cache”刷 新数据。 20-4 课下作业 Cache 和 Cookie 都是服务器发给客户端并存储的数据，你能比较一下两者的异同吗？ 回答一： 相同点：都会保存到浏览器中，并可以设置过期时间。 不同点： 1. Cookie 会随请求报文发送到服务器，而 Cache 不会，但可能会携带 if-ModifiedSince（保存资源的最后修改时间）和 If-None-Match（保存资源唯一标识） 字段来验证 资源是否过期。 回答二： Cookie和Cache的相同点：都存储在浏览器端 不同点：服务器端负责判断Cache的有 效性，浏览器端负责判断Cookie的有效性 回答三： cookie是服务端为了快速辨识客户端身份，保存在客户端的键值对缓存； cache是客户端为了避免不必要网络请求，加快响应速度，存储在本地的服务端内容。 两者的目的、作用不同。 即使有“Last-modified”和“ETag”，强制刷新（Ctrl+F5）也能够从服务器获取最新 数据（返回 200 而不是 304），请你在实验环境里试一下，观察请求头和响应头，解释 原因。 回答一： 发现强制刷新后请求头中 没有了 If-None-Match ，而且 CacheControl: no-cache 。没有条件请求头，那么服务器就无法处理缓存，就只能返回最新的数据。 回答二： 强制刷新，请求头里有Pragma: no-cache和Cache-Control: no-cache，没有IfModified-Since/If-None-Match，这个Pragma: no-cache的意思是禁用缓存 回答三： 强制刷新是因为请求头里的 If-Modified-Since 和 If-None-Match 会被清空所以会返 回最新数据 20-5 延伸知识 “no-cache”属性可以理解为“max-age=0,must-revalidate”。 如果响应报文里提供了“Last-modified”，但没有“Cache-Control”或“Expires”，浏览器会使用“启发”（Heuristic）算法计算一个缓存时间，在RFC里的建议是：(Date - Last-modified) * 10%。 弱ETag是服务器更新时自己判断本次的更新有没有语义的变化，如果语义有变化 就重新生成一个ETag，如果没有变化不重新生成直接使用原来的。 强etag和etag的流程都是一样的，只是计算的方式不同，（即判断是否发生变化的方式 不同）。 既然Etag的算法比较复杂，需要占用服务器资源，那么，实际上服务器会使用Etag 吗？看到有的资料说服务器很少会用到Etag，这个说法正确吗？作者回复: Nginx和Apache都有etag，但算法不同，但都不会用特别消耗计算资源的算法。 其他的web服务器就不太清楚了。 nocache，每次使用前都需要去浏览器问一下有没有过期，这不也是一次请求吗？ 那不和没有缓存一个意思吗？ 作者回复: 不一样，如果服务器返回304，是一个很小的报文，这样浏览器就可以直接重用缓存里 的数据，可以节约传输带宽。 nostore每次都会传输完整的报文，成本高。 这个缓存是用在静态资源上的么?还是生命周期较长的动态资源也可以用啊?使用时 需要在服务端或者nginx上做编码处理么?比如说Etag去缓冲中校验下是否存在后响应给浏 览器。 作者回复: 只要有cache-control，指定了生命周期，就都可以缓存。 静态资源是肯定可以缓存的，动态资源如果指定max-age=xxx，当然也可以用。 etag的算法可以自己定，条件请求时就要计算比较，注意这是在服务器上，不是缓存，而是直接 对资源进行计算，不变就返回304.","categories":[{"name":"HTTP","slug":"HTTP","permalink":"https://scarlett9354.github.io/categories/HTTP/"}],"tags":[{"name":"http","slug":"http","permalink":"https://scarlett9354.github.io/tags/http/"},{"name":"https","slug":"https","permalink":"https://scarlett9354.github.io/tags/https/"}]},{"title":"React实战进阶45讲","slug":"React实战进阶45讲","date":"2021-04-28T07:26:18.000Z","updated":"2021-05-13T03:12:13.989Z","comments":true,"path":"2021/04/28/React实战进阶45讲/","link":"","permalink":"https://scarlett9354.github.io/2021/04/28/React%E5%AE%9E%E6%88%98%E8%BF%9B%E9%98%B645%E8%AE%B2/","excerpt":"","text":"1丨react出现的历史背景及特性介绍 1-1 react解决ui细节问题 1-2 react解决数据模型问题 1-3 小结 2丨以组件方式考虑ui的构建 2-1 将ui组织成组件树的形式 2-2 理解react组件 2-3 创建一个简单的组件: tab-select 2-4 受控组件 vs 非受控组件 2-5 创建组件要遵循什么样的原则? 3丨jsx的本质 不是模板引擎 而是语法糖 3-1 理解jsx 3-2 在jsx中使用表达式 3-3 jsx的优点 3-4 jsx的约定: 自定义组件必须以大写字母开头 4丨react组件的生命周期及其使用场景 5丨理解virtual dom及key属性的作用 5-1 理解 virtual dom 5-2 小结 6丨组件设计模式 高阶组件和函数作为子组件 6-1 高阶组件 (hoc) 6-2 函数作为子组件 7丨理解新的context api及其使用场景 7-1 理解context api的使用场景 7-2 context api的使用办法 (举例) 8丨使用脚手架工具创建react项目 8-1 为什么需要脚手架工具? 8-2 三种工具: create-react-app, codesandbox, rekit 9丨打包和部署 9-1 为什么需要打包? 9-2 使用webpack进行打包 10丨redux (1) 前端为何需要状态管理库 10-1 redux: js状态管理框架 10-2 redux特性 11丨redux (2) 深入理解store action reducer 11-1 理解store 11-2 理解action 11-3 理解reducer 11-4 整体看redux 11-5 理解combine-reducers 11-6 理解bind-action-creators 11-7 redux (它是独立于ui框架之外的状态管理框架) 整个流程代码演示 12丨redux (3) 在react中使用redux 12-1 connect 12-2 具体在react中使用redux 13丨redux (4) 理解异步action以及redux中间件 13-1 redux异步请求 13-2 redux中间件 (middleware) 13-3 demo: 如何通过redux异步action发出异步请求? 14丨redux (5) 如何组织action和reducer 14-1 [标准] 形式redux action的问题 14-2 推荐新的方式: 单个action和reducer放在同一个文件中 14-3 demo 15丨redux (6) 理解不可变数据 (immutability) 15-1 不可变数据 15-2 为何需要不可变数据 15-3 如何操作不可变数据 16丨react router (1) 路由不只是页面切换 更是代码组织方式 16-1 为什么需要路由? 16-2 路由实现的基本架构 16-3 react router的实现 16-4 react router的特性 16-5 三种路由实现方式 16-6 基于路由配置进行资源组织 16-7 react router的核心api 17丨react router (2) 参数定义以及嵌套路由的使用场景 17-1 通过url传递参数 17-2 嵌套路由 18丨ui组件库对比和介绍 18-1 ui组件库的对比 18-2 选择ui库的考虑因素 19丨使用next (使用它创建react同构应用) 19-1 什么是同构应用? 19-2 如何使用nextjs开发服务器端渲染的react应用 19-3 在页面中使用其它react组件 19-4 使用link实现同构路由 19-5 动态加载页面 (即lazy-load) 20丨使用jest和enzyme等工具进行单元测试 20-1 react让前端单元测试变得更加容易 20-2 单元测试涉及的工具 21丨常用开发调试工具 21-1 eslint 21-2 prettier-强烈推荐 21-3 react devtool 21-4 redux devtool 22丨前端项目的理想架构即可维护 可扩展 可测试 易开发 易构建 22-1 易于开发 22-2 易于扩展 22-3 易于维护 22-4 易于测试 22-5 易于构建 23丨拆分复杂度 (1) 按领域模型 (feature) 组织代码 降低耦合度 23-1 将业务逻辑拆分成高内聚松耦合的模块 1丨react出现的历史背景及特性介绍1-1 react解决ui细节问题 1个新概念：组件 用组件的方式去描述UI 4个必须API 单向数据流 完善的错误提示 1-2 react解决数据模型问题 传统MVC难以扩展和维护，为了解决这个问题，提出Flux架构，它是一种设计模式，核心思想是单向数据流： 流程描述： ​ 当UI(React Views)上发生用户的操作(User interactions)会产生一个Action，这个action会通过Dispatcher dispatch出去，然后由Store进行处理，store根据这个action来更新自己，因为我们的views是绑定在store上的，所以当store有任何变化时，它就会发生更新。 ​ Flux架构完全是建立在React始终以状态为基础来展示UI的，所以不需要关心细节就可以把views connect到一个store上。 Flux架构的衍生项目：Redux、Mobx 1-3 小结 传统Web UI开发的问题 React：始终整体刷新页面 Flux：单向数据流 2丨以组件方式考虑ui的构建2-1 将ui组织成组件树的形式 2-2 理解react组件 外部传进来的属性props + 内部维护的状态state = view React组件一般不提供方法，而是某种状态机 React组件可以理解为一个纯函数 单向数据绑定 2-3 创建一个简单的组件: tab-select 创建静态UI 一般就是由html去描述 考虑组件的状态组成 考虑状态是来自外部还是需要在内部去维护 考虑组件的交互方式 用户在内部进行了操作，如何暴露给外部使用 组件内部： 组件外部： 2-4 受控组件 vs 非受控组件 受控组件： 表单元素状态由使用者维护 非受控组件： 表单元素状态DOM自身维护 2-5 创建组件要遵循什么样的原则? 何时创建组件：单一职责原则 每个组件只做一件事 如果组件变得复杂，那么应该拆分成小组件 这样做有两个好处： (1) 可以把复杂度拆分到不同的地方去 (2) 可以提高性能：如果组件很大，一点变化可能就要导致整个大组件刷新，拆成小组件，只会出现小组件的刷新 数据状态管理：DRY原则 简言之，不要去做重复的状态保存。 能计算得到的状态就不要单独存储 比如：发请求，未收到响应时，数据为空，这时就知道处于loading状态，而没必要存储loading的state 组件尽量无状态，所需数据通过props获取 3丨jsx的本质 不是模板引擎 而是语法糖3-1 理解jsx 不是模板语言，只是一种语法糖 在JavaScript代码中直接写html标记 本质：动态创建组件的语法糖，而且是用的JavaScript的语法 例1： createElement的参数： h1：标记的类型 null：传给它的属性 Hello, 和name：都是它的children 即，从第三个参数开始，都是这个元素的子元素。 例2： 3-2 在jsx中使用表达式 JSX本身也是表达式 1const element = &lt;h1&gt;Hello, world!&lt;/h1&gt; 在属性中使用表达式 1&lt;MyComponent foo=&#123;1 + 2 + 3 + 4&#125; /&gt; 延展属性 12const props = &#123;firstName: &#x27;Ben&#x27;, lastName: &#x27;Hector&#x27;&#125;const greeting = &lt;Greeting &#123;...props&#125; /&gt; 表达式作为子元素 1const element = &lt;li&gt;&#123;props.message&#125;&lt;/li&gt; 子元素是React组件的特殊属性，这个属性会传给children，作为子元素，这个返回值就需要是个可render的节点，如组件node、原生node或字符串。 3-3 jsx的优点 声明式创建界面的直观 比如有非常多的html标记，除了原生的，还有自己定义的，可以很方便地去描述UI 代码动态创建界面的灵活 什么时候创建节点，这个节点什么时候应该消失，属性什么时候发生变化 无需学习新的模板语言 3-4 jsx的约定: 自定义组件必须以大写字母开头 React认为小写的tag是原生DOM节点，如div 大写字母开头为自定义组件 JSX标记可以直接使用属性语法，例如&lt;menu.Item /&gt; 这种语法不需要遵循大写字母开头的约定 4丨react组件的生命周期及其使用场景 三个阶段：Render阶段、Pre-commit阶段、Commit阶段。 commit是React把当前的状态映射到DOM时，需要实际地更新DOM节点，更新DOM节点就称之为commit。 在pre-commit阶段还没真正地更新DOM，但是在这个阶段可以读取DOM节点的内容。 三个类型： 创建时 4.1 constructor ​ 标准的JS类的构造函数，一个组件在更新到界面上之前，首先需要创建出来，特点： 用于初始化内部状态，很少使用 唯一可以直接修改state的地方 this.state=xxx 4.2 getDerivedStateFromProps ​ React16.3新引入的api，提供了一个最佳实践 - 如果从外部属性来初始化内部状态。在这个方法里返回的状态都可以merge到当前的状态上。 使用场景：当state需要从props初始化时使用 尽量不要使用（不推荐使用）：维护两者状态一致性会增加复杂度 每次render都会调用 因为它是用来取代componentWillReceiveProps时使用的 典型场景：表单控件获取默认值 4.3 render ​ 描述UI DOM结构的地方，是组件唯一必须定义的生命周期方法。 4.4 componentDidMount UI渲染完成后调用 这时可以安全地操作DOM节点，以及触发ajax请求去获取外部的资源 只执行一次 典型场景：获取外部资源 更新时 当这个组件有一个新的属性props传进来或者内部调用setState方法修改了内部状态state或者调用forceUpdate强制组件刷新时发生。 4.2 getDerivedStateFromProps 4.5 shouldComponentUpdate ​ 它可以告诉组件是否真正需要render，这是一个可以用户介入的过程，比如当props发生变化时，我们可以判断界面的UI不需要变化，这时就可以告诉React组件不需要update，只需要在这个方法中返回false即可。当返回true时，React才继续下面的流程 - render。 决定Virtual DOM是否要重绘 一般可以由PureComponent自动实现 它可以判断当前的props和之前的props、当前的state和之前的state是否有变化，如果没有变化，它会自动组织React重新更新 典型场景：性能优化 4.3 render ​ 计算背后的虚拟DOM，这个DOM用来维持内部UI的状态，可以计算一些diff等等。 4.6 getSnapshotBeforeUpdate ​ React16.3新引入的api 在页面render之前调用，state已更新（从外部props传进来） 典型场景：获取render之前的DOM状态 举例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import React, &#123; PureComponent &#125; from &quot;react&quot;;import PropTypes from &quot;prop-types&quot;;import &quot;./SnapshotSample.css&quot;;export default class SnapshotSample extends PureComponent &#123; state = &#123; messages: [] &#125;; handleNewMessage() &#123; this.setState((prev) =&gt; (&#123; messages: [`msg $&#123;prev.messages.length&#125;`, ...prev.messages] &#125;)); &#125; componentDidMount() &#123; for (let i = 0; i &lt; 20; i++) this.handleNewMessage(); this.interval = window.setInterval(() =&gt; &#123; if (this.state.messages.length &gt; 200) &#123; window.clearInterval(this.interval); return; &#125; this.handleNewMessage(); &#125;, 1000); &#125; componentWillUnmount() &#123; window.clearInterval(this.interval); &#125; getSnapshotBeforeUpdate() &#123; return this.rootNode.scrollHeight; &#125; componentDidUpdate(prevProps, prevState, prevScrollHeight) &#123; const scrollTop = this.rootNode.scrollTop; if (scrollTop &lt; 5) return; this.rootNode.scrollTop = scrollTop + (this.rootNode.scrollHeight - prevScrollHeight); &#125; render() &#123; return ( &lt;div className=&quot;snapshot-sample&quot; ref=&#123;(n) =&gt; (this.rootNode = n)&#125;&gt; &#123;this.state.messages.map((msg) =&gt; ( &lt;div&gt;&#123;msg&#125;&lt;/div&gt; ))&#125; &lt;/div&gt; ); &#125;&#125; 1234567.snapshot-sample &#123; overflow: auto; height: 100px; widows: 300px; border: 1px solid #eee; padding: 20px;&#125; 4.7 componentDidUpdate 每次UI更新时被调用 我们已知React组件在外部props或内部state变化时都会重新渲染，它始终会整体刷新，所以UI的更新非常频繁，这个方法可以捕获每次更新 典型场景：页面需要根据props变化重新获取数据 比如说，当前文章是通过id参数决定显示什么内容，可以在这个方法里，根据不同的id获取到的文章内容，再更新到UI上。 卸载时 4.8 componentWillUnmount 组件移除时被调用（从界面上消失时销毁自己） 典型场景：释放资源 4.9 小结 理解React组件的生命周期方法 理解生命周期的使用场景 5丨理解virtual dom及key属性的作用5-1 理解 virtual dom 它是JSX运行的基础 React组件在内部维护了一套虚拟DOM的状态，这套DOM状态最终会映射到真实的DOM节点上，当虚拟DOM的状态发生变化时，内部需要计算虚拟DOM之间的区别来产生一个diff，最终在真实的DOM节点上并不是真实地刷新所有的DOM，而是只把diff的部分用一种高效的方式更新到UI上，从而能够保证性能 虚拟DOM是如何工作的？ - 原理 广度优先分层比较 拿到前后两个DOM树，一层一层地比较，上图两个状态的区别： A和B两个节点顺序发生了变化，第三层D节点原来在B下面，移动到了下层节点，A节点由圆形的组件变成了方形的，表示它的组件类型发生了变化。针对这些不同的变化，React diff算法有不同的处理方式： 第一层：根节点开始比较 参考上图 发现两个节点完全一样，不做任何修改。 第二层：属性变化及顺序 参考上图 如果想知道A和B发生了顺序变化，需要给出唯一的标识，算法做的事情是交换两个节点的位置。 第三层：节点类型发生变化 React做的事情是直接把F节点删掉，创建一个新的节点G，并append到A上，不会去管F节点是否被其他地方用到。 节点跨层移动 参考最上面的图 D从B节点下面，移动到了下下层节点。React的diff算法会把D节点及它下面的子元素全部删除掉，再创建一个全新的D节点加到当前的DOM树上。 当节点跨层移动时，react的这种做法看上去性能有点低，但这种应用场景很少出现。 虚拟DOM的diff算法得以实现，基于两个假设： 组件的DOM结构是相对稳定的（很少发生跨层移动的场景） 类型相同的兄弟节点可以被唯一标识 这就是key的作用，不止用于消除warning，还能提高性能 5-2 小结 算法复杂度为O(n) - 线性的复杂度，性能高 虚拟DOM如何计算diff key属性的作用 6丨组件设计模式 高阶组件和函数作为子组件6-1 高阶组件 (hoc) 它是对已有组件的封装，形成新的组件，新组件会包含一些自己的应用逻辑，这些逻辑会产生一些新的状态，这个状态会传给已有的组件，因此高阶组件一般不会有自己的UI展现，而是只负责为它封装的组件提供额外的功能和数据。如图中绿色的组件： 高阶组件接受组件作为参数，返回新的组件。 1const EnhancedComponent = higherOrderComponent(WrappedComponent) 以定时器为例： 高阶组件withTimer.js： 1234567891011121314151617181920212223import React from &quot;react&quot;;export default function withTimer(WrappedComponent) &#123; return class extends React.Component &#123; state = &#123; time: new Date() &#125;; componentDidMount() &#123; this.timerID = setInterval(() =&gt; this.tick(), 1000); &#125; componentWillUnmount() &#123; clearInterval(this.timerID); &#125; tick() &#123; this.setState(&#123; time: new Date() &#125;); &#125; render() &#123; return &lt;WrappedComponent time=&#123;this.state.time&#125; &#123;...this.props&#125; /&gt;; &#125; &#125;;&#125; 在ChatApp.js中的应用： 1234567891011121314import React from &quot;react&quot;;import withTimer from &quot;../c06/withTimer&quot;;export class ChatApp extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h2&gt;&#123;this.props.time.toLocaleString()&#125;&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125;export default withTimer(ChatApp); 在CommentBox.js中的应用： 123456789101112import React from &quot;react&quot;;import withTimer from &quot;../c06/withTimer&quot;;export class CommentBox extends React.Component &#123; render() &#123; return ( &lt;div&gt;&#123;this.props.time.getTime()&#125;&lt;/div&gt; ); &#125;&#125;export default withTimer(CommentBox); 6-2 函数作为子组件 children函数 特点：render的内容由引用它的父组件决定，而不是子组件不停地增加功能来适配外部的使用场景。 举例： 子组件AdvancedTabSelector： 12345678910111213141516171819202122232425262728293031323334353637383940import React, &#123; PureComponent &#125; from &quot;react&quot;;import PropTypes from &quot;prop-types&quot;;export default class AdvancedTabSelector extends PureComponent &#123; static propTypes = &#123; value: PropTypes.object, options: PropTypes.array, onChange: PropTypes.func, children: PropTypes.func &#125;; static defaultProps = &#123; value: null, options: [], onChange: () =&gt; &#123;&#125;, children: () =&gt; &#123;&#125; &#125;; render() &#123; const &#123; options, value, onChange &#125; = this.props; return ( &lt;div className=&quot;tab-selector&quot;&gt; &lt;ul&gt; &#123;options.map(opt =&gt; ( &lt;li key=&#123;opt.value&#125; className=&#123;`tab-item $&#123; opt.value === this.props.value ? &quot;selected&quot; : &quot;&quot; &#125;`&#125; onClick=&#123;() =&gt; this.props.onChange(opt.value)&#125; &gt; &#123;opt.name&#125; &lt;/li&gt; ))&#125; &lt;/ul&gt; &#123;this.props.value &amp;&amp; this.props.children(this.props.value)&#125; &lt;/div&gt; ); &#125;&#125; 父组件AdvancedTabSelectorSample（使用者）: 使用者1： 123456789101112131415161718192021222324252627282930313233const colors = [ &#123; name: &quot;Red&quot;, value: &quot;red&quot; &#125;, &#123; name: &quot;Blue&quot;, value: &quot;blue&quot; &#125;, &#123; name: &quot;Orange&quot;, value: &quot;orange&quot; &#125;];export class AdvancedTabSelectorSample extends PureComponent &#123; state = &#123; color: null &#125;; render() &#123; return ( &lt;div&gt; &lt;h3&gt;Select color: &lt;/h3&gt; &lt;AdvancedTabSelector options=&#123;colors&#125; value=&#123;this.state.color&#125; onChange=&#123;c =&gt; this.setState(&#123; color: c &#125;)&#125; &gt; &#123;color =&gt; ( &lt;span style=&#123;&#123; display: &quot;inline-block&quot;, backgroundColor: color, width: &quot;40px&quot;, height: &quot;40px&quot; &#125;&#125; /&gt; )&#125; &lt;/AdvancedTabSelector&gt; &lt;/div&gt; ); &#125;&#125; 使用者2： 1234567891011121314151617181920212223const animals = [ &#123; name: &quot;Tiger&quot;, value: &quot;tiger&quot; &#125;, &#123; name: &quot;Elephant&quot;, value: &quot;elephant&quot; &#125;, &#123; name: &quot;Cow&quot;, value: &quot;cow&quot; &#125;];export class AdvancedTabSelectorSample extends PureComponent &#123; render() &#123; return ( &lt;div&gt; &lt;h3&gt;Select animal: &lt;/h3&gt; &lt;AdvancedTabSelector options=&#123;animals&#125; value=&#123;this.state.animal&#125; onChange=&#123;c =&gt; this.setState(&#123; animal: c &#125;)&#125; &gt; &#123;animal =&gt; ( &lt;img width=&quot;100px&quot; src=&#123;require(`../../images/$&#123;animal&#125;.png`)&#125; /&gt; )&#125; &lt;/AdvancedTabSelector&gt; &lt;/div&gt; ); &#125;&#125; 7丨理解新的context api及其使用场景7-1 理解context api的使用场景 它是React16.3新特性 解决的是组件之间通信的问题： 比如有些全局的状态需要很多个组件使用，但如果所有属性都一层层传递下来，会非常麻烦。目前redux和react-router已经非常重度依赖Context API，可见它的作用非常大。 下图是典型的Context API的使用场景： 解读： 左边是个组件树，这个组件树的很多个节点需要共享一个全局的上下文数据，根节点需要提供所有的上下文数据，下面无论哪个节点都可以通过Context API去访问这个全局的数据，而不管它在哪一层，都不需要上层节点给它传props，都可以自己去访问。 图上的节点有两种类型：根节点 - provide，下面使用context API的绿色节点 - consume。 具体代码： 解读： 首先定义了一个context，然后定义了一个provider，如果去给上下文设定一个值，下面是consume，来使用这个上下文。 创建上下文的语法：React.createContext(参数)，它接收一个参数，即这个上下文的值，可以是任意类型的数据，如object、数组、常量或字符串。 得到这个context对象，它有个Provider属性，这个Provider是个组件，可以接收一个参数value，是个属性，我们传给它的属性是什么，下面所有的子节点consume拿到的数据就是什么，当value发生change时，下面所有的子组件都会同步更新。 ThemedButton是个consume，这个button可以从上下文拿到当前的theme，自己决定如何展现这个theme。需要注意一点，consume一定在provider下面，层级上一定属于provider某一层的子组件。 上段代码的整体解读是如果我们的应用程序需要定义一个theme，它的theme是dark还是light，可以通过在根节点上设置这个值，然后下面的节点需要theme时都可以通过consume拿到。 7-2 context api的使用办法 (举例) 场景：点击按钮切换当前页面的显示语言 context API是把上下文的数据存在一个外部的状态中，这个外部状态不需要通过props传进来，而且可以通过consume直接拿到其中的数据。 1234567891011121314151617181920212223242526272829import React from &quot;react&quot;;const enStrings = &#123; submit: &quot;Submit&quot;, cancel: &quot;Cancel&quot;&#125;;const cnStrings = &#123; submit: &quot;提交&quot;, cancel: &quot;取消&quot;&#125;;// 先定义一个context，它可能有两种值 - 英文字符串enString和中文字符串cnString，先把默认值设置为英文的const LocaleContext = React.createContext(enStrings);// 再定义一个组件 - LocaleProvider，这个组件内部给切换语言增加了一个buttonclass LocaleProvider extends React.Component &#123; state = &#123; locale: cnStrings &#125;; // 点击button切换当前语言，当前语言是存在组件内部的一个状态locale toggleLocale = () =&gt; &#123; const locale = this.state.locale === enStrings ? cnStrings : enStrings; // 当state中locale发生变化后，Provider的value也相应变化，下面的所有子组件都会使用到更新后的value this.setState(&#123; locale &#125;); &#125;; render() &#123; return ( &lt;LocaleContext.Provider value=&#123;this.state.locale&#125;&gt; &lt;button onClick=&#123;this.toggleLocale&#125;&gt;切换语言&lt;/button&gt; &#123;this.props.children&#125; &lt;/LocaleContext.Provider&gt; ); &#125;&#125; 如何使用上面定义的Provider组件？ 12345678910111213141516// 取消和提交两个按钮，数据来源是上面定义的context，给它包个consume外围组件，负责通知下面的组件语言是否发生变化，变化了就需要重新renderclass LocaledButtons extends React.Component &#123; render() &#123; return ( &lt;LocaleContext.Consumer&gt; // 用到了“函数作为子组件”的设计模式，并不关心上下文的数据如何被下面的子元素去消费，至于作为属性还是子元素，怎样用都可以 &#123;(locale) =&gt; ( &lt;div&gt; &lt;button&gt;&#123;locale.cancel&#125;&lt;/button&gt; &amp;nbsp;&lt;button&gt;&#123;locale.submit&#125;&lt;/button&gt; &lt;/div&gt; )&#125; &lt;/LocaleContext.Consumer&gt; ); &#125;&#125; 实际使用时： 12345678910111213export default () =&gt; ( &lt;div&gt; // 是上面定义的组件，包含了切换语言这个button；下面包含了LocaledButtons，这里放的是需要切换上下文的UI组件 &lt;LocaleProvider&gt; &lt;div&gt; &lt;br /&gt; &lt;LocaledButtons /&gt; &lt;/div&gt; &lt;/LocaleProvider&gt; // 注意：我们用到的上下文的子组件必须包含在provider层级下面，如果放在它之外，这个buttons组件的数据来源只是它的默认值（点击按钮不会切换） &#123;/* &lt;LocaledButtons /&gt; */&#125; &lt;/div&gt;); 为什么不直接把数据定义到外部的对象中，直接从外部取不就可以了吗？ 答：如果放到外部的对象中，需要主动监听它的变化，因为外部数据并不属于组件内部的状态，当它发生变化时需要主动监听它，并调用forceUpdate去强制刷新。但如果通过context API，当数据发生变化，react会主动监听到这个变化，并通知下面的所有组件自动刷新。 8丨使用脚手架工具创建react项目8-1 为什么需要脚手架工具? 创建React Application去开发一个真实的项目，通常要引入多个技术栈： 需要用React做UI的开发 需要用Redux做状态的管理 需要用React/Router做路由的管理 需要用Babel将最新的JavaScript特性翻译成旧的JavaScript语法 需要用webpack进行打包 需要用Eslint做语法检查 看似只有6个技术栈，其实每个技术栈后面都有自己的生态圈，体现在npm的packages上，有非常多小package，所以创建一个新的application时，意味着要引入并了解几十个package，并会配置。 创建一个新的application，通常要先建一个文件夹，再建个package.json，然后把所有的依赖放进去，并设定它们需要的版本，再创建webpack的配置文件，需要创建所有的文件夹结构，这个过程其实是个可重用的过程，创建一次后，再创建第二个app，只需要改一些参数即可，这就需要脚手架工具帮助我们做这样的事情。 脚手架工具会预先定义好一个典型的项目，需要用到哪些工具、哪些类库、哪些配置，或者根据参数做些配置的调整，并生成项目。 8-2 三种工具: create-react-app, codesandbox, rekit Create React App fackbook推出create-react-app这个命令行工具，使我们能快速开始react开发。它整合了Babel、Webpack Config(用来做打包)、Testing(采用的jest)、Eslint。 它只是入门级的命名行工具，因为它采取的最简策略，它的package基本上都是项目必须要用的package，适合用来学习react或者开发简单的react app。 Rekit 在Create React App基础上，额外整合里更多的最佳实践，如： Redux React Router Less/Scss 做样式文件的编译 Feature Oriented Architecture 一种开发大型项目架构的实践，它可以把大项目的复杂度拆分成一个个小的feature，每个小feature都尽量保持独立，互相之间松耦合，便于开发出可扩展、可维护的web应用。 IDE 帮助更好地组件源代码，以及帮助做代码生成的工作。 Online: Codesandbox.io 在线的开发平台，不需要本地搭任何环境，在它的在线IDE里就能创建项目、编写代码。它支持react、vue和angular项目的创建。 这个IDE比较厉害的一点是，它的webpack打包是运行在浏览器端的（webpack通常运行在node环境下），安装依赖也都是在前端完成的，大大提高打包的速度。 使用步骤： 打开官网 点击OPEN REACT(或Create Sandbox)即可创建。 9丨打包和部署9-1 为什么需要打包? 编译ES6语法特性，编译JSX 因为这些语言、语法并不能被浏览器直接执行，而且需要考虑到兼容性问题，所以需要一些编译的工具把这些语法进行转换 整合资源，例如图片、外部的样式文件(Less/Sass)、svg、xml等 优化代码的体积 比如对变量名进行缩短、去除注释、去除空格、去除不必要的变量 9-2 使用webpack进行打包 它可以把项目中的所有资源进行整合，比如JavaScript、png、sass，对于每种资源，webpack都可以用插件的方式去载入对应的loader，这个loader能决定自己支持什么样的语法，loader的输出对应的就是可执行的JavaScript语言，可兼容多个平台、多个版本浏览器。 目前的脚手架工具都配置了较全面的打包配置，我们只需要做少量修改即可。 打包的注意事项： 设置nodejs环境为production 可以在scripts/build.js中设置环境变量process.env.BABEL_ENV=&#39;production&#39;和process.env.NODE_ENV=&#39;production&#39; 禁用开发时的专用代码，比如logger 根据环境变量决定哪些代码在哪个环境运行，比如redux的配置中，在store.js中指定了一个中间件redux-logger，这个中间件用来在控制台输出所有action的信息，显然这个只需要在开发时使用： 12345678const middlewares = [ thunk, router]if(process.env.NODE_ENV === &#x27;development&#x27;) &#123; const &#123; createLogger &#125; = require(&#x27;redux-logger&#x27;) const logger = createLogger(&#123;collapsed: true&#125;) middlewares.push(logger)&#125; 打包时，webpack会检测该条件，为false不会打包到最终结果中。 设置应用的根路径 在package.json中有个homepage属性，会告诉webpack，应用程序会部署在哪个路径下，对于github而言，如果部署到github pages，就是这样的路径：&quot;homepage&quot;: &quot;https://supnate.github.io/gt-demo&quot;；如果要部署到cdn，这里就是个cdn的路径，所以最终打包出的结果就能从这个路径开始去寻找其他的资源。 具体打包和部署 执行$ npm run build打包出bundle.js文件，所有的打包结果都会出现在build(我习惯用dist)目录下，只需要把这个js文件及其他资源部署到server上即可。 10丨redux (1) 前端为何需要状态管理库10-1 redux: js状态管理框架 React的组件是把state转换成DOM的结构，这是在组件内部发生的。 Redux是把这个状态移到了组件之外，把全局所有状态都放在一个全局的store中，Redux最核心的概念是，它全局只有一个唯一的store，这个store负责提供整个应用程序所有的状态，所有组件的状态都可以放在外部的store中，当store有任何变化，这个组件也相应更新，页面中不同的部分可能来自store中不同的节点。Redux store中的结构也是个tree的结构，跟组件的tree结构是映射的关系。 Redux核心的出发点是让组件间的通信变得更加容易： 从左图可以看到，假如没有一个全局的状态管理，组件间的通信会非常麻烦：一个父组件要把状态传递到子组件必须通过props一层一层传递下去，当一个子组件的状态发生变化时，想让父组件知道，它就必须暴露一个事件出去才能通信，也就是说它的组件通信的逻辑非常依赖组件的层次结构。 如果平级的两个节点想要通信，只能通过父节点中转的方式进行，所以Redux提供了一个解决方案：把store放在所有组件之外，所有的组件都和这个store进行通信，组件之间互相通信就会变得少一点，当store发生变化，组件就能拿到store数据，当组件内部有个user action要触发store变化，就直接去更新store，这其实是个单向数据流过程。 10-2 redux特性 Single Source of Truth 传统MVC架构下，一个页面有很多view和model，view和model之间是互相依赖、互相绑定的关系，view内部可能有自己的状态，在model中放业务逻辑的数据，一个model可能被多个view使用，一个view可能也会使用多个model，关系错综复杂，一旦发现哪里出现bug，想要追踪状态在哪里发生错误就非常困难。 Redux提供的这个SST，把所有状态都放在一个唯一的store中，它是状态的唯一来源，所有的view都依赖这个store，view内部也尽量没有自己的状态，当store中数据变化，view会得到更新，如果view上有个用户的操作，它会通过事件去通知store进行变化，这样使整个应用程序更加容易理解和追踪，当发生问题时，只需检查当前的状态是否正确即可。 可预测性 ​ 意思是Redux的状态非常稳定，它要产生一个新状态，一定是由一个action引起的，即state+action=new state，表示状态state若发生了变化，一定是由某个action触发的，会产生一个新的state，而不是在原来的state上做修改，这种特性也称之为immutability，即不可变数据，它也是Redux运行的一个基础。 纯函数更新store 要更新一个Redux的store，必须通过一个action触发，然后通过一个reducer函数去产生一个新的store。 纯函数是指它的输出结果完全取决于输入参数，函数的内部不依赖任何外部参数和资源，这样整个函数就是非常容易预测和测试。 11丨redux (2) 深入理解store action reducer11-1 理解store 代码层面，产生一个store只需要调用createStore函数，它接收一个reducer参数，reducer也就是一个纯函数： const store = createStore(reducer) store有三个方法： getState() 可以得到当前的数据 dispatch(action) 比如在UI上用户点击一个button，就会产生一个action，store可以把它dispatch出去给reducer subscribe(listener) 用来监听store的变化，当store有任何变化时，都会调用它的callback，即listener store的结构，如下图所示： store包含三部分： State 是真正的数据（它是个纯JavaScript对象） Dispatcher 是用来dispatch一个action的方法 Reducer 用来真正处理所有的action，也是真正地去更新store 11-2 理解action​ 它描述了一个行为的数据结构，比如有个todoList应用，想要增加一条todoItem，用一个action去描述的数据结构如下： 1234&#123; type: ADD_TODO, text: &#x27;Build my first Redux app&#x27;&#125; ​ 它指定一个数据类型即action的类型为ADD_TODO，通常是个常量的字符串，text用来描述要做的事情，所以这个action就描述了ADD_TODO的行为，它如何去触发的store的更新呢？通过reducer进行的。 11-3 理解reducer 它是个函数，接收两个参数：state - 之前的状态或者初始状态initialState、action。 需要注意一点，所有的reducer会接收到所有的action，也就是说一个action通过store dispatch出去，所有系统中定义的reducer都能接收到。 如果判断自己能否执行？通过action.type判断，符合这种类型就继续更新store(即返回一个新的store，包含了旧store的部分和要更新的部分)。下图使得更新后的store上多了一条新的数据，使所有绑定在store上的组件都得以更新。 11-4 整体看redux​ 底部UI部分有两个button，点击deposit存10元钱，形成一个Action，这个action被Dispatcher dispatch出去到Reducer，reducer处理这个action，从而形成一个新的State，意味着更新了store，而store发生变化之后会通知UI，UI上显示的值就会发生变化。点击withdraw取10元钱的逻辑同理。 介绍两个工具函数： 11-5 理解combine-reducers 如果系统中有多个reducer，可以通过这个工具函数combineReducers组合到一起使用： combineReducers接收多个reducers作为参数，最终形成一个封装过的函数，这个封装后的函数也是一个reducer，它会把action分别散发到不同的子reducer中。 11-6 理解bind-action-creators 有两种写法： 可以将写法2中的dispatch进行封装成： 其实不需要我们自己写，直接使用redux的工具函数bindActionCreators即可。 bindActionCreators具体为： 11-7 redux (它是独立于ui框架之外的状态管理框架) 整个流程代码演示 使用redux首先要createStore，但是createStore接收一个参数是reducer函数，所以首先要定义一个reducer reducer要接收一个参数state - 当前的状态，因为第一次执行时没有初始状态，所以要定义一个initialState，如果没有state传进来就用初始状态；第二个参数是action，代码中它有三种类型，不同type下，每次reducer执行都会返回一个新的对象，而不是直接修改已有的state，因为直接修改它，redux无法监听到这种变化。定义reducer后，就可以createStore了，它可以dispatch action了。 action函数（也叫actionCreator）返回了action对象 用store将action dispatch出去（代码中的subscribe监听了store的变化） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import React from &quot;react&quot;;import &#123; createStore &#125; from &quot;redux&quot;;function run() &#123; // Store initial state const initialState = &#123; count: 0 &#125;; // reducer const counter = (state = initialState, action) =&gt; &#123; switch (action.type) &#123; case &quot;PLUS_ONE&quot;: return &#123; count: state.count + 1 &#125;; case &quot;MINUS_ONE&quot;: return &#123; count: state.count - 1 &#125;; case &quot;CUSTOM_COUNT&quot;: return &#123; count: state.count + action.payload.count &#125;; default: break; &#125; return state; &#125;; const todos = (state = &#123;&#125;) =&gt; state; // Create store const store = createStore(counter); // Action creator function plusOne() &#123; // action return &#123; type: &quot;PLUS_ONE&quot; &#125;; &#125; function minusOne() &#123; return &#123; type: &quot;MINUS_ONE&quot; &#125;; &#125; function customCount(count) &#123; return &#123; type: &quot;CUSTOM_COUNT&quot;, payload: &#123; count &#125; &#125;; &#125; store.subscribe(() =&gt; console.log(store.getState())); store.dispatch(plusOne()); store.dispatch(minusOne()); store.dispatch(customCount(5));&#125;export default () =&gt; ( &lt;div&gt; &lt;button onClick=&#123;run&#125;&gt;Run&lt;/button&gt; &lt;p&gt;* 请打开控制台查看运行结果&lt;/p&gt; &lt;/div&gt;); 控制台打出的结果如下： 使用bindActionCreators后，上面部分代码可改为： 1234567import &#123; createStore, bindActionCreators &#125; from &quot;redux&quot;;function run() &#123; plusOne = bindActionCreators(plusOne, store.dispatch) // store.dispatch(plusOne()); plusOne()&#125; 运行结果同上。 使用combineReducers，它的作用是将多个reducer组合成一个新的reducer，上面部分代码可改为： 12345678910import &#123; createStore, combineReducers, bindActionCreators &#125; from &quot;redux&quot;;function run() &#123; // reducer const todos = (state = &#123;&#125;) =&gt; state const store = createStore(combineReducers(&#123; todos, counter &#125;))&#125; 运行结果变成： 12丨redux (3) 在react中使用redux12-1 connect 组件需要获取store中的数据，组件上的UI操作需要更新store中的数据，是通过connect连接起来的，redux提供了一个package，即react-redux，里面有个connect方法。 基本语法： 工作原理：高阶组件 上图中connect(mapStateToProps, mapDispatchToProps)(SidePanel)是通过高阶组件的方式connect已有的组件。 左边是组件树的状态，connect后会在这个数据逻辑里访问store和action；右边的更新逻辑是redux自身的逻辑：Actions分发出去到Reducers，然后更新Store，store会把数据传到高阶组件，高价组件会把数据传到需要用到store数据的组件树中。 12-2 具体在react中使用redux 思路分析： 定义后，需要思考我们需要关注的是store上的哪些数据，通过mapStateToProps()方法定义，参数是store的根节点（我们通过store.getState()得到的就是它）。 此处需要注意，如果我们把整个store绑定到这个组件中，那么store中任何节点的变化都会触发这个组件的更新，而只绑定到count上，只有当count发生变化时，这个组件才会被更新，所以在mapStateToProps中我们必须把它能访问的节点限制到最小范围，这样才能保证组件的高性能。 mapDispatchToProps()方法使组件能够访问redux的action，从而更新store。 使用时，我们需要在根节点上定义一个provider，它的值是store，这样它下面的所有节点都能访问到store 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import React from &quot;react&quot;;import &#123; bindActionCreators, createStore &#125; from &quot;redux&quot;;import &#123; Provider, connect &#125; from &quot;react-redux&quot;;// Store initial stateconst initialState = &#123; count: 0 &#125;;// reducerconst counter = (state = initialState, action) =&gt; &#123; switch (action.type) &#123; case &quot;PLUS_ONE&quot;: return &#123; count: state.count + 1 &#125;; case &quot;MINUS_ONE&quot;: return &#123; count: state.count - 1 &#125;; case &quot;CUSTOM_COUNT&quot;: return &#123; count: state.count + action.payload.count &#125;; default: break; &#125; return state;&#125;;// Create storeconst store = createStore(counter);// Action creatorfunction plusOne() &#123; // action return &#123; type: &quot;PLUS_ONE&quot; &#125;;&#125;function minusOne() &#123; return &#123; type: &quot;MINUS_ONE&quot; &#125;;&#125;export class Counter extends React.Component &#123; render() &#123; const &#123; count, plusOne, minusOne &#125; = this.props; return ( &lt;div className=&quot;counter&quot;&gt; &lt;button onClick=&#123;minusOne&#125;&gt;-&lt;/button&gt; &lt;span style=&#123;&#123; display: &quot;inline-block&quot;, margin: &quot;0 10px&quot; &#125;&#125;&gt; &#123;count&#125; &lt;/span&gt; &lt;button onClick=&#123;plusOne&#125;&gt;+&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;function mapStateToProps(state) &#123; return &#123; count: state.count &#125;;&#125;function mapDispatchToProps(dispatch) &#123; return bindActionCreators(&#123; plusOne, minusOne &#125;, dispatch);&#125;const ConnectedCounter = connect(mapStateToProps, mapDispatchToProps)(Counter);export default class CounterSample extends React.Component &#123; render() &#123; return ( &lt;Provider store=&#123;store&#125;&gt; &lt;ConnectedCounter /&gt; &lt;/Provider&gt; ); &#125;&#125; 效果如下： 13丨redux (4) 理解异步action以及redux中间件13-1 redux异步请求 在View上点击button，触发了一个Action 这个action可能不是一个标准的JavaScript对象，它可能描述了如何发送请求、如何处理它的结果 然后到Dispatcher，在dispatcher之前多了一个Middlewares中间件，它的作用是可以截获某种特殊类型的action，比如对ajax请求这样的action，可以有个叫做react-thunk这样的中间件进行处理，它接收到之后不是把它dispatch到reducer，而是去访问一个API，当api响应结果成功时，就发一个成功的action出去，如果失败就发个失败的action出去。（这种中间件的思路不是redux自带的，只是一种设计模式） 所以一个ajax请求的action到中间件后，会进行预处理，然后才把结果的action dispatch给reducer来更新store。 总结：一个异步action不是一个特殊类型的action，而是多个同步action的组合使用。 13-2 redux中间件 (middleware) 它有两个作用： 截获action 它判断是否需要截获这个action的机制是，这个action是不是一个Promise，是不是一个函数，如果是就会执行它，因为这个函数内部真正地会发ajax请求。 发出action 13-3 demo: 如何通过redux异步action发出异步请求?12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import axios from &#x27;axios&#x27;import &#123; EXAMPLES_FETCH_REDDIT_LIST_BEGIN, EXAMPLES_FETCH_REDDIT_LIST_SUCCESS, EXAMPLES_FETCH_REDDIT_LIST_FAILURE, EXAMPLES_FETCH_REDDIT_LIST_DISMISS_ERROR &#125; from &#x27;./constants&#x27;// 这个异步action产生了三种同步actionexport function fetchRedditList(args = &#123;&#125;) &#123; return dispatch =&gt; &#123; dispatch(&#123; type: EXAMPLES_FETCH_REDDIT_LIST_BEGIN &#125;) const promise = new Promise((resolve, reject) =&gt; &#123; const doRequest = axios.get(&#x27;http://www.reddit.com/r/reactjs.json&#x27;) doRequest.then( res =&gt; &#123; dispatch(&#123; type: EXAMPLES_FETCH_REDDIT_LIST_SUCCESS, data: res.data &#125;) resolve(res) &#125;, err =&gt; &#123; dispatch(&#123; type: EXAMPLES_FETCH_REDDIT_LIST_FAILURE, data: &#123; error: err &#125; &#125;) reject(err) &#125; ) &#125;) return promise &#125;&#125;export function reducer(state, action) &#123; switch(action.type) &#123; case EXAMPLES_FETCH_REDDIT_LIST_BEGIN: return &#123; ...state, fetchRedditListPending: true, fetchRedditListError: null &#125; case EXAMPLES_FETCH_REDDIT_LIST_SUCCESS: return &#123; ...state, redditList: action.data.data.children, fetchRedditListPending: false, fetchRedditListError: null &#125; case EXAMPLES_FETCH_REDDIT_LIST_FAILURE: return &#123; ...state, fetchRedditListPending: false, fetchRedditListError: action.data.error &#125; case EXAMPLES_FETCH_REDDIT_LIST_DISMISS_ERROR: return &#123; ...state, fetchRedditListError: null &#125; default: return state &#125;&#125; 14丨redux (5) 如何组织action和reducer14-1 [标准] 形式redux action的问题 所有Action放一个文件，会无限扩展 Action、Reducer分开，实现业务逻辑时需要来回切换 系统中有哪些Action不够直观 14-2 推荐新的方式: 单个action和reducer放在同一个文件中 好处： 易于开发：不用在action和reducer文件间来回切换 易于维护：每个action文件都很小，容易理解 易于测试：每个业务逻辑只需对应一个测试文件 易于理解：文件名就是action名字，文件列表就是action列表 14-3 demo 以todomvc为例 新建Actions问价夹，里面包含两个不同的action： addTodo.js: 1234567891011121314151617181920212223242526import &#123; TODO_ADD_TODO &#125; from &#x27;./constants&#x27;export function addTodo(text) &#123; return &#123; type: TODO_ADD_TODO, text &#125;&#125;export function reducer(state, action) &#123; switch(action.type) &#123; case TODO_ADD_TODO: return &#123; ...state, todos: [ ...state.todos, &#123; id: state.todos.reduce((maxId, todo) =&gt; Math.max(todo.id, maxId), -1) + 1, completed: false, text: action.text &#125; ] &#125; default: retrun state &#125;&#125; clearCompleted.js: 1234567891011121314151617import &#123; TODO_CLEAR_COMPLETED &#125; from &#x27;./constants&#x27;export function clearCompleted() &#123; return &#123; type: TODO_CLEAR_COMPLETED &#125;&#125;export function reducer(state, action) &#123; switch(action.type) &#123; case TODO_CLEAR_COMPLETED: return &#123; ...state, todos: state.todos.filter(todo =&gt; todo.completed === false) &#125; default: return state &#125;&#125; 如何load这些部分呢？新建Misc/redux文件夹，里面包含: actions.js把所有的action导进来再导出去： 12export &#123; addTodo &#125; from &#x27;./addTodo&#x27;export &#123; completeTodo &#125; from &#x27;./completeTodo&#x27; 1234567891011121314151617181920 reducer.js从不同的action文件中把所有的都导进来再导出去： &#96;&#96;&#96;js import initialState from &#39;.&#x2F;initialState&#39; import &#123; reducer as addTodoReducer &#125; from &#39;.&#x2F;addTodo&#39; import &#123; reducer as completeTodoReducer &#125; from &#39;.&#x2F;completeTodo&#39; const reducers &#x3D; &#123; addTodoReducer, completeTodoReducer &#125; export default function reducer(state &#x3D; initialState, action) &#123; let newState switch(action.type) &#123; default: newState &#x3D; state break &#125; return reducers.reduce((s, r) &#x3D;&gt; r(s, action), newState) &#125; 15丨redux (6) 理解不可变数据 (immutability)15-1 不可变数据​ 它是redux的一个运行基础，它的含义是不可以直接修改它的值，而是要通过复制它的值并且通过产生一个新对象的方式来得到一个新数据，它包含了修改的部分。 ​ 如图，假设左边是个状态树，如果要更新黄色节点上的某个状态的值，首先要产生一个全新对象(如右图)，在这个路径上(绿色部分)所有对象都处于一个被修改的状态，但是其他节点是不发生变化的。不可变数据不能直接修改的，非要修改就必须将它进行一份复制，无论是浅复制还是深复制，然后去包含将要修改的部分。 15-2 为何需要不可变数据 原因： 性能优化 当一个store需要变化时，我们需要通知所有组件更新，store的所有变化都是由action触发，触发在原来旧的state上，形成一个新的state，这个新的state已不是原来那个state，它们分别是两个完全不同的对象。当旧state和新state不是同一个对象时，我们就知道这个store发生了变化，不需要去比较它其中的值是否变化，只需要比较两个引用的状态是否一样，这可以达到性能优化的目的。 redux中的store都是不可变数据，每个节点都是不可变数据，当一个组件绑定在某个节点上，只需判断前一个状态和后一个的引用是否相等，就能知道当前的store有没有变化，从而决定是否要更新组件。不需要做深层次遍历每个值是否相等，只要通过引用比较就可以达到这个目的。 易于调试和跟踪 当store发生变化时，任何时刻都可以记录之前和之后的状态，并且能够计算得到它们diff的值，这样可以在调试时看到前面和后面的状态。 易于推测 在任何时刻都可以推测出store是由什么引起的变化，store一定是由action触发，action之前和之后的状态分别是什么，通过这个值的比较可以很容易地判断当前的action是否被正确地处理。 15-3 如何操作不可变数据 原生写法：&#123;...&#125;(浅复制)，Object.assign 性能最高 场景：todoList中要增加一条todoItem immutability-helper 主要用于层次比较深的节点的更新 immer 性能差，不推荐 16丨react router (1) 路由不只是页面切换 更是代码组织方式16-1 为什么需要路由? 单页应用需要进行页面切换（这时候浏览器不刷新） 通过URL可以定位到页面 更有语义的组织资源 因为每个页面的业务功能其实是高内聚松耦合的，通过URL可以将它们做个很好的隔离，不仅是业务上的功能，包括做lazyLoad或者其它的资源组织，路由都可以帮助到。 React Router和React、Redux合称为React全家桶。 16-2 路由实现的基本架构 路由定义 通过react标记或配置文件来定义路由 Router 定义好的路由通过React Router的解析，根据URL的地址返回不同的组件 页面布局 定义一个组件容器，通常是页面布局的一部分，由React Router控制里面展示什么，当URL变化时，其实只是组件容器中的内容发生了变化，左边的导航栏或顶部的header实际上不变。 原理：React Router是在一个组件容器中根据URL判断当前应该显示什么样的组件，去实现一个路由的功能。 16-3 react router的实现 有个Router标记告诉React Router这下面可能会有其他Route的定义，需要由它去解析。 page-container就是由React Router控制的一个容器，里面通过Route配置路由的定义，它会指定一个path和component，意味着当前URL是这个path时用这个component去展示。 12345678910111213141516171819202122232425262728293031323334import React from &quot;react&quot;;import &#123; HashRouter as Router, Route, Link &#125; from &quot;react-router-dom&quot;;const Home = () =&gt; &lt;h1&gt;Home&lt;/h1&gt;;const Hello = () =&gt; &lt;h1&gt;Hello&lt;/h1&gt;;const About = () =&gt; &lt;h1&gt;About Us&lt;/h1&gt;;export default class RouterSample extends React.PureComponent &#123; render() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;ul id=&quot;menu&quot;&gt; &lt;li&gt; &lt;Link to=&quot;/home&quot;&gt;Home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&quot;/hello&quot;&gt;Hello&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&quot;/about&quot;&gt;About&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div id=&quot;page-container&quot;&gt; &lt;Route path=&quot;/home&quot; component=&#123;Home&#125; /&gt; &lt;Route path=&quot;/hello&quot; component=&#123;Hello&#125; /&gt; &lt;Route path=&quot;/about&quot; component=&#123;About&#125; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/Router&gt; ); &#125;&#125; 16-4 react router的特性​ 和后端路由对比，React Router的特性有： 声明式路由定义 这个Route像使用React的一个标记一样，是作为一个tag去定义的。 动态路由 路由是在页面render时被实时解析的。 16-5 三种路由实现方式 URL路径 大部分情况采用本方式，但低版本浏览器可能不支持，导致切换路由不刷新，就要采取hash路由。 hash路由 不是通过/，而是通过#，支持低版本浏览器。 内存路由 意思是路由并不会反映到URL上，即点击切换路由，URL并没有发生变化，但页面内容变了，这是因为路由的状态完全存在内存中。 通常在做服务器端渲染时使用，前端也可以用，比如在上例中补充： 123456789import &#123; MemoryRouter &#125; from &#x27;react&#x27;export default class RouterSample extends React.PureComponent &#123; render() &#123; return ( &lt;MemoryRouter&gt;...&lt;/MemoryRouter&gt; ) &#125;&#125; 16-6 基于路由配置进行资源组织​ 主要有三个目的： 实现业务逻辑的松耦合 把页面相关的部分都组织在一起，无论是业务上的逻辑、代码还是懒加载lazyLoad，都可以基于路由实现。 易于扩展、重构和维护 没有把所有的路由都放到业务逻辑中实现，而是把它抽象出来，通过React Router来实现路由的配置，这样再增加新页面时就会非常清楚，去增加路由的配置即可。 因为业务的逻辑单元是一个个小的页面，而不单是个整体，所以容易重构和维护。 路由层面实现lazyLoad 如果我们在统一的地方定义路由，去加载不同组件时，都可以在那个点实现一个lazyLoad，在展示第一个页面时效率会比较高，速度也比较快。 16-7 react router的核心api &lt;Link&gt; 普通链接，不会触发浏览器刷新 12import &#123; Link &#125; from &#x27;react-router-dom&#x27;&lt;Link to=&quot;/about&quot;&gt;About&lt;/Link&gt; 它展现出的效果就和a标签在html中的效果是一样的。 &lt;NavLink&gt; 类似Link，但是会添加当前选中状态 1&lt;NavLink to=&quot;/faq&quot; activeClassName=&quot;selected&quot;&gt;FAQs&lt;/NavLink&gt; &lt;Prompt&gt; 满足条件时提示用户是否离开当前页面 12import &#123; Prompt &#125; from &#x27;react-router&#x27;&lt;Prompt when=&#123;formIsHalfFilledOut&#125; message=&quot;Are you sure you want to leave?&quot; /&gt; 做用户页面切换时的一个确认的操作，比如点击一个未填完的表单中的某个链接，可以用它询问提示。 when属性表示什么时候需要提示，message表示提示的信息。 &lt;Redirect&gt; 重定向当前页面，例如登录判断 12345678import &#123; Route, Redirect &#125; from &#x27;react-router&#x27;&lt;Route exact path=&quot;/&quot; render=&#123;() =&gt; &#123; loggedIn ? ( &lt;Redirect to=&quot;/dashboard&quot; /&gt; ) : ( &lt;PublicHomePage /&gt; )&#125;&#125; /&gt; &lt;Route&gt; 路由配置的核心标记，路径匹配时显示对应组件 1234567import &#123; BrowserRouter as Router, Route &#125; from &#x27;react-router-dom&#x27;&lt;Router&gt; &lt;div&gt; &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125; /&gt; &lt;Route path=&quot;/news&quot; component=&#123;NewsFeed&#125; /&gt; &lt;/div&gt;&lt;/Router&gt; exact属性表示是否精确匹配path。 单独使用时并不是排他的，比如定义了两个Route，它的path都可以匹配当前的路径，两个组件都会同时显示。 &lt;Switch&gt; 只显示第一个匹配的路由 1234567import &#123; Switch, Route &#125; from &#x27;react-router&#x27;&lt;Switch&gt; &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125; /&gt; &lt;Route path=&quot;/about&quot; component=&#123;About&#125; /&gt; &lt;Route path=&quot;/:user&quot; component=&#123;User&#125; /&gt; &lt;Route component=&#123;NoMatch&#125; /&gt;&lt;/Switch&gt; 主要用来改变上述的多匹配的行为，如果把Route放到Switch中，只有第一条匹配的Route被显示，下面的就不会再render对应的组件了。 17丨react router (2) 参数定义以及嵌套路由的使用场景17-1 通过url传递参数 如何通过URL传递参数：&lt;Route path=&quot;/topic/:id&quot; ... /&gt; 将参数id作为URL路径的一部分比作为查询字符串的方式对搜索引擎更加友好，看上去也更加有语义。 如何获取参数：this.props.match.params 123456789101112131415161718192021222324252627282930import React from &quot;react&quot;;import &#123; BrowserRouter as Router, Route, Link&#125; from &quot;react-router-dom&quot;;// 会传递match这样的props给你的组件const Topic = (&#123; match &#125;) =&gt; ( &lt;h1&gt;Topic &#123;match.params.id&#125;&lt;/h1&gt;);export default class RouterParams extends React.PureComponent &#123; render() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;ul id=&quot;menu&quot;&gt; &lt;li&gt;&lt;Link to=&quot;/topic/1&quot;&gt;Topic 1&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/topic/2&quot;&gt;Topic 2&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/topic/3&quot;&gt;Topic 3&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div id=&quot;page-container&quot;&gt; &lt;Route path=&quot;/topic/:id&quot; component=&#123;Topic&#125; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/Router&gt; ); &#125;&#125; https://github.com/pillarjs/path-to-regexp 何时需要URL参数：页面状态尽量通过URL参数定义 17-2 嵌套路由 每个React组件都可以是路由容器 React Router的声明式语法可以方便定义嵌套路由 demo如下： 点击红框链接，红框内容及URL红线部分相应变化；点击绿框链接，绿框内容及URL绿色部分相应变化。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import React from &quot;react&quot;;import &#123; BrowserRouter as Router, Route, Link &#125; from &quot;react-router-dom&quot;;const Category = (&#123; match &#125;) =&gt; ( &lt;h1&gt;Sub Category &#123;match.params.subId&#125;&lt;/h1&gt;);const SubCategory = (&#123; match &#125;) =&gt; ( &lt;div&gt; &lt;h1&gt;Category &#123;match.params.id&#125;&lt;/h1&gt; &lt;ul id=&quot;menu&quot;&gt; &lt;li&gt; &lt;Link to=&#123;`/category/$&#123;match.params.id&#125;/sub/1`&#125;&gt; Sub Category 1 &lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&#123;`/category/$&#123;match.params.id&#125;/sub/2`&#125;&gt; Sub Category 2 &lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=&#123;`/category/$&#123;match.params.id&#125;/sub/3`&#125;&gt; Sub Category 3 &lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div id=&quot;page-container-2&quot;&gt; &lt;Route path=&quot;/category/:id/sub/:subId&quot; component=&#123;Category&#125; /&gt; &lt;/div&gt; &lt;/div&gt;);export default class NestedRoute extends React.PureComponent &#123; render() &#123; return ( &lt;Router&gt; &lt;div&gt; &lt;ul id=&quot;menu&quot;&gt; &lt;li&gt;&lt;Link to=&quot;/category/1&quot;&gt;Category 1&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/category/2&quot;&gt;Category 2&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/category/3&quot;&gt;Category 3&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div id=&quot;page-container&quot;&gt; &lt;Route path=&quot;/category/:id&quot; component=&#123;SubCategory&#125; /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/Router&gt; ); &#125;&#125; 18丨ui组件库对比和介绍18-1 ui组件库的对比 Ant.Design (对比后更推荐它) 蚂蚁金服前端团队开发的，服务于企业级产品的设计体系。 Material UI Google提供的，它没有具体的应用场景，设计风格更为时尚、花哨 Semantic UI 非常具有历史性，在jq时代就产生了，倾向于将UI作为一种language描述，如果从来没用过建议别用。 18-2 选择ui库的考虑因素 组件库是否完善和齐全 尽量能有对应组件直接拿来用，而不是还要自己去实现 样式风格是否符合业务需求 企业级应用对UI的要求是简洁明了，数据能够展现的比较密集、合理，Ant.Design可能更加符合； 移动端面向最终消费者的应用要求UI更加好看，每个button和字体要求比较大，可能Material UI更加符合。 API设计是否便捷和灵活 关系到我们用这个组件库开发效率是否高、是否方便 技术支持是否完善 主要体现在两方面：技术文档是否非常齐全、在github上提些问题能否快速解答 开发是否活跃 这个库是否有个稳定的团队进行快速地迭代和维护，保证遇到bug或需要一些功能时得到修复和满足 19丨使用next (使用它创建react同构应用)19-1 什么是同构应用? 一个web应用分为浏览器端和服务器端，对于同构应用来说，它分为初次发送请求和后面的后续请求，对于第一次请求来说，会由服务器端完成页面的渲染（页面的内容是完全使用服务器端render出来的，包括所有的html和css），然后返回到浏览器端，浏览器就会直接显示页面的内容以及UI，浏览器不需要执行任何JavaScript操作就可以直接把UI渲染出来，所以第一次打开页面的速度非常快。后续浏览器端的表现就像个单页应用，不再需要浏览器的刷新，所有的UI操作都是由前端来完成，包括前端的路由等等。 因为React具有服务器端渲染能力，所以它实现同构应用是非常自然和简单的。 19-2 如何使用nextjs开发服务器端渲染的react应用 nextjs的页面 nextjs在开发时是遵循一定的约定的： 页面都必须放到pages目录下，这个目录下的所有js文件都是一个React组件，对应页面路由的导航。当访问这个页面下的路径时，就会把对应的组件渲染出来。 static目录下放所有的静态文件 page具有一个特殊的静态方法getInitialProps()，在这个方法中可以获取一些初始数据，比如从URL中拿参数，作为组件的属性去使用 demo，官方教程： step1 安装：$ npm install -S next react react-dom step2 指定npm中的script： 12345&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;next dev&quot;, &quot;build&quot;: &quot;next build&quot;, &quot;start&quot;: &quot;next start&quot;&#125; 运行$ npm run dev就能启动开发环境，默认通过3000端口访问。 19-3 在页面中使用其它react组件 在nextjs中页面也是标准的node模块，可使用其它React组件 页面会针对性打包，仅包含其引入的组件 这样每个页面不会加载额外的资源，性能会比较好。 19-4 使用link实现同构路由 使用“next/link”定义链接 点击链接时页面不会刷新 使用prefetch预加载目标资源 一般只有点过去才会加载链接后面的组件内容，这个属性可以使nextjs在打包时就获取链接对应的组件并预加载所有的js内容，这样可以提高页面切换的速度，但是prefetch并不会加载服务器端api的数据，如果组件中要加载api数据，需要等待一段时间才显示。 使用replace属性替换URL 19-5 动态加载页面 (即lazy-load)​ dynamic这个函数告诉nextjs，这个import的组件hello2需要lazyLoad的，它会产生一个新的组件DynamicComponentWithCustomLoading，它是加载实际组件的容器，我们render的实际上是这个封装后的组件，这个组件一旦render就会动态加载其中包含的内容。 20丨使用jest和enzyme等工具进行单元测试20-1 react让前端单元测试变得更加容易原因有三： React应用很少需要访问浏览器API 虚拟DOM可以在Nodejs环境运行和测试 Redux隔离了状态管理，纯数据层单元测试 20-2 单元测试涉及的工具 Jest: facebook开源的JS单元测试框架 它的特性是零配置，直接开始单元测试，而且对react做了很好的支持 JS DOM: 浏览器环境的NodeJs模拟 Enzyme: React组件渲染和测试 nock: 模拟HTTP请求 sinon: 函数模拟和调用跟踪 istanbul: 单元测试覆盖率 21丨常用开发调试工具21-1 eslint 用于做语法风格的检查 使用.eslintrc进行规则的配置或放在package.json中，一般选择前者 使用airbnb的JavaScript代码风格，见github 21-2 prettier-强烈推荐 facebook出的用于格式化代码（会自动帮助修改） 保证更容易写出风格一致的代码 使用.prettierrc定义规则 21-3 react devtool 用来调试React的chrome插件 可以以React组件树的形式观察页面结构 勾选Highlight Updates，操作时，页面中都会标识出哪些组件发生了渲染 21-4 redux devtool 用来调试Redux的chorme插件 可以观察到当前store的完整状态，操作时能看到这个action及其引起了什么变化(Diff) 有个非常牛的功能叫做time machine或time fly，时间线，点击action可以直接跳到(点击Jump)该action引起变化时的状态 还可以自动生成测试的代码，比如想测试某个action是否正确，点击Test就可以看到它的代码逻辑，并把它直接cv到单元测试文件中稍作修改就能使用 22丨前端项目的理想架构即可维护 可扩展 可测试 易开发 易构建22-1 易于开发​ 判断一个技术栈是否易于开发，需要考虑以下几点： 开发工具是否完善 生态圈是否繁荣 社区是否活跃 22-2 易于扩展 增加新功能是否容易 新功能是否会显著增加系统复杂度 22-3 易于维护 代码是否容易理解 文档是否健全 22-4 易于测试 功能的分层是否清晰 副作用少 尽量使用纯函数 React组件基本上可以理解为一个纯函数，它的输出完全取决于它的输入 22-5 易于构建 使用通用技术和架构 构建工具的选择 23丨拆分复杂度 (1) 按领域模型 (feature) 组织代码 降低耦合度23-1 将业务逻辑拆分成高内聚松耦合的模块未完待续……","categories":[{"name":"React","slug":"React","permalink":"https://scarlett9354.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://scarlett9354.github.io/tags/React/"}]}],"categories":[{"name":"算法","slug":"算法","permalink":"https://scarlett9354.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"React","slug":"React","permalink":"https://scarlett9354.github.io/categories/React/"},{"name":"工作相关","slug":"工作相关","permalink":"https://scarlett9354.github.io/categories/%E5%B7%A5%E4%BD%9C%E7%9B%B8%E5%85%B3/"},{"name":"ES6-7","slug":"ES6-7","permalink":"https://scarlett9354.github.io/categories/ES6-7/"},{"name":"Vue","slug":"Vue","permalink":"https://scarlett9354.github.io/categories/Vue/"},{"name":"性能优化","slug":"性能优化","permalink":"https://scarlett9354.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"Node.js","slug":"Node-js","permalink":"https://scarlett9354.github.io/categories/Node-js/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://scarlett9354.github.io/categories/TypeScript/"},{"name":"webpack","slug":"webpack","permalink":"https://scarlett9354.github.io/categories/webpack/"},{"name":"HTTP","slug":"HTTP","permalink":"https://scarlett9354.github.io/categories/HTTP/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://scarlett9354.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"React","slug":"React","permalink":"https://scarlett9354.github.io/tags/React/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://scarlett9354.github.io/tags/TypeScript/"},{"name":"React Hook","slug":"React-Hook","permalink":"https://scarlett9354.github.io/tags/React-Hook/"},{"name":"ES6","slug":"ES6","permalink":"https://scarlett9354.github.io/tags/ES6/"},{"name":"ES7","slug":"ES7","permalink":"https://scarlett9354.github.io/tags/ES7/"},{"name":"vue","slug":"vue","permalink":"https://scarlett9354.github.io/tags/vue/"},{"name":"React16.4","slug":"React16-4","permalink":"https://scarlett9354.github.io/tags/React16-4/"},{"name":"vue-router","slug":"vue-router","permalink":"https://scarlett9354.github.io/tags/vue-router/"},{"name":"vuex","slug":"vuex","permalink":"https://scarlett9354.github.io/tags/vuex/"},{"name":"性能优化","slug":"性能优化","permalink":"https://scarlett9354.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"Node.js","slug":"Node-js","permalink":"https://scarlett9354.github.io/tags/Node-js/"},{"name":"webpack","slug":"webpack","permalink":"https://scarlett9354.github.io/tags/webpack/"},{"name":"http","slug":"http","permalink":"https://scarlett9354.github.io/tags/http/"},{"name":"https","slug":"https","permalink":"https://scarlett9354.github.io/tags/https/"}]}